<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「工作日还有多少天，休息日还剩几小时」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#regex%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">regex的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#regex%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">regex的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E8%AF%8D%E5%8C%B9%E9%85%8D"><span class="toc-text">全词匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%8C%B9%E9%85%8D"><span class="toc-text">搜索匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%8C%B9%E9%85%8D"><span class="toc-text">提取匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%A4%9A%E4%B8%AA%E5%8C%B9%E9%85%8D"><span class="toc-text">提取多个匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3result"><span class="toc-text">迭代result</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%8C%B9%E9%85%8D%E4%B8%B2"><span class="toc-text">迭代匹配串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%8C%B9%E9%85%8D"><span class="toc-text">替换匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#regex%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">regex的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%AE%E7%AE%B1regex%E7%A4%BA%E4%BE%8B"><span class="toc-text">邮箱regex示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		regex 正则表达式
	</div>
	
	<div class="page-date">
		2021-04-01
	</div>
	
	<div class="category-area">
		
			 
				「
				<div class="category">
					<a href="/categories/C++">C++</a>
				
				</div>
				」
			
		
	</div>
	
	<div class="content">
		<p>C++11 新增了正则表达式的标准库支持</p>
<span id="more"></span>

<h2 id="regex的介绍"><a href="#regex的介绍" class="headerlink" title="regex的介绍"></a>regex的介绍</h2><p>C++11 自带了 6 种正则表达式语法的支持</p>
<ol>
<li> ECMAScript</li>
<li> basic</li>
<li> extended</li>
<li> awk</li>
<li> grep</li>
<li> egrep</li>
</ol>
<p>C++11 默认使用 ECMAScript 语法，这也是 6 种语法中最强大的，假如想使用其他 5 种语法，只需在声明 <code>regex</code> 对象时指定即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">regex <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;^a.&quot;</span>, regex_constants::grep)</span></span>;<br></code></pre></td></tr></table></figure>

<p>在C++中，有三种正则可以选择使用</p>
<ul>
<li>  C ++regex</li>
<li>  C regex</li>
<li>  boost regex </li>
</ul>
<p>如果在windows下开发C++，默认不支持后面两种正则，如果想快速应用，显然C++ regex 比较方便使用。</p>
<h2 id="regex的使用"><a href="#regex的使用" class="headerlink" title="regex的使用"></a>regex的使用</h2><h3 id="全词匹配"><a href="#全词匹配" class="headerlink" title="全词匹配"></a>全词匹配</h3><p><code>regex_match</code>是正则表达式匹配的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a = <span class="hljs-string">&quot;modao&quot;</span>;<br>    <span class="hljs-function">regex <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;m(.*)&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">regex_match</span>(a, e))cout &lt;&lt; <span class="hljs-string">&quot;modao&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="搜索匹配"><a href="#搜索匹配" class="headerlink" title="搜索匹配"></a>搜索匹配</h3><p>regex_search和regex_match的主要区别是：regex_match是全词匹配，而regex_search是搜索其中匹配的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">regex <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;abc*&quot;</span>)</span></span>;<br>  <span class="hljs-keyword">bool</span> m = <span class="hljs-built_in">regex_search</span>(<span class="hljs-string">&quot;abccc&quot;</span>, e);<br><br>  <span class="hljs-comment">// 输出 yes</span><br>  cout &lt;&lt; (m ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="提取匹配"><a href="#提取匹配" class="headerlink" title="提取匹配"></a>提取匹配</h3><p>想要提取出匹配的部分，就需要用到 <code>match_results</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;Email a@bc.com abc&quot;</span>)</span></span>;<br><br>  <span class="hljs-comment">// 等同于 match_results&lt;string&gt;</span><br>  smatch m; <br><br>  <span class="hljs-function">regex <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;([[:w:]]+)@([[:w:]]+\\.com)&quot;</span>)</span></span>;<br>  <span class="hljs-keyword">bool</span> found = <span class="hljs-built_in">regex_search</span>(str, m, e);<br><br>  <span class="hljs-comment">// m.size=3, 存储了 3 个 result</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;m.size=&quot;</span> &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>; n&lt;m.<span class="hljs-built_in">size</span>(); n++)&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;m[&quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;]=&quot;</span> &lt;&lt; m[n].<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//等价写法 m.str(n), *(m.begin()+n) </span><br>  &#125;<br>  <span class="hljs-comment">//匹配项的前缀和后缀</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;m.prefix=&quot;</span> &lt;&lt; m.<span class="hljs-built_in">prefix</span>().<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-string">&quot;m.suffix=&quot;</span> &lt;&lt; m.<span class="hljs-built_in">suffix</span>().<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">迭代 match_results, 输出</span><br><span class="hljs-comment">m[0]=a@bc.com (整个匹配)</span><br><span class="hljs-comment">m[1]=a (第1个group)</span><br><span class="hljs-comment">m[2]=bc.com (第2个group)</span><br><span class="hljs-comment">m.prefix=Email </span><br><span class="hljs-comment">m.suffix= abc</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h3 id="提取多个匹配"><a href="#提取多个匹配" class="headerlink" title="提取多个匹配"></a>提取多个匹配</h3><h4 id="迭代result"><a href="#迭代result" class="headerlink" title="迭代result"></a>迭代result</h4><p>假如我们想要匹配的字符串中，有多个子串都可以匹配正则表达式，并且我们想把这些子串全部找出来，例如一个字符串中包含多个邮箱地址，那么就需要用到 <code>regex_iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;a@bc.com, d@ef.com, aa@b.com&quot;</span>)</span></span>;<br><br>  <span class="hljs-function">regex <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;([[:w:]]+)@([[:w:]]+\\.com)&quot;</span>)</span></span>;<br><br>  <span class="hljs-comment">// 定义 regex_iteraror</span><br>  <span class="hljs-function">sregex_iterator <span class="hljs-title">pos</span><span class="hljs-params">(str.cbegin(), str.cend(), e)</span></span>; <br>  <span class="hljs-comment">// C++惯例: 默认构造的迭代器表示序列结束</span><br>  sregex_iterator end;<br><br>  <span class="hljs-keyword">for</span> (; pos!=end; pos++) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;email=&quot;</span> &lt;&lt; pos-&gt;<span class="hljs-built_in">str</span>(<span class="hljs-number">0</span>) <br>      &lt;&lt; <span class="hljs-string">&quot;, user=&quot;</span> &lt;&lt; pos-&gt;<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>) <br>      &lt;&lt; <span class="hljs-string">&quot;, domain=&quot;</span> &lt;&lt; pos-&gt;<span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>) <br>      &lt;&lt; endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">email=a@bc.com, user=a, domain=bc.com</span><br><span class="hljs-comment">email=d@ef.com, user=d, domain=ef.com</span><br><span class="hljs-comment">email=aa@bb.com, user=aa, domain=b.com</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>如上我们可以看到，<code>regex_iterator</code> 其实就是迭代字符串中所有正则表达式匹配的 <code>match_results</code>。</p>
<h4 id="迭代匹配串"><a href="#迭代匹配串" class="headerlink" title="迭代匹配串"></a>迭代匹配串</h4><p>除此之外，C++ 还提供了另一种迭代器 <code>regex_token_iterator</code>。</p>
<p>不同的是，<code>regex_token_iterator</code> 迭代的是所有正则表达式匹配中的指定子表达式，或迭代未匹配的子字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;a@bc.com, d@ef.com, aa@bb.com&quot;</span>)</span></span>;<br><br>  <span class="hljs-function">regex <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;([[:w:]]+)@([[:w:]]+\\.com)&quot;</span>)</span></span>;<br><br>  <span class="hljs-comment">// 定义regex_token_iterator</span><br>  <span class="hljs-function">sregex_token_iterator <span class="hljs-title">pos</span><span class="hljs-params">(str.cbegin(), str.cend(), e)</span></span>; <br>  sregex_token_iterator end; <span class="hljs-comment">//序列结束</span><br>  <br>  <span class="hljs-keyword">for</span> (; pos!=end; pos++) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Matched:  &quot;</span> &lt;&lt; *pos &lt;&lt; endl;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Matched: a@bc.com</span><br><span class="hljs-comment">Matched: d@ef.com</span><br><span class="hljs-comment">Matched: aa@bb.com</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>我们可以修改 <code>pos</code> 的定义，使它每次迭代 <code>match_results</code> 的第 2 个 group</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第 4 个参数表示第几个 group</span><br><span class="hljs-function">sregex_token_iterator <span class="hljs-title">pos</span><span class="hljs-params">(str.cbegin(), str.cend(), e, <span class="hljs-number">2</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>值得注意的是，如果我们把这里的参数设为 -1，则迭代字符串中所有不匹配正则表达式的部分，相当于用正则表达式切割字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;a bb   cd&quot;</span>)</span></span>;<br><br>  <span class="hljs-function">regex <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;\\s+&quot;</span>)</span></span>; <span class="hljs-comment">// 匹配空格</span><br><br>  <span class="hljs-comment">// 迭代不匹配正则表达式的部分</span><br>  <span class="hljs-function">sregex_token_iterator <span class="hljs-title">pos</span><span class="hljs-params">(str.cbegin(), str.cend(), e, <span class="hljs-number">-1</span>)</span></span>;<br>  sregex_token_iterator end;<br>  <br>  <span class="hljs-keyword">for</span> (; pos!=end; pos++) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Matched: &quot;</span> <br>      &lt;&lt; *pos &lt;&lt; endl;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Matched: a</span><br><span class="hljs-comment">Matched: bb</span><br><span class="hljs-comment">Matched: cd</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h3 id="替换匹配"><a href="#替换匹配" class="headerlink" title="替换匹配"></a>替换匹配</h3><p>正则表达式还有一个常用的场景——字符串替换。C++ 中我们可以使用 <code>regex_replace</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;a@bc.com, d@ef.com, aa@bb.com&quot;</span>)</span></span>;<br><br>  <span class="hljs-function">regex <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;([[:w:]]+)@([[:w:]]+\\.com)&quot;</span>)</span></span>;<br>  <span class="hljs-comment">//原字符串，匹配规则，替换规则</span><br>  cout &lt;&lt; <span class="hljs-built_in">regex_replace</span>(str, e, <span class="hljs-string">&quot;$1 is on $2&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">a is on bc.com, d is on ef.com, aa is on bb.com<br></code></pre></td></tr></table></figure>

<h2 id="regex的语法"><a href="#regex的语法" class="headerlink" title="regex的语法"></a>regex的语法</h2><blockquote>
<p>  正则表达式的括号：</p>
<p>  ()匹配并捕获</p>
<p>  []匹配字符组里的每一个字符</p>
<p>  {}匹配出现的次数</p>
</blockquote>
<p>C++ regex正则表达式的规则和其他编程语言差不多，如下：</p>
<p><strong>特殊字符</strong>（用于匹配很难形容的字符）:</p>
<table>
<thead>
<tr>
<th>characters</th>
<th>description</th>
<th>matches</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>not newline</td>
<td>any character except <em>line terminators</em> (LF, CR, LS, PS).</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td>tab (HT)</td>
<td>a horizontal tab character (same as <strong>\u0009</strong>).</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td>newline (LF)</td>
<td>a newline (line feed) character (same as <strong>\u000A</strong>).</td>
</tr>
<tr>
<td><strong>\v</strong></td>
<td>vertical tab (VT)</td>
<td>a vertical tab character (same as <strong>\u000B</strong>).</td>
</tr>
<tr>
<td><strong>\f</strong></td>
<td>form feed (FF)</td>
<td>a form feed character (same as <strong>\u000C</strong>).</td>
</tr>
<tr>
<td><strong>\r</strong></td>
<td>carriage return (CR)</td>
<td>a carriage return character (same as <strong>\u000D</strong>).</td>
</tr>
<tr>
<td><strong>\c</strong>letter</td>
<td>control code</td>
<td>a control code character whose <em>code unit value</em> is the same as the remainder of dividing the <em>code unit value</em> of <em>letter</em> by 32.  For example: \ca is the same as \u0001, \cb the same as \u0002, and so on…</td>
</tr>
<tr>
<td><strong>\x</strong>hh</td>
<td>ASCII character</td>
<td>a character whose <em>code unit value</em> has an hex value equivalent to the two hex digits <em>hh</em>.  For example: \x4c is the same as L, or \x23 the same as #.</td>
</tr>
<tr>
<td><strong>\u</strong>hhhh</td>
<td>unicode character</td>
<td>a character whose <em>code unit value</em> has an hex value equivalent to the four hex digits<em>hhhh</em>.</td>
</tr>
<tr>
<td><strong>\0</strong></td>
<td>null</td>
<td>a null character (same as <strong>\u0000</strong>).</td>
</tr>
<tr>
<td>\int</td>
<td>backreference</td>
<td>the result of the submatch whose opening parenthesis is the <em>int</em>-th (<em>int</em> shall begin by a digit other than 0). See groups below for more info.</td>
</tr>
<tr>
<td><strong>\d</strong></td>
<td>digit</td>
<td>a decimal digit character</td>
</tr>
<tr>
<td><strong>\D</strong></td>
<td>not digit</td>
<td>any character that is not a decimal digit character</td>
</tr>
<tr>
<td><strong>\s</strong></td>
<td>whitespace</td>
<td>a whitespace character</td>
</tr>
<tr>
<td><strong>\S</strong></td>
<td>not whitespace</td>
<td>any character that is not a whitespace character</td>
</tr>
<tr>
<td><strong>\w</strong></td>
<td>word</td>
<td>an alphanumeric or underscore character</td>
</tr>
<tr>
<td><strong>\W</strong></td>
<td>not word</td>
<td>any character that is not an alphanumeric or underscore character</td>
</tr>
<tr>
<td>\character</td>
<td>character</td>
<td>the character <em>character</em> as it is, without interpreting its special meaning within a regex expression.  Any <em>character</em> can be escaped except those which form any of the special character sequences above.  Needed for: ^ $ \ . * + ? ( ) [ ] { } |</td>
</tr>
<tr>
<td><strong>[class]</strong></td>
<td>character class</td>
<td>the target character is part of the class</td>
</tr>
<tr>
<td><strong>[^class]</strong></td>
<td>negated character class</td>
<td>the target character is not part of the class</td>
</tr>
</tbody></table>
<p>注意了，在C++反斜杠字符（\）会被转义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::regex <span class="hljs-title">e1</span> <span class="hljs-params">(<span class="hljs-string">&quot;\\d&quot;</span>)</span></span>; <span class="hljs-comment">// \d -&gt; 匹配数字字符</span><br><span class="hljs-function">std::regex <span class="hljs-title">e2</span> <span class="hljs-params">(<span class="hljs-string">&quot;\\\\&quot;</span>)</span></span>; <span class="hljs-comment">// \\ -&gt; 匹配反斜杠字符</span><br></code></pre></td></tr></table></figure>

<p>数量<strong>：</strong></p>
<table>
<thead>
<tr>
<th>characters</th>
<th>times</th>
<th>effects</th>
</tr>
</thead>
<tbody><tr>
<td>*****</td>
<td>0 or more</td>
<td>The preceding atom is matched 0 or more times.</td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>1 or more</td>
<td>The preceding atom is matched 1 or more times.</td>
</tr>
<tr>
<td><strong>?</strong></td>
<td>0 or 1</td>
<td>The preceding atom is optional (matched either 0 times or once).</td>
</tr>
<tr>
<td><strong>{int}</strong></td>
<td><em>int</em></td>
<td>The preceding atom is matched exactly <em>int</em> times.</td>
</tr>
<tr>
<td><strong>{int,}</strong></td>
<td><em>int</em> or more</td>
<td>The preceding atom is matched <em>int</em> or more times.</td>
</tr>
<tr>
<td><strong>{min,max}</strong></td>
<td>between <em>min</em> and <em>max</em></td>
<td>The preceding atom is matched at least <em>min</em> times, but not more than <em>max</em>.</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>  模式 <code>(a+).*</code> 匹配 “aardvark” 将匹配到 aa</li>
<li>  模式 <code>(a+?).*</code> 匹配 “aardvark” 将匹配到 a</li>
</ul>
<p><strong>组</strong>（用以匹配连续的多个字符）:</p>
<table>
<thead>
<tr>
<th>characters</th>
<th>description</th>
<th>effects</th>
</tr>
</thead>
<tbody><tr>
<td><strong>(subpattern)</strong></td>
<td>Group</td>
<td>Creates a backreference.</td>
</tr>
<tr>
<td><strong>(?:subpattern)</strong></td>
<td>Passive group</td>
<td>Does not create a backreference.</td>
</tr>
</tbody></table>
<p>注意了，第一种将创建一个反向引用，用于提取匹配到的内容，第二种则没有，相对来说性能方面也没这部分的开销</p>
<table>
<thead>
<tr>
<th>characters</th>
<th>description</th>
<th>condition for match</th>
</tr>
</thead>
<tbody><tr>
<td><strong>^</strong></td>
<td>Beginning of line</td>
<td>Either it is the beginning of the target sequence, or follows a <em>line terminator</em>.</td>
</tr>
<tr>
<td><strong>$</strong></td>
<td>End of line</td>
<td>Either it is the end of the target sequence, or precedes a <em>line terminator</em>.</td>
</tr>
<tr>
<td><strong>|</strong></td>
<td>Separator</td>
<td>Separates two alternative patterns or subpatterns..</td>
</tr>
</tbody></table>
<p>单个字符</p>
<p><code>[abc]</code> 匹配 a, b 或 c.<br><code> [^xyz]</code>匹配任何非 x, y, z的字符</p>
<p>范围<br>[a-z] 匹配任何小写字母 (a, b, c, …, z)<br>[abc1-5] 匹配 a, b , c, 或 1 到 5 的数字</p>
<p>c++ regex还有一种类POSIX的写法</p>
<table>
<thead>
<tr>
<th>class</th>
<th>description</th>
<th>equivalent (with regex_traits, default locale)</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>alpha-numerical character</td>
<td>isalnum</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>alphabetic character</td>
<td>isalpha</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>blank character</td>
<td>isblank</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>control character</td>
<td>iscntrl</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>decimal digit character</td>
<td>isdigit</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>character with graphical representation</td>
<td>isgraph</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>lowercase letter</td>
<td>islower</td>
</tr>
<tr>
<td>[:print:]</td>
<td>printable character</td>
<td>isprint</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>punctuation mark character</td>
<td>ispunct</td>
</tr>
<tr>
<td>[:space:]</td>
<td>whitespace character</td>
<td>isspace</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>uppercase letter</td>
<td>isupper</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>hexadecimal digit character</td>
<td>isxdigit</td>
</tr>
<tr>
<td>[:d:]</td>
<td>decimal digit character</td>
<td>isdigit</td>
</tr>
<tr>
<td>[:w:]</td>
<td>word character</td>
<td>isalnum</td>
</tr>
<tr>
<td>[:s:]</td>
<td>whitespace character</td>
<td>isspace</td>
</tr>
</tbody></table>
<h2 id="邮箱regex示例"><a href="#邮箱regex示例" class="headerlink" title="邮箱regex示例"></a>邮箱regex示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span>  <span class="hljs-comment">// regular expression 正则表达式</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>    string email_address;<br>    string user_name, domain_name;<br><br>    <span class="hljs-function">regex <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;([0-9A-Za-z\\-_\\.]+)@([0-9a-z]+\\.[a-z]&#123;2,3&#125;(\\.[a-z]&#123;2&#125;)?)&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 正则表达式，匹配规则：</span><br>    <span class="hljs-comment">// 第1组（即用户名），匹配规则：0至9、A至Z、a至z、下划线、点、连字符之中</span><br>    <span class="hljs-comment">// 的任意字符，重复一遍或以上</span><br>    <span class="hljs-comment">// 中间，一个“@”符号</span><br>    <span class="hljs-comment">// 第二组（即域名），匹配规则：0至9或a至z之中的任意字符重复一遍或以上，</span><br>    <span class="hljs-comment">// 接着一个点，接着a至z之中的任意字符重复2至3遍（如com或cn等），</span><br>    <span class="hljs-comment">// 第二组内部的一组，一个点，接着a至z之中的任意字符重复2遍（如cn或fr等）</span><br>    <span class="hljs-comment">// 内部一整组重复零次或一次</span><br><br><br>    <span class="hljs-comment">// 输入文件结尾符（Windows用Ctrl+Z，UNIX用Ctrl+D）结束循环</span><br>    <span class="hljs-keyword">while</span> ( cin &gt;&gt; email_address ) <br>    &#123;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">regex_match</span>( email_address, pattern ) )<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;您输入的电子邮件地址合法&quot;</span> &lt;&lt; endl;<br><br>            <span class="hljs-comment">// 截取第一组</span><br>            user_name = <span class="hljs-built_in">regex_replace</span>( email_address, pattern, <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;$1&quot;</span>) );<br><br>            <span class="hljs-comment">// 截取第二组</span><br>            domain_name = <span class="hljs-built_in">regex_replace</span>( email_address, pattern, <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;$2&quot;</span>) );<br><br>            cout &lt;&lt; <span class="hljs-string">&quot;用户名：&quot;</span> &lt;&lt; user_name &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;域名：&quot;</span> &lt;&lt; domain_name &lt;&lt; endl;<br>            cout &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;您输入的电子邮件地址不合法&quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112219748">C++11新特性7 - 正则表达式</a></li>
<li>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/li_wei_quan/article/details/81947604">C++ regex 正则表达式的使用</a></li>
</ul>

	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>