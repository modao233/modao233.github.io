<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>PL</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/编程语言/Linux shell/shellqian-tan-zhi-jiu-zi-shellyu-jin-cheng-chu-li/">(转载)关于子shell</a></h1><div class=post-meta-inline><span class=post-date> 2020-11-20 </span></div><div class=post-content><p>原文：<a href=https://blog.csdn.net/taiyang1987912/article/details/39529291>shell浅谈之九子shell与进程处理</a><p>作者：<a href=https://me.csdn.net/taiyang1987912>乌托邦2号</a><h2 id=yi-jian-jie>一、简介</h2><p>Linux是一种用户控制的多作业操作系统，系统允许多个系统用户同时提交作业，而一个系统用户又可能用多个shell登录，每个系统用户可以用一个shell提交多个作业。<p>了解Bash Shell在多作业管理和进程处理方面的命名和机制有助于理解多用户、多作业的系统。<h2 id=er-xiang-jie>二、详解</h2><h3 id=1-zi-shell>1、子Shell</h3><p>父子Shell是相对的，它描述了两个Shell进程的fork关系，父Shell指在终端模拟器的shell进程，子Shell是由父Shell创建的进程。父Shell创建子Shell调用的是fork函数。<p>创建子shell的情况：<ul><li>使用外部命令<li>使用圆括号结构，强制将其中的命令运行在子shell中，bash3后定义了内部变量BASH_SUBSHELL记录子shell的层次。</ul><p>Shell命令可以分为<ul><li>内建命令（Shell本身执行的命令），不创建子Shell。内建命令是包含在Shell工具包中的命令，其中保留字对Shell有特殊含义，保留字本身不是一个命令而是命令结构的一部分。<li>外部命令（fork创建出来的子shell执行的命令），创建子Shell。</ul><p>冒号是Shell中一个特殊的符号<ul><li>冒号可以表示永真（相当于TRUE关键字）如<code>while  :;do...done</code>（while循环的条件始终为真）<li>冒号可以清空一个文件，<code>:>log</code>将冒号重定向到文件，log文件内容被清空，所 以<code>:></code>命名是常用的清空文件的命令<li>冒号最重要的用法是：不做任何事，<strong>只做参数展开</strong></ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#圆括号结构用法
</span><span style=color:#65737e;>#!/bin/bash
</span><span>
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Father Shell is: </span><span>$</span><span style=color:#bf616a;>BASH_SUBSHELL</span><span>"      </span><span style=color:#65737e;>#打印父shell的层次，为0
</span><span style=color:#bf616a;>outervar</span><span>=</span><span style=color:#a3be8c;>OUTER                              </span><span style=color:#65737e;>#父shell的变量outervar
</span><span>
</span><span>(                                           </span><span style=color:#65737e;>#利用圆括号结构创建子shell
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>SubShell is: </span><span>$</span><span style=color:#bf616a;>BASH_SUBSHELL</span><span>"        </span><span style=color:#65737e;>#子shell的层次为1
</span><span>(
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>GrandSubShell is: </span><span>$</span><span style=color:#bf616a;>BASH_SUBSHELL</span><span>" </span><span style=color:#65737e;>#孙shell的层次为2
</span><span>) 
</span><span style=color:#bf616a;>innervar</span><span>=</span><span style=color:#a3be8c;>INNER                            </span><span style=color:#65737e;>#子shell的变量
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>innervar=</span><span>$</span><span style=color:#bf616a;>innervar</span><span>"
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>outervar=</span><span>$</span><span style=color:#bf616a;>outervar</span><span>"                 </span><span style=color:#65737e;>#outervar继承了符shell所赋给它的值
</span><span>)                                           </span><span style=color:#65737e;>#回到父shell
</span><span>
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Father Shell is: </span><span>$</span><span style=color:#bf616a;>BASH_SUBSHELL</span><span>"   
</span><span>
</span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span style=color:#bf616a;>-z </span><span>"$</span><span style=color:#bf616a;>innervar</span><span>" </span><span style=color:#96b5b4;>]                      </span><span style=color:#65737e;>#子shell中定义变量为空，则说明
</span><span style=color:#b48ead;>then
</span><span>  </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The </span><span style=color:#96b5b4;>\$</span><span style=color:#a3be8c;>innervar is not defined in main body.</span><span>"
</span><span style=color:#b48ead;>else
</span><span>   </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The </span><span style=color:#96b5b4;>\$</span><span style=color:#a3be8c;>innervar is defined in main body.</span><span>"
</span><span style=color:#b48ead;>fi
</span></code></pre><p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140925143613826><p><strong>子shell不影响父shell的环境：</strong><ul><li>子shell中变量的作用域不能在父Shell中生效<li>在子shell中将变量export成环境变量，子shell对变量的更改仍然对父shell不可见</ul><p><strong>子shell能继承父shell的一些属性，且子shell不能反过来改变父shell的属性：</strong><ul><li><p>子shell能够从父shell继承得来的属性有：当前的工作目录、环境变量、标准输入输出和错误输出、所有已打开的文件描述符、忽略的信号。</p><li><p>子shell不能从父shell继承得来的属性是：除了环境变量 和.bashrc文件中定义变量之外的shell变量、未被忽略的信号处理。</p></ul><p>shell是允许嵌套调用的，可以在函数或圆括号结构内再次调用圆括号结构创建子shell<p>利用子shell测试变量是否已经定义的例子：<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span>
</span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#96b5b4;>set </span><span style=color:#bf616a;>-u</span><span>; </span><span style=color:#96b5b4;>: </span><span>$</span><span style=color:#bf616a;>var</span><span>)  </span><span style=color:#65737e;>#冒号与$间有空格
</span><span style=color:#b48ead;>then 
</span><span>  </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Variable is set.</span><span>"
</span><span style=color:#b48ead;>fi
</span></code></pre><p>set -u命令用于设置shell选项，u是nounset表示当使用未定义的变量时，输出错误信息并强制退出。<p><code>:  $var</code>中冒号是不做任何事只是参数展开，若没有冒号则<code>$var</code>被解释成shell命令，shell试图去执行var变量的值。加上冒号，shell试图将var变量进行参数展开但不会试图去执行var变量的值。<p>shell可以接收到父shell从管道传送过来的数据，例：<code>cat /etc/passwd | (grep 'root')</code>，使用管道符向子shell发送数据，符shell将cat的结果通过管道发送给子shell，子shell执行grep命令。<p>shell应用将一个计算量较大的任务分成若干个小任务并行执行。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#子shell用于并行计算的用法
</span><span style=color:#65737e;>#!/bin/bash
</span><span>
</span><span style=color:#65737e;>#用圆括号结构创建三个子shell同时执行
</span><span>(</span><span style=color:#bf616a;>grep -r </span><span>"</span><span style=color:#a3be8c;>root</span><span>" /etc/* | </span><span style=color:#bf616a;>sort </span><span>> part1)       &       </span><span style=color:#65737e;>#与root关键字匹配的行，排序后输出到某文件
</span><span>(</span><span style=color:#bf616a;>grep -r </span><span>"</span><span style=color:#a3be8c;>root</span><span>" /usr/local/* | </span><span style=color:#bf616a;>sort </span><span>> part2) &
</span><span>(</span><span style=color:#bf616a;>grep -r </span><span>"</span><span style=color:#a3be8c;>root</span><span>" /lib/* | </span><span style=color:#bf616a;>sort </span><span>> part3)       &
</span><span>
</span><span style=color:#96b5b4;>wait                                                 </span><span style=color:#65737e;>#等待后台执行的作业全部完成
</span><span style=color:#bf616a;>cat</span><span> part1 part2 part3 | </span><span style=color:#bf616a;>sort </span><span>> parttotal
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Run time of this script is:</span><span>$</span><span style=color:#bf616a;>SECONDS</span><span>"           </span><span style=color:#65737e;>#输出该脚本执行时间
</span></code></pre><p><code>grep  -r</code>递归搜索，搜索时的计算量比较大，对每个目录创建一个子shell进行并行处理，然后合并。<p>每个圆括号之外有一个&符号，表示此命令放在后台执行，继续执行下一条命令；若无&符号则需要一条命令执行完毕后再执行下一条命令，就没真正实现并行计算。<p>wait是一个内建命令，用于等待后台执行的作业全部完成后再执行下面的命令；若没有wait，脚本将三个子shell放在后台执行后直接执行合并临时文件的命令，三个子shell可能并未执行完毕，此时临时文件中的结果不完整，合并后也将产生不完整的结果。<h3 id=2-shellde-xian-zhi-mo-shi>2、Shell的限制模式</h3><p>处于限制模式下的shell运行一个脚本或脚本片段，将会禁用一些命令或操作。shell的限制模式是Linux系统基于安全方面的考虑，目的为了限制脚本用户的权限，并尽可能地减小脚本所带来的危害。<p>的限制模式限制的操作有：用cd命令更改当前工作目录、更改重要的环境变量的值<code>（$PATH、$SHELL、$BASH_ENV、$ENV 和$SHELLOPTS）</code>、输出重定向符号<code>（>、>>、>|、>&、<>和&>）</code>、调用含有一个或多个斜杠的命令名称、使用内建命令exec、使用set+r等命令关闭限制模式。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#正常模式和限制模式的区别
</span><span style=color:#65737e;>#!/bin/bash
</span><span>
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Changing current work directory</span><span>" 
</span><span style=color:#96b5b4;>cd</span><span> /etc                                    </span><span style=color:#65737e;>#正常模式下改变当前工作目录
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Now in </span><span>$</span><span style=color:#bf616a;>PWD</span><span>"
</span><span>
</span><span style=color:#96b5b4;>set</span><span> -r                                     </span><span style=color:#65737e;>#shell选项使代码运行在限制模式下（r是restricted）
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>------IN RESTRICTED MODE---------</span><span>"   </span><span style=color:#65737e;>#开始运行在限制模式下
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Trying to change directory</span><span>"
</span><span style=color:#96b5b4;>cd</span><span> /usr/local                              </span><span style=color:#65737e;>#cd命令出错，被限制了
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#96b5b4;>\$</span><span style=color:#a3be8c;>SHELLOPTS=</span><span>$</span><span style=color:#bf616a;>SHELLOPTS</span><span>"              </span><span style=color:#65737e;>#可以读取$SHELLOPTS变量的值
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Now in `</span><span style=color:#bf616a;>pwd</span><span style=color:#a3be8c;>`</span><span>"                        </span><span style=color:#65737e;>#还是/etc为当前目录
</span><span style=color:#96b5b4;>echo
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Trying to change </span><span style=color:#96b5b4;>\$</span><span style=color:#a3be8c;>SHELL</span><span>"
</span><span style=color:#bf616a;>SHELL</span><span>="</span><span style=color:#a3be8c;>/bin/sh</span><span>"                            </span><span style=color:#65737e;>#$SHELL变量在限制模式下只读
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#96b5b4;>\$</span><span style=color:#a3be8c;>SHELL=</span><span>$</span><span style=color:#bf616a;>SHELL</span><span>"              
</span><span style=color:#96b5b4;>echo
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Trying to redirect output to a file</span><span>"
</span><span style=color:#bf616a;>who </span><span>> outputnull                          </span><span style=color:#65737e;>#输出重定向失败，被限制了
</span><span>ls</span><span style=color:#bf616a;> -l</span><span> outputnull                          </span><span style=color:#65737e;>#outputnull没有被创建
</span></code></pre><p>开启shell的restricted选项进入限制模式，两种方式：<ol><li><code>set -r</code><li><code>#!/bin/bash -r</code></ol><h3 id=3-jin-cheng-chu-li>3、进程处理</h3><p><strong>进程角度看shell执行</strong><p>内建命令是由shell本身执行的命令，而外部命令则需要创建新的进程来执行。从进程角度归纳shell执行内建命令和外部命令的过程。<p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140926135700456><p>当shell命令不是内建命令时，linux利用fork对一个子进程执行该命令，父进程处于等待状态。若该命令或脚本中包含编译过的可执行文件，则内核将新程序装载到内存，并覆盖子进程，执行结束退出子进程，父进程被重新激活开始读取shell的后一条命令。<p>fork是系统调用，fork创建的子进程是父进程的副本，两个进程具有同样的环境、打开的文件、用户标志符、当前工作目录和信号等。<p>fork后exec，重新装载另一个程序。<p><strong>进程和作业</strong><p>作业是用户层面的概念，而进程是操作系统层面的概念。其区别：一个正在执行的进程称为作业，一个作业可以包含多个进程，用户提交作业到操作系统，作业的完成可能依赖于启动多个进程。<p>进程的三种基本状态：<p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140926141255187><p>作业号标识的是在该shell下运行的所有进程，而进程号就标识整个系统下正在运行的所有进程。<p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140926142025238><p>其中[1]是作业号，7574是进程号。<p><strong>作业控制</strong><p>作业是针对shell而言的，有前台运行和后台运行。内建命令fg可将后台运行的作业放到前台，而&符号使得作业在后台运行。<p>fg可以指定作业的方法（Ctrl+Z组合键可将正在运行的作业阻塞）：<p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140926143152484><p>bg命令可将阻塞状态的作业转入后台运行。<p>jobs查看作业列表。<p>disown用于从shell的作业表中删除作业。<p>wait命令用与等待后台作业完成。<p><strong>信号</strong><p>信号是在软件层次上对中断机制的一种模拟，原理上一个进程收到一个信号与处理器收到一个中断请求是一样的。<p>信号事件的来源：硬件来源（比如按下键盘或其他 硬件故障）、软件来源（比如系统函数kill、raise、alarm、setitimer和sigqueue函数）。<p>信号是进程间通信机制中唯一的异步通信机制。<p>向进程发送信号大多通过Ctrl键加上一些功能键来实现。<p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140926145812843><p>除了利用组合键发送信号外，内建命令kill可用于向进程发送TERM（即terminal）信号，功能和INT信号类似用于停止进程。kill可以通过进程号、作业号（kill %n）或进程命令名想任何作业发送信号。kill杀掉自己本身的进程（记录了运行该脚本的进程号），其中大于128的退出码表示脚本是被系统强行结束的。kill -l可看出，kill命令一共能发出64种信号。<p><strong>trap命令</strong><p>trap是Linux的内建命令，用于捕捉信号，trap命令可以指定收到某种信号时所执行的命令。trap命令的格式如下：trap command sig1 sig2 ... sigN，当接收到sinN中任意一个信号时，执行command命令，command命令完成后继续接收到信号前的操作，直到脚本结束。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span>
</span><span style=color:#96b5b4;>trap </span><span>"</span><span style=color:#a3be8c;>echo 'You hit Ctrl+c!'</span><span>" INT
</span><span>
</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>:</span><span>; </span><span style=color:#b48ead;>do
</span><span>  </span><span style=color:#96b5b4;>let</span><span> count=count+</span><span style=color:#d08770;>1
</span><span>  </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>This is the </span><span>$</span><span style=color:#bf616a;>count</span><span style=color:#a3be8c;> sleep</span><span>"
</span><span>  </span><span style=color:#bf616a;>sleep</span><span> 5
</span><span style=color:#b48ead;>done
</span></code></pre><p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140926152749436><p>利用trap命令捕捉INT信号（即与Ctrl+c绑定的中断信号）。trap还可以忽略某些信号，将command用空字符串代替即可，如trap "" TERM INT，忽略kill %n和Ctrl+c发送的信号（kill发送的是TERM信号）。LInux更强劲的杀死进程的命令：kill -9 进程号（或kill -9 %n作业号）等价与kill -KILL 进程号。<p><strong>子shell的信号</strong><p>子shell能继承父shell所忽略的信号，但是不能继承父shell未忽略的信号。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span>
</span><span style=color:#96b5b4;>trap </span><span>"" QUIT            </span><span style=color:#65737e;>#忽略kill -3信号，并且子shell能继承父shell所忽略的信号
</span><span style=color:#96b5b4;>trap </span><span>"</span><span style=color:#a3be8c;>echo 'You want to kill me'</span><span>" TERM    </span><span style=color:#65737e;>#父shell处理的信号，子shell不能继承
</span><span>(                       </span><span style=color:#65737e;>#子shell，子进程号比父进程号大1
</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>:</span><span>; </span><span style=color:#b48ead;>do
</span><span style=color:#96b5b4;>let</span><span> count=count+</span><span style=color:#d08770;>1
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>This is the </span><span>$</span><span style=color:#bf616a;>count</span><span style=color:#a3be8c;> sleep</span><span>"
</span><span style=color:#bf616a;>sleep</span><span> 5
</span><span style=color:#b48ead;>done
</span><span>)
</span></code></pre><p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140926164007320><p>父shell忽略QUIT信号但不忽略TERM信号，9987为父 shell进程号9988为子shell进程号，kill -3 9987向父shell发送3信号和kill -3 9988向子shell发送3信号，均未退出，可以看出子shell对QUIT的忽略是从父shell继承而来的。<p>kill 9987向父shell发送TERM信号，父shell仍存活（因处理了TERM信号），kill 9988向子shell发送TERM信号，子shell退出，随后父shell执行完毕结束。TERM信号能杀掉子shell，说明子shell不能继承 父shel未忽略的信号。<p><img alt=img src=shell%E6%B5%85%E8%B0%88%E4%B9%8B%E4%B9%9D%E5%AD%90shell%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86/20140926164031984><p>最后出现父shell响应TERM信号的输出，是因为子shell执行fork一个子进程后父shell处于等待状态，只有子shell退出后父shell才会被激活执行输出。</div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>