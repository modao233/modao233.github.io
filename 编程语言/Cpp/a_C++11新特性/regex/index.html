<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/编程语言/Cpp/a_C++11新特性/regex/>regex 正则表达式</a></h1><div class=post-meta-inline><span class=post-date> 2021-04-01 </span></div><div class=post-content><p>C++11 新增了正则表达式的标准库支持<h2 id=regexde-jie-shao>regex的介绍</h2><p>C++11 自带了 6 种正则表达式语法的支持<ol><li>ECMAScript<li>basic<li>extended<li>awk<li>grep<li>egrep</ol><p>C++11 默认使用 ECMAScript 语法，这也是 6 种语法中最强大的，假如想使用其他 5 种语法，只需在声明 <code>regex</code> 对象时指定即可<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>regex </span><span style=color:#8fa1b3;>e</span><span>("</span><span style=color:#a3be8c;>^a.</span><span>", regex_constants::</span><span style=color:#bf616a;>grep</span><span>);</span><span>
</span></code></pre><p>在C++中，有三种正则可以选择使用<ul><li>C ++regex<li>C regex<li>boost regex</ul><p>如果在windows下开发C++，默认不支持后面两种正则，如果想快速应用，显然C++ regex 比较方便使用。<h2 id=regexde-shi-yong>regex的使用</h2><h3 id=quan-ci-pi-pei>全词匹配</h3><p><code>regex_match</code>是正则表达式匹配的函数<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {</span><span>
</span><span>    string a = "</span><span style=color:#a3be8c;>modao</span><span>";</span><span>
</span><span>    regex </span><span style=color:#bf616a;>e</span><span>("</span><span style=color:#a3be8c;>m(.*)</span><span>");</span><span>
</span><span>    </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#bf616a;>regex_match</span><span>(a, e))cout << "</span><span style=color:#a3be8c;>modao</span><span>";</span><span>
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;</span><span>
</span><span>}</span><span>
</span></code></pre><h3 id=sou-suo-pi-pei>搜索匹配</h3><p>regex_search和regex_match的主要区别是：regex_match是全词匹配，而regex_search是搜索其中匹配的字符串。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {</span><span>
</span><span>  regex </span><span style=color:#bf616a;>e</span><span>("</span><span style=color:#a3be8c;>abc*</span><span>");</span><span>
</span><span>  </span><span style=color:#b48ead;>bool</span><span> m = </span><span style=color:#bf616a;>regex_search</span><span>("</span><span style=color:#a3be8c;>abccc</span><span>", e);</span><span>
</span><span>
</span><span>  </span><span style=color:#65737e;>// 输出 yes</span><span style=color:#65737e;>
</span><span>  cout << (m ? "</span><span style=color:#a3be8c;>yes</span><span>" : "</span><span style=color:#a3be8c;>no</span><span>") << endl;</span><span>
</span><span>}</span><span>
</span></code></pre><h3 id=ti-qu-pi-pei>提取匹配</h3><p>想要提取出匹配的部分，就需要用到 <code>match_results</code><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {</span><span>
</span><span>  string </span><span style=color:#bf616a;>str</span><span>("</span><span style=color:#a3be8c;>Email a@bc.com abc</span><span>");</span><span>
</span><span>
</span><span>  </span><span style=color:#65737e;>// 等同于 match_results&LTstring></span><span style=color:#65737e;>
</span><span>  smatch m; </span><span>
</span><span>
</span><span>  regex </span><span style=color:#bf616a;>e</span><span>("</span><span style=color:#a3be8c;>([[:w:]]+)@([[:w:]]+</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>.com)</span><span>");</span><span>
</span><span>  </span><span style=color:#b48ead;>bool</span><span> found = </span><span style=color:#bf616a;>regex_search</span><span>(str, m, e);</span><span>
</span><span>
</span><span>  </span><span style=color:#65737e;>// m.size=3, 存储了 3 个 result</span><span style=color:#65737e;>
</span><span>  cout << "</span><span style=color:#a3be8c;>m.size=</span><span>" << m.</span><span style=color:#bf616a;>size</span><span>() << endl;</span><span>
</span><span>
</span><span>  </span><span style=color:#b48ead;>for </span><span>(</span><span style=color:#b48ead;>int</span><span> n=</span><span style=color:#d08770;>0</span><span>; n&LTm.</span><span style=color:#bf616a;>size</span><span>(); n++){</span><span>
</span><span>    cout << "</span><span style=color:#a3be8c;>m[</span><span>" << n << "</span><span style=color:#a3be8c;>]=</span><span>" << m[n].</span><span style=color:#bf616a;>str</span><span>() << endl;</span><span>
</span><span>	</span><span style=color:#65737e;>//等价写法 m.str(n), *(m.begin()+n) </span><span style=color:#65737e;>
</span><span>  }</span><span>
</span><span>  </span><span style=color:#65737e;>//匹配项的前缀和后缀</span><span style=color:#65737e;>
</span><span>  cout << "</span><span style=color:#a3be8c;>m.prefix=</span><span>" << m.</span><span style=color:#bf616a;>prefix</span><span>().</span><span style=color:#bf616a;>str</span><span>() << endl;</span><span>
</span><span>  cout << "</span><span style=color:#a3be8c;>m.suffix=</span><span>" << m.</span><span style=color:#bf616a;>suffix</span><span>().</span><span style=color:#bf616a;>str</span><span>() << endl;</span><span>
</span><span>}</span><span>
</span><span style=color:#65737e;>/*</span><span style=color:#65737e;>
</span><span style=color:#65737e;>迭代 match_results, 输出</span><span style=color:#65737e;>
</span><span style=color:#65737e;>m[0]=a@bc.com (整个匹配)</span><span style=color:#65737e;>
</span><span style=color:#65737e;>m[1]=a (第1个group)</span><span style=color:#65737e;>
</span><span style=color:#65737e;>m[2]=bc.com (第2个group)</span><span style=color:#65737e;>
</span><span style=color:#65737e;>m.prefix=Email </span><span style=color:#65737e;>
</span><span style=color:#65737e;>m.suffix= abc</span><span style=color:#65737e;>
</span><span style=color:#65737e;>*/</span><span>
</span></code></pre><h3 id=ti-qu-duo-ge-pi-pei>提取多个匹配</h3><h4 id=die-dai-result>迭代result</h4><p>假如我们想要匹配的字符串中，有多个子串都可以匹配正则表达式，并且我们想把这些子串全部找出来，例如一个字符串中包含多个邮箱地址，那么就需要用到 <code>regex_iterator</code><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {</span><span>
</span><span>  string </span><span style=color:#bf616a;>str</span><span>("</span><span style=color:#a3be8c;>a@bc.com, d@ef.com, aa@b.com</span><span>");</span><span>
</span><span>
</span><span>  regex </span><span style=color:#bf616a;>e</span><span>("</span><span style=color:#a3be8c;>([[:w:]]+)@([[:w:]]+</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>.com)</span><span>");</span><span>
</span><span>
</span><span>  </span><span style=color:#65737e;>// 定义 regex_iteraror</span><span style=color:#65737e;>
</span><span>  sregex_iterator </span><span style=color:#bf616a;>pos</span><span>(str.</span><span style=color:#bf616a;>cbegin</span><span>(), str.</span><span style=color:#bf616a;>cend</span><span>(), e); </span><span>
</span><span>  </span><span style=color:#65737e;>// C++惯例: 默认构造的迭代器表示序列结束</span><span style=color:#65737e;>
</span><span>  sregex_iterator end;</span><span>
</span><span>
</span><span>  </span><span style=color:#b48ead;>for </span><span>(; pos!=end; pos++) {</span><span>
</span><span>    cout << "</span><span style=color:#a3be8c;>email=</span><span>" << pos-></span><span style=color:#bf616a;>str</span><span>(</span><span style=color:#d08770;>0</span><span>) </span><span>
</span><span>      << "</span><span style=color:#a3be8c;>, user=</span><span>" << pos-></span><span style=color:#bf616a;>str</span><span>(</span><span style=color:#d08770;>1</span><span>) </span><span>
</span><span>      << "</span><span style=color:#a3be8c;>, domain=</span><span>" << pos-></span><span style=color:#bf616a;>str</span><span>(</span><span style=color:#d08770;>2</span><span>) </span><span>
</span><span>      << endl;</span><span>
</span><span>  }</span><span>
</span><span>}</span><span>
</span><span>
</span><span style=color:#65737e;>/*</span><span style=color:#65737e;>
</span><span style=color:#65737e;>email=a@bc.com, user=a, domain=bc.com</span><span style=color:#65737e;>
</span><span style=color:#65737e;>email=d@ef.com, user=d, domain=ef.com</span><span style=color:#65737e;>
</span><span style=color:#65737e;>email=aa@bb.com, user=aa, domain=b.com</span><span style=color:#65737e;>
</span><span style=color:#65737e;>*/</span><span>
</span></code></pre><p>如上我们可以看到，<code>regex_iterator</code> 其实就是迭代字符串中所有正则表达式匹配的 <code>match_results</code>。<h4 id=die-dai-pi-pei-chuan>迭代匹配串</h4><p>除此之外，C++ 还提供了另一种迭代器 <code>regex_token_iterator</code>。<p>不同的是，<code>regex_token_iterator</code> 迭代的是所有正则表达式匹配中的指定子表达式，或迭代未匹配的子字符串<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {</span><span>
</span><span>  string </span><span style=color:#bf616a;>str</span><span>("</span><span style=color:#a3be8c;>a@bc.com, d@ef.com, aa@bb.com</span><span>");</span><span>
</span><span>
</span><span>  regex </span><span style=color:#bf616a;>e</span><span>("</span><span style=color:#a3be8c;>([[:w:]]+)@([[:w:]]+</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>.com)</span><span>");</span><span>
</span><span>
</span><span>  </span><span style=color:#65737e;>// 定义regex_token_iterator</span><span style=color:#65737e;>
</span><span>  sregex_token_iterator </span><span style=color:#bf616a;>pos</span><span>(str.</span><span style=color:#bf616a;>cbegin</span><span>(), str.</span><span style=color:#bf616a;>cend</span><span>(), e); </span><span>
</span><span>  sregex_token_iterator end; </span><span style=color:#65737e;>//序列结束</span><span style=color:#65737e;>
</span><span>  </span><span>
</span><span>  </span><span style=color:#b48ead;>for </span><span>(; pos!=end; pos++) {</span><span>
</span><span>    cout << "</span><span style=color:#a3be8c;>Matched:  </span><span>" << *pos << endl;</span><span>
</span><span>  }</span><span>
</span><span>}</span><span>
</span><span style=color:#65737e;>/*</span><span style=color:#65737e;>
</span><span style=color:#65737e;>Matched: a@bc.com</span><span style=color:#65737e;>
</span><span style=color:#65737e;>Matched: d@ef.com</span><span style=color:#65737e;>
</span><span style=color:#65737e;>Matched: aa@bb.com</span><span style=color:#65737e;>
</span><span style=color:#65737e;>*/</span><span>
</span></code></pre><p>我们可以修改 <code>pos</code> 的定义，使它每次迭代 <code>match_results</code> 的第 2 个 group<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>// 第 4 个参数表示第几个 group</span><span style=color:#65737e;>
</span><span>sregex_token_iterator </span><span style=color:#8fa1b3;>pos</span><span>(str.</span><span style=color:#bf616a;>cbegin</span><span>(), str.</span><span style=color:#bf616a;>cend</span><span>(), </span><span style=color:#bf616a;>e</span><span>, </span><span style=color:#d08770;>2</span><span>);</span><span>
</span></code></pre><p>值得注意的是，如果我们把这里的参数设为 -1，则迭代字符串中所有不匹配正则表达式的部分，相当于用正则表达式切割字符串<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {</span><span>
</span><span>  string </span><span style=color:#bf616a;>str</span><span>("</span><span style=color:#a3be8c;>a bb   cd</span><span>");</span><span>
</span><span>
</span><span>  regex </span><span style=color:#bf616a;>e</span><span>("</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>s+</span><span>"); </span><span style=color:#65737e;>// 匹配空格</span><span style=color:#65737e;>
</span><span>
</span><span>  </span><span style=color:#65737e;>// 迭代不匹配正则表达式的部分</span><span style=color:#65737e;>
</span><span>  sregex_token_iterator </span><span style=color:#bf616a;>pos</span><span>(str.</span><span style=color:#bf616a;>cbegin</span><span>(), str.</span><span style=color:#bf616a;>cend</span><span>(), e, -</span><span style=color:#d08770;>1</span><span>);</span><span>
</span><span>  sregex_token_iterator end;</span><span>
</span><span>  </span><span>
</span><span>  </span><span style=color:#b48ead;>for </span><span>(; pos!=end; pos++) {</span><span>
</span><span>    cout << "</span><span style=color:#a3be8c;>Matched: </span><span>" </span><span>
</span><span>      << *pos << endl;</span><span>
</span><span>  }</span><span>
</span><span>}</span><span>
</span><span style=color:#65737e;>/*</span><span style=color:#65737e;>
</span><span style=color:#65737e;>Matched: a</span><span style=color:#65737e;>
</span><span style=color:#65737e;>Matched: bb</span><span style=color:#65737e;>
</span><span style=color:#65737e;>Matched: cd</span><span style=color:#65737e;>
</span><span style=color:#65737e;>*/</span><span>
</span></code></pre><h3 id=ti-huan-pi-pei>替换匹配</h3><p>正则表达式还有一个常用的场景——字符串替换。C++ 中我们可以使用 <code>regex_replace</code><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {</span><span>
</span><span>  string </span><span style=color:#bf616a;>str</span><span>("</span><span style=color:#a3be8c;>a@bc.com, d@ef.com, aa@bb.com</span><span>");</span><span>
</span><span>
</span><span>  regex </span><span style=color:#bf616a;>e</span><span>("</span><span style=color:#a3be8c;>([[:w:]]+)@([[:w:]]+</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>.com)</span><span>");</span><span>
</span><span>  </span><span style=color:#65737e;>//原字符串，匹配规则，替换规则</span><span style=color:#65737e;>
</span><span>  cout << </span><span style=color:#bf616a;>regex_replace</span><span>(str, e, "</span><span style=color:#a3be8c;>$1 is on $2</span><span>");</span><span>
</span><span>}</span><span>
</span></code></pre><p>输出为<pre class=language-text data-lang=text style=background-color:#2b303b;color:#c0c5ce;><code class=language-text data-lang=text><span>a is on bc.com, d is on ef.com, aa is on bb.com</span><span>
</span></code></pre><h2 id=regexde-yu-fa>regex的语法</h2><blockquote><p>正则表达式的括号：<p>()匹配并捕获<p>[]匹配字符组里的每一个字符<p>{}匹配出现的次数</blockquote><p>C++ regex正则表达式的规则和其他编程语言差不多，如下：<p><strong>特殊字符</strong>（用于匹配很难形容的字符）:<table><thead><tr><th>characters<th>description<th>matches<tbody><tr><td>.<td>not newline<td>any character except <em>line terminators</em> (LF, CR, LS, PS).<tr><td><strong>\t</strong><td>tab (HT)<td>a horizontal tab character (same as <strong>\u0009</strong>).<tr><td><strong>\n</strong><td>newline (LF)<td>a newline (line feed) character (same as <strong>\u000A</strong>).<tr><td><strong>\v</strong><td>vertical tab (VT)<td>a vertical tab character (same as <strong>\u000B</strong>).<tr><td><strong>\f</strong><td>form feed (FF)<td>a form feed character (same as <strong>\u000C</strong>).<tr><td><strong>\r</strong><td>carriage return (CR)<td>a carriage return character (same as <strong>\u000D</strong>).<tr><td><strong>\c</strong>letter<td>control code<td>a control code character whose <em>code unit value</em> is the same as the remainder of dividing the <em>code unit value</em> of <em>letter</em> by 32. For example: \ca is the same as \u0001, \cb the same as \u0002, and so on...<tr><td><strong>\x</strong>hh<td>ASCII character<td>a character whose <em>code unit value</em> has an hex value equivalent to the two hex digits <em>hh</em>. For example: \x4c is the same as L, or \x23 the same as #.<tr><td><strong>\u</strong>hhhh<td>unicode character<td>a character whose <em>code unit value</em> has an hex value equivalent to the four hex digits<em>hhhh</em>.<tr><td><strong>\0</strong><td>null<td>a null character (same as <strong>\u0000</strong>).<tr><td>\int<td>backreference<td>the result of the submatch whose opening parenthesis is the <em>int</em>-th (<em>int</em> shall begin by a digit other than 0). See groups below for more info.<tr><td><strong>\d</strong><td>digit<td>a decimal digit character<tr><td><strong>\D</strong><td>not digit<td>any character that is not a decimal digit character<tr><td><strong>\s</strong><td>whitespace<td>a whitespace character<tr><td><strong>\S</strong><td>not whitespace<td>any character that is not a whitespace character<tr><td><strong>\w</strong><td>word<td>an alphanumeric or underscore character<tr><td><strong>\W</strong><td>not word<td>any character that is not an alphanumeric or underscore character<tr><td>\character<td>character<td>the character <em>character</em> as it is, without interpreting its special meaning within a regex expression. Any <em>character</em> can be escaped except those which form any of the special character sequences above. Needed for: ^ $ \ . * + ? ( ) [ ] { } |<tr><td><strong>[class]</strong><td>character class<td>the target character is part of the class<tr><td><strong><sup class=footnote-reference><a href=#class>1</a></sup></strong><td>negated character class<td>the target character is not part of the class</table><p>注意了，在C++反斜杠字符（\）会被转义<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>std::regex </span><span style=color:#8fa1b3;>e1 </span><span>("</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>d</span><span>"); </span><span style=color:#65737e;>// \d -> 匹配数字字符</span><span style=color:#65737e;>
</span><span>std::regex </span><span style=color:#8fa1b3;>e2 </span><span>("</span><span style=color:#96b5b4;>\\\\</span><span>"); </span><span style=color:#65737e;>// \\ -> 匹配反斜杠字符</span><span style=color:#65737e;>
</span></code></pre><p>数量**：**<table><thead><tr><th>characters<th>times<th>effects<tbody><tr><td>*****<td>0 or more<td>The preceding atom is matched 0 or more times.<tr><td><strong>+</strong><td>1 or more<td>The preceding atom is matched 1 or more times.<tr><td><strong>?</strong><td>0 or 1<td>The preceding atom is optional (matched either 0 times or once).<tr><td><strong>{int}</strong><td><em>int</em><td>The preceding atom is matched exactly <em>int</em> times.<tr><td><strong>{int,}</strong><td><em>int</em> or more<td>The preceding atom is matched <em>int</em> or more times.<tr><td><strong>{min,max}</strong><td>between <em>min</em> and <em>max</em><td>The preceding atom is matched at least <em>min</em> times, but not more than <em>max</em>.</table><p>注意：<ul><li>模式 <code>(a+).*</code> 匹配 "aardvark" 将匹配到 aa<li>模式 <code>(a+?).*</code> 匹配 "aardvark" 将匹配到 a</ul><p><strong>组</strong>（用以匹配连续的多个字符）:<table><thead><tr><th>characters<th>description<th>effects<tbody><tr><td><strong>(subpattern)</strong><td>Group<td>Creates a backreference.<tr><td><strong>(?:subpattern)</strong><td>Passive group<td>Does not create a backreference.</table><p>注意了，第一种将创建一个反向引用，用于提取匹配到的内容，第二种则没有，相对来说性能方面也没这部分的开销<table><thead><tr><th>characters<th>description<th>condition for match<tbody><tr><td><strong>^</strong><td>Beginning of line<td>Either it is the beginning of the target sequence, or follows a <em>line terminator</em>.<tr><td><strong>$</strong><td>End of line<td>Either it is the end of the target sequence, or precedes a <em>line terminator</em>.<tr><td><strong>|</strong><td>Separator<td>Separates two alternative patterns or subpatterns..</table><p>单个字符<p><code>[abc]</code> 匹配 a, b 或 c. <code> [^xyz]</code>匹配任何非 x, y, z的字符<p>范围 [a-z] 匹配任何小写字母 (a, b, c, ..., z) [abc1-5] 匹配 a, b , c, 或 1 到 5 的数字<p>c++ regex还有一种类POSIX的写法<table><thead><tr><th>class<th>description<th>equivalent (with regex_traits, default locale)<tbody><tr><td>[:alnum:]<td>alpha-numerical character<td>isalnum<tr><td>[:alpha:]<td>alphabetic character<td>isalpha<tr><td>[:blank:]<td>blank character<td>isblank<tr><td>[:cntrl:]<td>control character<td>iscntrl<tr><td>[:digit:]<td>decimal digit character<td>isdigit<tr><td>[:graph:]<td>character with graphical representation<td>isgraph<tr><td>[:lower:]<td>lowercase letter<td>islower<tr><td>[:print:]<td>printable character<td>isprint<tr><td>[:punct:]<td>punctuation mark character<td>ispunct<tr><td>[:space:]<td>whitespace character<td>isspace<tr><td>[:upper:]<td>uppercase letter<td>isupper<tr><td>[:xdigit:]<td>hexadecimal digit character<td>isxdigit<tr><td>[:d:]<td>decimal digit character<td>isdigit<tr><td>[:w:]<td>word character<td>isalnum<tr><td>[:s:]<td>whitespace character<td>isspace</table><h2 id=you-xiang-regexshi-li>邮箱regex示例</h2><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>></span><span>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>cstdlib</span><span>></span><span>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string</span><span>></span><span>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>regex</span><span>>  </span><span style=color:#65737e;>// regular expression 正则表达式</span><span>
</span><span>
</span><span style=color:#b48ead;>using namespace</span><span> std;</span><span>
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main </span><span>( )</span><span>
</span><span>{</span><span>
</span><span>    string email_address;</span><span>
</span><span>    string user_name, domain_name;</span><span>
</span><span>
</span><span>    regex </span><span style=color:#bf616a;>pattern</span><span>("</span><span style=color:#a3be8c;>([0-9A-Za-z</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>-_</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>.]+)@([0-9a-z]+</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>.[a-z]{2,3}(</span><span style=color:#96b5b4;>\\</span><span style=color:#a3be8c;>.[a-z]{2})?)</span><span>");</span><span>
</span><span>    </span><span style=color:#65737e;>// 正则表达式，匹配规则：</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#65737e;>// 第1组（即用户名），匹配规则：0至9、A至Z、a至z、下划线、点、连字符之中</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#65737e;>// 的任意字符，重复一遍或以上</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#65737e;>// 中间，一个“@”符号</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#65737e;>// 第二组（即域名），匹配规则：0至9或a至z之中的任意字符重复一遍或以上，</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#65737e;>// 接着一个点，接着a至z之中的任意字符重复2至3遍（如com或cn等），</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#65737e;>// 第二组内部的一组，一个点，接着a至z之中的任意字符重复2遍（如cn或fr等）</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#65737e;>// 内部一整组重复零次或一次</span><span style=color:#65737e;>
</span><span>
</span><span>
</span><span>    </span><span style=color:#65737e;>// 输入文件结尾符（Windows用Ctrl+Z，UNIX用Ctrl+D）结束循环</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#b48ead;>while </span><span>( cin >> email_address ) </span><span>
</span><span>    {</span><span>
</span><span>        </span><span style=color:#b48ead;>if </span><span>( </span><span style=color:#bf616a;>regex_match</span><span>( email_address, pattern ) )</span><span>
</span><span>        {</span><span>
</span><span>            cout << "</span><span style=color:#a3be8c;>您输入的电子邮件地址合法</span><span>" << endl;</span><span>
</span><span>
</span><span>            </span><span style=color:#65737e;>// 截取第一组</span><span style=color:#65737e;>
</span><span>            user_name = </span><span style=color:#bf616a;>regex_replace</span><span>( email_address, pattern, </span><span style=color:#bf616a;>string</span><span>("</span><span style=color:#a3be8c;>$1</span><span>") );</span><span>
</span><span>
</span><span>            </span><span style=color:#65737e;>// 截取第二组</span><span style=color:#65737e;>
</span><span>            domain_name = </span><span style=color:#bf616a;>regex_replace</span><span>( email_address, pattern, </span><span style=color:#bf616a;>string</span><span>("</span><span style=color:#a3be8c;>$2</span><span>") );</span><span>
</span><span>
</span><span>            cout << "</span><span style=color:#a3be8c;>用户名：</span><span>" << user_name << endl;</span><span>
</span><span>            cout << "</span><span style=color:#a3be8c;>域名：</span><span>" << domain_name << endl;</span><span>
</span><span>            cout << endl;</span><span>
</span><span>        }</span><span>
</span><span>        </span><span style=color:#b48ead;>else</span><span>
</span><span>        {</span><span>
</span><span>            cout << "</span><span style=color:#a3be8c;>您输入的电子邮件地址不合法</span><span>" << endl << endl;</span><span>
</span><span>        }</span><span>
</span><span>    }</span><span>
</span><span>    </span><span style=color:#b48ead;>return</span><span> EXIT_SUCCESS;</span><span>
</span><span>}</span><span>
</span></code></pre><h2 id=can-kao-wen-zhang>参考文章</h2><ul><li><a href=https://zhuanlan.zhihu.com/p/112219748>C++11新特性7 - 正则表达式</a><li><a href=https://blog.csdn.net/li_wei_quan/article/details/81947604>C++ regex 正则表达式的使用</a></ul></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>