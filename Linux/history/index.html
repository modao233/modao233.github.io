<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「工作日还有多少天，休息日还剩几小时」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E4%BF%9D%E5%AD%98%E5%91%BD%E4%BB%A4%E5%88%B0history%E4%B8%AD"><span class="toc-text">不要保存命令到history中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zsh%E7%9A%84history"><span class="toc-text">zsh的history</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9history-file%E4%BD%9C%E7%9B%B8%E5%BA%94%E4%BF%9D%E9%9A%9C"><span class="toc-text">对history file作相应保障</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%89%8D%E4%BD%BF%E7%94%A8shred%E5%91%BD%E4%BB%A4%E8%A6%86%E7%9B%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">删除文件前使用shred命令覆盖文件内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vi%E5%8A%A0%E5%AF%86%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-text">vi加密文本文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6"><span class="toc-text">gpg加密文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6"><span class="toc-text">加密文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-text">指定加密算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="toc-text">指定输出文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E3%80%81cookie%E5%92%8C%E5%8E%86%E5%8F%B2"><span class="toc-text">清理浏览器缓存、cookie和历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8private-mode%E6%B5%8F%E8%A7%88%E7%BD%91%E9%A1%B5"><span class="toc-text">使用private mode浏览网页</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8DuckDuckGo%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BB%A3%E6%9B%BFgoogle%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="toc-text">使用DuckDuckGo搜索引擎代替google搜索引擎</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Bleachbit%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-text">使用Bleachbit清理系统临时文件</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		
	</div>
	
	<div class="page-date">
		2021-11-07
	</div>
	
	<div class="category-area">
		
			
		
	</div>
	
	<div class="content">
		<h1 id="不要保存命令到history中"><a href="#不要保存命令到history中" class="headerlink" title="不要保存命令到history中"></a>不要保存命令到history中</h1><p>bash和zsh默认会将输入过的命令保存在 <code>$HISTFILE</code> 指代的文件中保存的数量由 <code>$HISTSIZE</code> 来决定。</p>
<p>若 <code>$HISTCONTROL</code> 中的值是 <code>ignorespace</code> 或 <code>ignoreboth</code>,则可以通过在命令前插入空格的方式告诉bash该命令不记入history中。</p>
<p>关于 <code>$HISTCONTROL</code> 的说明如下:</p>
<ul>
<li>如果设置为 ignorespace, 以 space 开头的行将不会插入到历史列表中。</li>
<li>如果设置为 ignoredups, 匹配上一次历史记录的行将不会插入。</li>
<li>设置为 ignoreboth 会结合这两种选项。</li>
<li>如果没有定义，或者设置为其他值，所有解释器读取的行都将存入历史列表，但还<br>要经过HISTIGNORE处理。这个变量的作用可以被HISTIGNORE替代。多行的组合命令的第二和其余行都不会被检测，不管HISTCONTROL是什么，都会加入到历史中。</li>
</ul>
<p>或者也可以通过 <code>set -o history</code> 来临时禁止本次登陆session中的history功能。</p>
<p>对于已经记录在history中的命令，可以使用 <code>history -c</code> 清空历史记录，或者使用 <code>history -d N</code> 删除第N条历史记录</p>
<h1 id="zsh的history"><a href="#zsh的history" class="headerlink" title="zsh的history"></a>zsh的history</h1><p>zsh中使用命令<code>history -i</code>即可查看命令执行的时间，<code>HISTTIMEFORMAT</code>变量只对bash有效，zsh的history文件默认存储时间戳（开始时间以Unix纪元表示，经过的秒数以秒为单位）。</p>
<p>bash的<code>HISTFILESIZE</code>变量在zsh中对应的是<code>SAVEHIST</code></p>
<p><code>$HISTFILE</code>变量为保存文件，由于未找如何修改保存时间戳格式，初步想法是在执行<code>history -i</code>命令前使用<code>export $HISTFILE=xxx</code>。</p>
<h1 id="对history-file作相应保障"><a href="#对history-file作相应保障" class="headerlink" title="对history file作相应保障"></a>对history file作相应保障</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weiji100/p/3964230.html">https://www.cnblogs.com/weiji100/p/3964230.html</a><br>相对浅显版本：<a target="_blank" rel="noopener" href="https://blog.csdn.net/marklua/article/details/42396361">https://blog.csdn.net/marklua/article/details/42396361</a></p>
<p>首先，锁定shell的历史文件本身，更改它的属性为末尾只添加：<code>chattr +a .bash_history</code>。这样一来，就不可能删除或更改文件中的数据，连用户都无法改变属性——只有root用户才能改变。</p>
<p>其次，确保历史变量设置合理、<strong>无法更改</strong>。这些历史变量包括最重要的<code>HISTFILE</code>、<code>HISTCOMMAND</code>和<code>HISTIGNORE</code>。要做到这一点，使用shell的<code>typeset</code>命令，带-r选项，这使得指定的变量拥有只读属性。良好的操作规范是使所有历史环境变量都变为只读，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export HISTCONTROL=&quot;&quot;<br>export HISTFILE=$HOME/.bash_history<br>export HISTFILESIZE=2000<br>export HISTIGNORE=&quot;&quot;<br>export HISTSIZE=1000<br>export HISTTIMEFORMAT=&quot;%a %b %Y %T %z &quot;<br>typeset -r HISTCONTROL<br>typeset -r HISTFILE<br>typeset -r HISTFILESIZE<br>typeset -r HISTIGNORE<br>typeset -r HISTSIZE<br>typeset -r HISTTIMEFORMAT<br></code></pre></td></tr></table></figure>

<blockquote>
<p>HISTTIMEFORMAT是bash shell的扩展，将在历史文件中提供时间戳。</p>
</blockquote>
<p>对于bash shell来说，你需要更改历史的一些标准选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#设置cmdhist将把多行命令放入到单单一个历史行<br>shopt -s cmdhist<br>#设置histappend将确保被添加到历史文件，而不是像通常的做法那样覆盖历史文件<br>shopt -s histappend<br></code></pre></td></tr></table></figure>

<p>对于bash shell来说，还要设置PROMPT_COMMAND：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">PROMPT_COMMAND=&quot;history -a&quot; <br>typeset -r PROMPT_COMMAND<br></code></pre></td></tr></table></figure>
<p>这是由于bash shell实际上把历史写入到内存中，<strong>历史文件仅在shell会话结束时加以更新</strong>。这个命令会把上一个命令附加到磁盘上的历史文件。</p>
<p>最后，<a target="_blank" rel="noopener" href="http://blog.rootshell.be/2009/02/28/bash-history-to-syslog/"><strong>创建一个SIGDEBUG陷阱</strong></a>，将命令发送到系统日志（syslog）。VMware的ESXi借助自己版本的ash shell已经具有这样的功能。简而言之，应创建一个把当前命令记入日志（从历史文件获取）的函数，然后用logger命令，把它发送到系统日志。这一步在bash shell和Korn Shell中都适用。<br>这些步骤有些冗长，不过在新版的bash和ksh中有一些新的功能特性，让这一切变得极其容易。GNU Bash在4.1版中添加了记入到系统日志中的功能，只需要编译shell的时候开启该功能即可激活。</p>
<h1 id="删除文件前使用shred命令覆盖文件内容"><a href="#删除文件前使用shred命令覆盖文件内容" class="headerlink" title="删除文件前使用shred命令覆盖文件内容"></a>删除文件前使用shred命令覆盖文件内容</h1><p>只是删除文件的话，文件内容其实还是保存在磁盘上，可以通过特殊工具读回。shred工具则会通过随机写入数据的方式对文件内容进行覆盖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shred $&#123;file&#125;<br></code></pre></td></tr></table></figure>
<p>默认 <code>shred</code> 会覆盖文件内容三次，但是我们也可以通过 <code>-n N</code> 来指定覆盖内容 <code>N</code> 次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shred -n 1 f&#123;file&#125;<br></code></pre></td></tr></table></figure>
<p>我们还可以通过 <code>-u</code> 选项让 <code>shred</code> 在混乱文件内容后直接删掉该文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shred -u $&#123;file&#125;<br></code></pre></td></tr></table></figure>
<p>因此，我们可以写一个alias达到安全删除的目的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alias rm=&#x27;shred -u&#x27;<br></code></pre></td></tr></table></figure>
<h1 id="vi加密文本文件"><a href="#vi加密文本文件" class="headerlink" title="vi加密文本文件"></a>vi加密文本文件</h1><p>vi中可以通过 <code>:X</code> 对文件内容进行加密，系统会让你输入两次密码，然后保存退出，文件就被加密了。</p>
<p>再用vi打开加密的文件时，vi会自动发现文件被加密，然后让你输入解密密码。</p>
<h1 id="gpg加密文件"><a href="#gpg加密文件" class="headerlink" title="gpg加密文件"></a>gpg加密文件</h1><p>上面说的vi只能用来加密文件文件，而gpg可以用来加密任何文件，且功能也要强大的多，比如可以自选加密方式。</p>
<h2 id="加密文件"><a href="#加密文件" class="headerlink" title="加密文件"></a>加密文件</h2><p>我们一般使用对称算法来加密文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">gpg --symmetric $&#123;file&#125;<br></code></pre></td></tr></table></figure>
<p>这会产生一个 <code>$&#123;file&#125;.gpg</code> 的文件就是加密后的文件，但是需要注意的是，原始文件 <code>$&#123;file&#125;</code> 依然存在，不会被删除.</p>
<h2 id="指定加密算法"><a href="#指定加密算法" class="headerlink" title="指定加密算法"></a>指定加密算法</h2><p>通过 <code>--cipher-algo</code> 来指定加密算法，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">gpg --symmetric --cipher-algo AES256 $&#123;gpg_file&#125;<br></code></pre></td></tr></table></figure>
<h2 id="指定输出文件"><a href="#指定输出文件" class="headerlink" title="指定输出文件"></a>指定输出文件</h2><p>不管是加密还是解密，都可以使用 <code>-o</code> 选项指定输出文件，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">gpg -o $&#123;gpg_file&#125; $&#123;file&#125;<br><br>gpg -o $&#123;file&#125; $&#123;gpg_file&#125;<br></code></pre></td></tr></table></figure>
<h1 id="清理浏览器缓存、cookie和历史"><a href="#清理浏览器缓存、cookie和历史" class="headerlink" title="清理浏览器缓存、cookie和历史"></a>清理浏览器缓存、cookie和历史</h1><p>在Firefox中访问 <code>about:preferences#privacy</code></p>
<h1 id="使用private-mode浏览网页"><a href="#使用private-mode浏览网页" class="headerlink" title="使用private mode浏览网页"></a>使用private mode浏览网页</h1><p>在Firefox中按下 <code>Ctrl-Shift-P</code>,打开private窗口</p>
<h1 id="使用DuckDuckGo搜索引擎代替google搜索引擎"><a href="#使用DuckDuckGo搜索引擎代替google搜索引擎" class="headerlink" title="使用DuckDuckGo搜索引擎代替google搜索引擎"></a>使用DuckDuckGo搜索引擎代替google搜索引擎</h1><p>google搜索引擎会搜集用户数据，而DuockDuckGo并不会搜索用户数据。</p>
<h1 id="使用Bleachbit清理系统临时文件"><a href="#使用Bleachbit清理系统临时文件" class="headerlink" title="使用Bleachbit清理系统临时文件"></a>使用Bleachbit清理系统临时文件</h1><p>![[Pasted image 20211017105824.png]]</p>

	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>