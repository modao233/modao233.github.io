<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/编程语言/Cpp/inline-shuo-ming-fu/>inline 说明符</a></h1><div class=post-meta-inline><span class=post-date> 2020-12-29 </span></div><div class=post-content><p><code>inline</code> 说明符<h2 id=gui-ze>规则</h2><p>inline 说明符在用于函数的 <a href=https://zh.cppreference.com/w/cpp/language/declarations#.E8.AF.B4.E6.98.8E.E7.AC.A6>声明说明符序列</a> 时，将函数声明为一个 <em>内联（inline）函数</em>。<p>完全在 <a href=https://zh.cppreference.com/w/cpp/language/classes>class/struct/union 的定义</a>之内<strong>定义</strong>的函数，无论它是成员函数还是非成员 friend 函数，均为隐式的内联函数。<blockquote><p>C++11起<p>声明有 <code>constexpr</code> 的函数是隐式的内联函数。<p>弃置的函数是隐式的内联函数：其（弃置）定义可出现在多于一个翻译单元中。</blockquote><blockquote><p>C++17起：内联变量<p><code>inline</code> 说明符，在用于具有<strong>静态存储期的变量</strong>（静态类成员或命名空间作用域变量）的 <a href=https://zh.cppreference.com/w/cpp/language/declarations#.E8.AF.B4.E6.98.8E.E7.AC.A6>声明说明符序列</a> 时，将变量声明为<em>内联变量</em>。<p>声明为 <code>constexpr</code> 的<strong>静态成员变量</strong>（但不是命名空间作用域变量）是隐式的内联变量。</blockquote><p><em>内联函数</em>或<em>内联变量</em> 具有下列性质：<ol><li>inline 函数或变量的定义必须在访问它的翻译单元中可达（不一定要在访问点前）。<li>带<a href=https://zh.cppreference.com/w/cpp/language/storage_duration>外部链接</a>的 inline 函数或变量（例如不声明为 static ）拥有下列额外属性： <ol><li>内联函数或变量 (C++17 起)在程序中可拥有<a href=https://zh.cppreference.com/w/cpp/language/definition#.E5.8D.95.E4.B8.80.E5.AE.9A.E4.B9.89.E8.A7.84.E5.88.99.EF.BC.88ODR.EF.BC.89>多于一次定义</a>，只要每个定义都出现在不同翻译单元中（对于非静态的内联函数和变量）且所有定义等同即可。例如，内联函数或内联变量可定义于被多个源文件所 #include 的头文件中。<li>它必须在每个翻译单元中均声明为 inline 。<li>它在每个翻译单元中均拥有相同地址。</ol></ol><p>在内联函数中，<ul><li>所有函数定义中的函数局部静态对象在所有翻译单元间共享（它们都指代相同的定义于某一个翻译单元中的对象）<li>所有函数定义中所定义的类型亦在所有翻译单元中相同。</ul><blockquote><p>C++17起：<p>命名空间作用域的内联 const 变量默认具有<a href=https://zh.cppreference.com/w/cpp/language/storage_duration>外部链接</a>（这点不同于非内联非 volatile 的有 const 限定的变量）</blockquote><h2 id=han-yi-de-bian-hua>含义的变化</h2><p>inline 关键词的本意是作为给优化器的指示器，以指示优先采用<a href=https://en.wikipedia.org/wiki/inline_expansion>函数的内联替换</a>而非进行函数调用，即并不执行将控制转移到函数体内的函数调用 CPU 指令，而是代之以执行函数体的一份副本而无需生成调用。这会避免函数调用的开销（传递实参及返回结果），但它可能导致更大的可执行文件，因为函数体必须被复制多次。<p>因为关键词 inline 的含义是非强制的，编译器拥有对任何未标记为 inline 的函数使用内联替换的自由，和对任何标记为 inline 的函数生成函数调用的自由。这些优化选择不改变上述关于多个定义和共享静态变量的规则。<p><strong>C++17 起：由于关键词 inline 对于函数的含义已经变为“<em>容许多次定义</em>”而不是“<em>优先内联</em>”，因此这个含义也扩展到了变量。</strong><h2 id=zhu-jie>注解</h2><p>若具有外部连接的内联函数或变量在不同翻译单元中的<strong>定义不同</strong>，则<strong>行为未定义</strong>。<p>inline 说明符不能用于块作用域内（函数内部）的函数或变量声明<p>inline 说明符<strong>不能重声明</strong>在翻译单元中<strong>已定义的非内联</strong>函数或变量。<p>隐式生成的成员函数、任何在其首条声明中声明为inline的成员函数、任何在类定义内定义的函数：都是内联的。<p>若内联函数在不同翻译单元中进行声明，则其<a href=https://zh.cppreference.com/w/cpp/language/default_arguments>默认实参</a>的积累集合必须在每个翻译单元的末尾相同。<blockquote><p>在 C 中，内联函数不必在每个翻译单元声明为 inline（至多一个可为非 inline 或 extern inline），函数定义不必相同（但若程序依赖于调用的是哪个函数，则行为未指明），且函数局部的静态变量在同一函数的不同定义间不同。</blockquote><blockquote><p>C++17起：<p>关于内联静态成员的额外规则见<a href=https://zh.cppreference.com/w/cpp/language/static>静态数据成员</a><p>内联变量消除了将 C++ 代码打包为唯头文件的库的主要障碍（允许多次（相同）定义）</blockquote><h2 id=shi-li>示例</h2><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>// 头文件
</span><span style=color:#b48ead;>#ifndef</span><span> EXAMPLE_H
</span><span style=color:#b48ead;>#define </span><span>EXAMPLE_H
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>atomic</span><span>>
</span><span style=color:#65737e;>// 包含于多个源文件的函数必须为 inline
</span><span style=color:#b48ead;>inline int </span><span style=color:#8fa1b3;>sum</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>a</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>b</span><span>) 
</span><span>{
</span><span>    </span><span style=color:#b48ead;>return</span><span> a + b;
</span><span>}
</span><span style=color:#65737e;>// 拥有外部链接的包含于多个源文件的变量必须为 inline
</span><span style=color:#b48ead;>inline</span><span> std::atomic<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>counter</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span><span style=color:#b48ead;>#endif
</span><span> 
</span><span style=color:#65737e;>// 源文件 #1
</span><span style=color:#b48ead;>#include </span><span>"</span><span style=color:#a3be8c;>example.h</span><span>"
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>a</span><span>()
</span><span>{
</span><span>    ++counter;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>sum</span><span>(</span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>2</span><span>);
</span><span>}
</span><span> 
</span><span style=color:#65737e;>// 源文件 #2
</span><span style=color:#b48ead;>#include </span><span>"</span><span style=color:#a3be8c;>example.h</span><span>"
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>b</span><span>()
</span><span>{
</span><span>    ++counter;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>sum</span><span>(</span><span style=color:#d08770;>3</span><span>, </span><span style=color:#d08770;>4</span><span>);
</span><span>}
</span></code></pre></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>