<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/Effective C++/item5-liao-jie-c-mo-ren-tian-jia-he-diao-yong-de-han-shu/">Item5-了解 C++ 默认添加和调用的函数</a></h1><div class=post-meta-inline><span class=post-date> 2021-01-06 </span></div><div class=post-content><p>Item 5: 了解 C++ 默默编写并调用哪些函数<h2 id=bian-yi-qi-mo-ren-wei-yi-ge-lei-sheng-cheng-de-han-shu>编译器默认为一个类生成的函数</h2><p>一个类：<ul><li>如果没有声明拷贝构造函数、拷贝赋值运算符和析构函数，则编译器会为类声明一个默认版本<li>如果没有声明任何构造函数，编译器会为类声明一个default构造函数<li>编译器生出的声明，都是public和inline的</ul><p>当定义一个Empty类：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Empty</span><span style=color:#eff1f5;>{}</span><span>;</span><span>
</span></code></pre><p>就好像写下了这样的代码：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Empty </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>Empty</span><span style=color:#eff1f5;>() { </span><span>... </span><span style=color:#eff1f5;>}                  </span><span style=color:#65737e;>//@ default constructor</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>Empty</span><span style=color:#eff1f5;>(</span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;> Empty</span><span>& </span><span style=color:#bf616a;>rhs</span><span style=color:#eff1f5;>) { </span><span>... </span><span style=color:#eff1f5;>}  </span><span style=color:#65737e;>//@ copy constructor</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>~Empty</span><span style=color:#eff1f5;>() { </span><span>... </span><span style=color:#eff1f5;>}   </span><span style=color:#65737e;>//@ destructor — see below,for whether it's virtual</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  Empty</span><span>& </span><span style=color:#8fa1b3;>operator=</span><span style=color:#eff1f5;>(</span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;> Empty</span><span>& </span><span style=color:#bf616a;>rhs</span><span style=color:#eff1f5;>) { </span><span>... </span><span style=color:#eff1f5;>} </span><span style=color:#65737e;>//@ copy assignment operator</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span></code></pre><p>这些默认生出的函数只有在它们被调用的时候才会生成定义。<p>编译器默认生出的函数：<ul><li>析构函数：编译器生出的析构函数是非virtual的，除非它所在的类是从一个基类继承而来，而基类自己声明了一个虚拟析构函数，这种情况下，函数的虚拟性来自基类<li>拷贝构造函数和拷贝赋值运算符：编译器生成版本只是简单地从源对象拷贝每一个非静态数据成员到目标对象，即浅拷贝。</ul><h2 id=bian-yi-qi-sheng-cheng-kao-bei-fu-zhi-yun-suan-fu-de-xiang-guan-yue-shu>编译器生成拷贝赋值运算符的相关约束</h2><p>编译器生成的拷贝赋值运算符行为基本上与拷贝构造函数一致，但一般只有在<strong>生成的代码合法而且有适当机会证明它有意义时</strong>，编译器才会默认生成。万一两个条件有一个不符合，编译器会拒绝为 class 生成 <code>operator=</code>。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>template</span><span><</span><span style=color:#b48ead;>class</span><span> T></span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>NamedObject </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>NamedObject</span><span style=color:#eff1f5;>(std::string</span><span>& </span><span style=color:#bf616a;>name</span><span style=color:#eff1f5;>, </span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;> T</span><span>& </span><span style=color:#bf616a;>value</span><span style=color:#eff1f5;>);</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#65737e;>//@ assume no operator= is declared</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  </span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>private</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  std::string</span><span>&</span><span style=color:#eff1f5;> nameValue;           </span><span style=color:#65737e;>//@ this is now a reference</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;> T objectValue;              </span><span style=color:#65737e;>//@ this is now const</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span><span>
</span><span>std::string </span><span style=color:#8fa1b3;>newDog</span><span>("</span><span style=color:#a3be8c;>Persephone</span><span>");</span><span>
</span><span>std::string </span><span style=color:#8fa1b3;>oldDog</span><span>("</span><span style=color:#a3be8c;>Satch</span><span>");</span><span>
</span><span>NamedObject<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>p</span><span>(</span><span style=color:#bf616a;>newDog</span><span>, </span><span style=color:#d08770;>2</span><span>);                                </span><span>
</span><span>NamedObject<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>s</span><span>(</span><span style=color:#bf616a;>oldDog</span><span>, </span><span style=color:#d08770;>36</span><span>);                                                </span><span>
</span><span>p = s;                                                                   </span><span>
</span></code></pre><p>赋值之前，p.nameValue 和 s.nameValue 是不同的 string 对象的引用。如果赋值成功，则会修改引用绑定的对象，但是 C++ 并不允许“让 reference 改指向不同对象”。面对这种情况，编译器不知道该怎么办，C++的响应是拒绝编译那一行的赋值操作。如果你打算在一个“内含 reference 成员”的 class 内支持赋值操作，必须自己定义 copy assignment 操作符。<p>面对“内含 const 成员“的 class，编译器的反应也一样，更改 const 成员是不合法的，所以编译器不知道如何在它自己生成的赋值函数内面对它们。<p>如果某个基类将 copy assignment 操作符声明为 private ，编译器将拒绝其派生类生成一个 copy assignment 操作符，毕竟编译器为派生类生成的拷贝赋值运算符想象中可以处理基类成员，但实际上它无法调用派生类无权调用的成员函数。<p>需要注意的是，含有引用成员和 const 成员对拷贝赋值运算符的约束对于拷贝构造函数是不适用的：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>std::string </span><span style=color:#8fa1b3;>newDog</span><span>("</span><span style=color:#a3be8c;>Persephone</span><span>");</span><span>
</span><span>NamedObject<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>p</span><span>(</span><span style=color:#bf616a;>newDog</span><span>, </span><span style=color:#d08770;>2</span><span>);</span><span>
</span><span>NamedObject<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>p2</span><span>(</span><span style=color:#bf616a;>p</span><span>);	</span><span style=color:#65737e;>//@ 调用编译器默认生成的拷贝构造函数</span><span style=color:#65737e;>
</span></code></pre><h2 id=zong-jie>总结</h2><ul><li>编译器可以隐式生成一个类的 default 构造函数，拷贝构造函数，拷贝赋值运算符和析构函数。<li>默认生成的析构函数是非虚析构函数，除非该类继承自一个基类，且基类中含有虚析构函数。<li>拷贝构造函数与拷贝赋值运算符，都是简单地从源对象拷贝每一个非静态数据成员到目标对象。<li>含有引用成员，const 成员的类，编译器不会默认生成拷贝赋值运算符，需要自己定义，但是这种约束对于拷贝构造函数则无限制。<li>如果基类将拷贝赋值运算符声明为 private，编译器将不会为从它继承的派生类生成隐式拷贝赋值运算符。</ul></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>