<!DOCTYPE html>
<html>
  <head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>modao</title>
	
	<script type="text/javascript" charset="utf-8">
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?36479f1e15841da95f9e92a25b010d23";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<meta name="generator" content="Hexo 5.4.0"></head>
  <body>
	
      
<link rel="stylesheet" href="/css/navigatebar.css">


<div class="navigatebar">
	<div class="navigatebar-button navigatebar-mine">
    <a href="/">modao</a>
	</div>
	
	
        <div class="navigatebar-button">
          <a href="/">Home</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/categories">Categories</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/links">Friends</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/sites">Sites</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/stars">Stars</a>
        </div>
	
</div>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">


<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-text">入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-text">2. 常见编程概念</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		
	</div>
	
	<div class="page-date">
		2021-11-07
	</div>
	
	<div class="category-area">
		
			
		
	</div>
	
	<div class="content">
		<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>在 <em>Cargo.toml</em> 文件中，标题以及之后的内容属同一个片段，直到遇到下一个标题才开始新的片段。<code>[dependencies]</code> 片段告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。本例中，我们使用语义化版本 <code>0.5.5</code> 来指定 <code>rand</code> crate。Cargo 理解<a target="_blank" rel="noopener" href="http://semver.org/">语义化版本（Semantic Versioning）</a>（有时也称为 <em>SemVer</em>），这是一种定义版本号的标准。<code>0.5.5</code> 事实上是 <code>^0.5.5</code> 的简写，它表示 “任何与 0.5.5 版本公有 API 相兼容的版本”。</p>
<p>Cargo 从 <em>registry</em> 上获取所有包的最新版本信息，这是一份来自 <a target="_blank" rel="noopener" href="https://crates.io/">Crates.io</a> 的数据拷贝。Crates.io 是 Rust 生态环境中的开发者们向他人贡献 Rust 开源项目的地方。</p>
<p>在更新完 registry 后，Cargo 检查 <code>[dependencies]</code> 片段并下载缺失的 crate 。</p>
<p>如果打开 <em>src/main.rs</em> 文件，做一些无关紧要的修改，保存并再次构建，则会出现两行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">$ cargo build<br>   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)<br>    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs<br></code></pre></td></tr></table></figure>

<p>这一行表示 Cargo 只针对 <em>src/main.rs</em> 文件的微小修改而更新构建。依赖没有变化，所以 Cargo 知道它可以复用已经为此下载并编译的代码。它只是重新构建了部分（项目）代码。</p>
<p><strong><em>Cargo.lock</em> 文件确保构建是可重现的</strong></p>
<p>Cargo 有一个机制来确保任何人在任何时候重新构建代码，都会产生相同的结果：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的。例如，如果下周 <code>rand</code> crate 的 <code>0.5.6</code> 版本出来了，它修复了一个重要的 bug，同时也含有一个会破坏代码运行的缺陷，这时会发生什么呢？</p>
<p>这个问题的答案是 <em>Cargo.lock</em> 文件。它在第一次运行 <code>cargo build</code> 时创建，并放在 <em>guessing_game</em> 目录。当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 <em>Cargo.lock</em> 文件。当将来构建项目时，Cargo 会发现 <em>Cargo.lock</em> 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现的构建。换句话说，项目会持续使用 <code>0.5.5</code> 直到你显式升级，多亏有了 <em>Cargo.lock</em> 文件。</p>
<p>当你 <strong>确实</strong> 需要升级 crate 时，Cargo 提供了另一个命令，<code>update</code>，它会忽略 <em>Cargo.lock</em> 文件，并计算出所有符合 <em>Cargo.toml</em> 声明的最新版本。如果成功了，Cargo 会把这些版本写入 <em>Cargo.lock</em> 文件。</p>
<p>不过，Cargo 默认只会寻找大于 <code>0.5.5</code> 而小于 <code>0.6.0</code> 的版本。</p>
<p>如果想要使用 <code>0.6.0</code> 版本的 <code>rand</code> 或是任何 <code>0.6.x</code> 系列的版本，必须像这样更新 <em>Cargo.toml</em> 文件：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><br><span class="hljs-attr">rand</span> = <span class="hljs-string">&quot;0.6.0&quot;</span><br></code></pre></td></tr></table></figure>

<p>下一次运行 <code>cargo build</code> 时，Cargo 会从 registry 更新可用的 crate，并根据你指定的新版本重新计算。</p>
<p>注意：你不可能凭空就知道应该 use 哪个 trait 以及该从 crate 中调用哪个方法。crate 的使用说明位于其文档中。Cargo 有一个很棒的功能是：运行 <code>cargo doc --open</code> 命令来构建所有本地依赖提供的文档，并在浏览器中打开。例如，假设你对 <code>rand</code> crate 中的其他功能感兴趣，你可以运行 <code>cargo doc --open</code> 并点击左侧导航栏中的 <code>rand</code>。</p>
<h2 id="2-常见编程概念"><a href="#2-常见编程概念" class="headerlink" title="2. 常见编程概念"></a>2. 常见编程概念</h2><p><strong>变量和可变性：</strong>变量默认是不可改变的（immutable）。在一些情况下，你会想用可变变量，因为与只用不可变变量相比，它会让代码更容易编写。除了防止出现 bug 外，还有很多地方需要权衡取舍。例如，使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快。对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的。</p>
<p><strong>常量和变量的区别：</strong>类似于不可变变量，常量是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。首先，不允许对常量使用 <code>mut</code>。常量不光默认不能变，它总是不能变。声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 <em>必须</em> 注明值的类型。常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。最后一个区别是，常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。</p>
<p><strong>隐藏（Shadowing）</strong>：我们可以定义一个与之前变量同名的新变量，而新变量会 <strong>隐藏</strong> 之前的变量。Rustacean 们称之为第一个变量被第二个 <strong>隐藏</strong> 了，这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 <code>let</code> 关键字来多次隐藏</p>
<p><strong>隐藏与将变量标记为 <code>mut</code> 是有区别的：</strong></p>
<ol>
<li> 当对可变变量重新不同类型赋值时，如果没有使用 <code>let</code> 关键字，就会导致编译时错误。</li>
<li> 当再次使用 <code>let</code> 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字（变量名字不变）</li>
</ol>
<p><strong>数据类型：</strong>在 Rust 中，每一个值都属于某一个 <strong>数据类型</strong>（<em>data type</em>），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，必须增加类型注解。</p>
<ol>
<li><p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。</p>
<ol>
<li><p><strong>整数</strong> 是一个没有小数部分的数字。</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p> <code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p>
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte(u8 only)</td>
<td>b’A’</td>
</tr>
</tbody></table>
<p> 可以使用表格 3-2 中的任何一种形式编写数字字面值。注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 <code>57u8</code>，同时也允许使用 <code>_</code> 做为分隔符以方便读数，例如<code>1_000</code>。Rust 的默认类型通常就很好，数字类型默认是 <code>i32</code>：它通常是最快的，甚至在 64 位系统上也是。<code>isize</code> 或 <code>usize</code> 主要作为某些集合的索引。</p>
</li>
<li><p> <strong>浮点型：</strong>Rust 也有两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 中，它与 <code>f32</code> 速度几乎一样，不过精度更高。</p>
</li>
<li><p> <strong>布尔型：</strong>Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。Rust 中的布尔类型使用 <code>bool</code> 表示。</p>
</li>
<li><p> <strong>字符类型：</strong>Rust 的 <code>char</code> 类型是语言中最原生的字母类型。<code>char</code> 由单引号指定，不同于字符串使用双引号。Rust 的 <code>char</code> 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value）。</p>
</li>
</ol>
</li>
<li><p><strong>复合类型</strong>：复合类型（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<ol>
<li><p> <strong>元组类型</strong>：元组长度固定：一旦声明，其长度不会增大或缩小。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来<strong>解构（destructure）</strong>元组值。除了使用模式匹配解构外，也可以使用点号（<code>.</code>）后跟值的索引来直接访问它们。</p>
</li>
<li><p><strong>数组类型</strong>：数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。当你想要在栈（stack）而不是在堆（heap）上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。</p>
<p> 当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em>，这是 Rust 术语，它用于程序因为错误而退出的情况。</p>
</li>
</ol>
</li>
</ol>
<p>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。</p>
<p>Rust 不关心函数定义于何处，只要定义了就行。</p>
<p>在函数签名中，<strong>必须</strong> 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器不需要你在代码的其他地方注明类型来指出你的意图。当一个函数有多个参数时，使用逗号分隔</p>
<p> Rust 是一门基于表达式（expression-based）的语言。<strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。表达式（<em>Expressions</em>）计算并产生一个值。函数调用是一个表达式。宏调用是一个表达式。我们用来创建新作用域的大括号（代码块），<code>&#123;&#125;</code>，也是一个表达式</p>
<p>函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（<code>-&gt;</code>）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 <code>return</code> 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。</p>
<p>在 Rust 中，注释必须以两道斜杠开始，并持续到本行的结尾。对于超过一行的注释，需要在每一行前都加上 <code>//</code>，注释也可以在放在包含代码的行的末尾，不过你更经常看到的是以这种格式使用它们，也就是位于它所解释的代码行的上面一行。</p>
<p><code>if</code> 表达式中与条件关联的代码块有时被叫做 <em>arms</em>。值得注意的是代码中的条件 <strong>必须</strong> 是 <code>bool</code> 值。如果条件不是 <code>bool</code> 值，我们将得到一个错误。使用过多的 <code>else if</code> 表达式会使代码显得杂乱无章，所以如果有多于一个 <code>else if</code> 表达式，最好重构代码。</p>
<p>因为 <code>if</code> 是一个表达式，我们可以在 <code>let</code> 语句的右侧使用它，这意味着 <code>if</code> 的每个分支的可能的返回值都必须是相同类型，因为变量必须只有一个类型。Rust 需要在编译时就确切的知道变量的类型。</p>
<p>Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code>。<code>for</code> 循环的安全性和简洁性使得它成为 Rust 中使用最多的循环结构。</p>
<p>栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。</p>
<p>字符串值被硬编码进程序里，他们是不可变的。我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。</p>
<p>Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 <strong>自动</strong> 的复制可以被认为对运行时性能影响较小。</p>
<p>变量与数据交互的方式（一）：移动</p>
<p>变量与数据交互的方式（二）：克隆</p>
<p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章详细讲解 trait）。如果一个类型拥有 <code>Copy</code> trait，一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。</p>
<p>一个通用的规则，任何简单标量值的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>  所有整数类型，比如 <code>u32</code>。</li>
<li>  布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>  所有浮点数类型，比如 <code>f64</code>。</li>
<li>  字符类型，<code>char</code>。</li>
<li>  元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li>
</ul>
<p>向函数传递值可能会移动或者复制，就像赋值语句一样。返回值也可以转移所有权。</p>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>我们可以使用元组来返回多个值，<strong>引用</strong>允许你使用值但不获取其所有权。</p>
<p>与使用 <code>&amp;</code> 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符，<code>*</code>。</p>
<p>我们将获取引用作为函数参数称为 <strong>借用</strong>（<em>borrowing</em>）</p>
<p>在特定作用域中的特定数据有且只有一个可变引用。这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p>
<ul>
<li>  两个或更多指针同时访问同一数据。</li>
<li>  至少有一个指针被用来写入数据。</li>
<li>  没有同步数据访问的机制。</li>
</ul>
<p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <strong>同时</strong> 拥有</p>
<p>我们 <strong>也</strong> 不能在拥有不可变引用的同时拥有可变引用。多个不可变引用是可以的</p>
<p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 <strong>悬垂指针</strong>（<em>dangling pointer</em>），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<p>另一个没有所有权的数据类型是 <em>slice</em>。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。</p>
<p><strong>字符串 slice</strong>（<em>string slice</em>）是 <code>String</code> 中一部分值的引用</p>
<p><strong>字符串字面值</strong>就是<strong>字符串slice</strong>，它是一个指向<strong>二进制程序特定位置</strong>的 slice。这也就是为什么字符串字面值是不可变的；<code>&amp;str</code> 是一个不可变引用。</p>
<p>其他类型的 slice，跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。</p>
<p>例如 <code>&amp;[i32]</code>。</p>
<p><code>println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1);</code> 这样。在 <code>&#123;&#125;</code> 中加入 <code>:?</code> 指示符告诉 <code>println!</code> 我们想要使用叫做 <code>Debug</code> 的输出格式。<code>Debug</code> 是一个 trait，它允许我们以一种对开发者有帮助的方式打印结构体，以便当我们调试代码时能看到它的值。</p>
<p>Rust <strong>确实</strong> 包含了打印出调试信息的功能，不过我们必须为结构体显式选择这个功能。为此，在结构体定义之前加上 <code>#[derive(Debug)]</code> 注解</p>
<p>Rust 为我们提供了很多可以通过 <code>derive</code> 注解来使用的 trait，他们可以为我们的自定义类型增加实用的行为。</p>
<p><strong>方法</strong> 与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p>
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p><code>impl</code> 块的另一个有用的功能是：允许在 <code>impl</code> 块中定义 <strong>不</strong> 以 <code>self</code> 作为参数的函数。这被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。使用结构体名和 <code>::</code> 语法来调用这个关联函数</p>
<p>每个结构体都允许拥有多个 <code>impl</code> 块。</p>
<p>结构体和枚举相似点：就像可以使用 <code>impl</code> 来为结构体定义方法那样，也可以在枚举上定义方法。</p>
<p>Rust 并没有很多其他语言中有的空值功能。<strong>空值</strong>（<em>Null</em> ）是一个值，它代表没有值。在有空值的语言中，变量总是这两种状态之一：空值和非空值。</p>
<p>如果使用 <code>None</code> 而不是 <code>Some</code>，需要告诉 Rust <code>Option</code> 是什么类型的，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 成员保存的值的类型。</p>
<p><code>Option</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option</code>。只要一个值不是 <code>Option</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。</p>
<p>Rust 中的匹配是 <strong>穷尽的</strong>（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这使我们免于假设拥有一个实际上为空的值，这造成了之前提到过的价值亿万的错误。</p>
<p><code>_</code> 模式会匹配所有的值。通过将其放置于其他分支之后，<code>_</code> 将会匹配所有之前没有指定的可能的值。<code>()</code> 就是 unit 值，所以 <code>_</code> 的情况什么也不会发生。</p>
<p><code>if let</code> 语法让我们以一种不那么冗长的方式结合 <code>if</code> 和 <code>let</code>，来处理只匹配一个模式的值而忽略其他模式的情况。</p>
<p>使用 <code>if let</code> 意味着编写更少代码，更少的缩进和更少的样板代码。然而，这样会失去 <code>match</code> 强制要求的穷尽性检查。<code>match</code> 和 <code>if let</code> 之间的选择依赖特定的环境以及增加简洁度和失去穷尽性检查的权衡取舍。</p>
<p>可以在 <code>if let</code> 中包含一个 <code>else</code>。<code>else</code> 块中的代码与 <code>match</code> 表达式中的 <code>_</code> 分支块中的代码相同，这样的 <code>match</code> 表达式就等同于 <code>if let</code> 和 <code>else</code>。</p>

	</div>
</div>
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>
<script>
    function setClipboardText(event){
        
        let clipboardData = event.clipboardData || window.clipboardData;
        
        if (!clipboardData) { return; }
        event.preventDefault();
        
        let text = window.getSelection().toString();
		    
        if (text) {
            
            event.preventDefault();
            
            var copyright = '\n\n'
            + '\n作品采用 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议 进行许可'
            + '\n著作权归作者所有，商业转载请联系作者获得授权，非商业转载请注明出处。'
            + '\n作者: modao'
            + '\n邮箱: rustacean@aliyun.com'
            + '\n原文地址: https://modao.site/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/rust/'
			
            clipboardData.setData('text/plain', text + copyright);
    
        }
    };
	
    var contents = document.getElementsByClassName("content-area");
   
    contents[0].addEventListener('copy',function(e){
        setClipboardText(e);
    });

</script>
    
  </body>
</html>