<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/Interview/c-ji-zhu-mian-shi-ji-chu-zhi-shi-zong-jie/>C/C++ 技术面试基础知识总结</a></h1><div class=post-meta-inline><span class=post-date> 2020-12-30 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/interview/>#Interview</a></span><div class=post-content><p>改自：<a href=https://interview.huihut.com/>C/C++ 技术面试基础知识总结</a><p>遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。<h2 id=c>C++</h2><h3 id=lei-nei-sheng-ming-lei-wai-ding-yi>类内声明类外定义</h3><p>inline<ul><li>类内定义的默认为inline<li>类外定义的，类内声明为inline，类外定义可省略inline</ul><p>static<ul><li>类内声明static成员，类外初始化时无需（不能）重复声明static</ul><p>const<ul><li>类内声明const，类外定义也要带const</ul><p>virtual<ul><li>virtual只能出现在类内部的声明语句之前，不能用于类外部的函数定义</ul><h3 id=const>const</h3><p><strong>作用：</strong><ol><li>修饰变量，说明该变量不可以被改变<li>修饰指针 <ul><li>指向常量的指针（pointer to const）<li>自身是常量的指针（常量指针，const pointer）</ul><li>修饰引用 <ul><li>指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改<li>没有本身是常量的引用（const reference），const修饰对象，引用本身不是对象【引用本身就是 const pointer】</ul><li>修饰成员函数，说明该成员函数内不能修改成员变量</ol><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>//函数中使用const
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>func</span><span>(</span><span style=color:#b48ead;>const int </span><span style=color:#bf616a;>a</span><span>);</span><span style=color:#65737e;>//修饰函数参数值，无意义，形参是临时值
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>func</span><span>(</span><span style=color:#b48ead;>const char</span><span>* </span><span style=color:#bf616a;>a</span><span>);</span><span style=color:#65737e;>//修饰参数值指向对象，所指内容不可变
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>func</span><span>(</span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#b48ead;>const </span><span style=color:#bf616a;>a</span><span>);</span><span style=color:#65737e;>//修饰函数参数值，无意义，形参是临时值
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>func</span><span>(</span><span style=color:#b48ead;>const int</span><span>& </span><span style=color:#bf616a;>a</span><span>); </span><span style=color:#65737e;>//引用参数在函数内为常量，不可变
</span><span style=color:#65737e;>/*
</span><span style=color:#65737e;>const引用传递和最普通的函数按值传递（不加任何修饰）的效果是一模一样的
</span><span style=color:#65737e;>区别是：按值传递会先建立一个类对象的副本，然后传递过去，而引用参数直接传递实参的地址，比按值传递更高效。
</span><span style=color:#65737e;>可避免拷贝构造。
</span><span style=color:#65737e;>*/
</span></code></pre><ul><li><p>在 C++ (不是 C) 中可以用 const 值声明数组长度</p><li><p>对于全局 const 值，C++ 中默认是内部链接(跟 static 一样只允许在本文件内可见)，而不是 C 中的默认外部链接，若想在其他文件中使用必须在其他文件中重新定义或将 const 值放在头文件中(默认是外部链接放在头文件中编译可能会出现错误，默认是内部链接就不会出错)</p></ul><h3 id=static>static</h3><p>**作用：**改变生命周期或者改变作用域<p><strong>1、作用于变量</strong><p>程序的局部变量存在于<strong>堆栈</strong>中，全局变量存在于<strong>静态区</strong>中，动态申请数据存在于<strong>堆</strong>中。<ol><li>修饰局部变量，使变量成为静态的局部变量，存储在静态区，编译时就为变量分配内存，直到程序退出才释放存储单元。如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。<li>修饰外部变量，外部变量指在所有代码块{}之外定义的变量，它缺省为静态变量，编译时分配内存，程序结束时释放内存单元。外部变量的作用域很广，整个文件都有效甚至别的文件也能引用它。为了限制某些外部变量的作用域，使其只在<strong>本文件中有效</strong>，而不能被其他文件引用，可以用static关键字对其作出声明。<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。<strong>类的静态成员{变量，函数}与类本身直接相关，而不是与类的各个对象保持关联。</strong></ol><p>**总结：**用static声明局部变量，使其变为静态存储方式(静态数据区)，作用域不变；用static声明外部变量，其本身就是静态变量，这只会改变其连接方式，使其只在本文件内部有效，而其他文件不可连接或引用该变量。<p><strong>2、作用于函数</strong><ol><li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 <strong>static 函数内不能访问非静态成员</strong>。<li>类的静态成员存在于任何对象之外，对象中不包含任何于静态数据成员有关的数据。</ol><h3 id=thiszhi-zhen>this指针</h3><ol><li><code>this</code> 指针是一个特殊指针，作为每一个非静态成员函数的<strong>隐含参数</strong>（第一个参数），它指向成员函数所属的对象<li>当一个成员函数被调用时，除了显示传递的参数以外，还包含一个隐含参数： <code>this</code> 指针，该参数是一个指向这个成员函数所在的对象的指针，编译程序时将对象的地址赋给 <code>this</code> 指针<li>每次成员函数存取数据成员时，都是通过隐式使用<code>this</code> 指针访问数据成员<li><code>this</code>指针的隐式声明形式 <ul><li>普通成员函数：<code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值<li><code>const</code> 成员函数：<code>const ClassName* const</code>， 这意味着<code>this</code> 指针所指向的对象<strong>也</strong>是不可修改的（即不能对这种对象的数据成员进行赋值操作）<li><code>static</code>成员函数：静态成员函数也不与任何对象绑定在一起，故而不包含this指针</ul><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&this</code>）。<li>在以下场景中，经常需要显式引用 <code>this</code> 指针： <ol><li>为实现对象的链式引用；<li>为避免对同一对象进行赋值操作；<li>在实现一些数据结构时，如 <code>list</code>。</ol></ol><h3 id=lei-de-jing-tai-cheng-yuan>类的静态成员</h3><p>【详见C++ Primer 第7章笔记】<p>静态成员函数与类本身直接相关，不与任何对象绑定在一起，它们不包含this指针。<p>静态成员可以是public的或private的。<p>类使用作用域运算符<code>::</code>访问静态成员(<code>Account::rate()</code>)，成员函数不用通过域运算符就能直接使用静态成员。<p>静态成员函数不能声明成const的，而且我们<strong>不能在static函数体内使用this指针。</strong><p>类的静态成员存在于任何对象之外，对象中不包含任何于静态数据成员有关的数据。静态成员虽然不属于某个对象，但是仍然可以使用类的对象、引用或者指针来访问静态成员<p>static关键字只能出现在类内部：类内部声明时使用static，如果类外部定义不需要static声明<p>静态成员可以是不安全类型<p>静态成员的类型可以就是它所属的类类型，而非静态成员只能声明成它所属的类的指针或引用。<p>静态成员和普通成员的另一个区别是我们可以<strong>使用静态成员作为默认实参</strong><h3 id=inline>inline</h3><p>【详见文章：inline 说明符】<p>C++17之前：只有内联函数，含义是“优先内联”，即给编译器提意见说想要内联但编译器不一定理你<p>C++17以后：多了内联变量，含义是“容许多次（一致性）定义”，仍然是非强制性的<p><strong>特征：</strong><ul><li>相当于把内联函数里面的内容写在调用内联函数处；<li>相当于不用执行进入函数的步骤，直接执行函数体；<li>相当于宏，却比宏多了类型检查，真正具有函数特性；<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</ul><p><strong>编译器对 inline 函数的处理步骤：</strong><ol><li>将 inline 函数体复制到 inline 函数调用点处；<li>为所用 inline 函数中的局部变量分配内存空间；<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</ol><p><strong>优点</strong><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。<li>在类中声明同时定义的成员函数，自动转化为内联函数，<strong>（是这个因果吗？）因此内联函数可以访问类的成员变量</strong>，宏定义则不能。<li>内联函数在运行时可调试，而宏定义不可以。</ol><p><strong>缺点</strong><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</ol><h3 id=xu-han-shu-yu-nei-lian>虚函数与内联</h3><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。<li>虚函数唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</ul><p>虚函数内联使用<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>  
</span><span style=color:#b48ead;>using namespace</span><span> std;
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Base
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>	</span><span style=color:#b48ead;>inline virtual void </span><span style=color:#8fa1b3;>who</span><span style=color:#eff1f5;>()
</span><span style=color:#eff1f5;>	{
</span><span style=color:#eff1f5;>		cout </span><span><< "</span><span style=color:#a3be8c;>I am Base</span><span style=color:#96b5b4;>\n</span><span>"</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>	}
</span><span style=color:#eff1f5;>	</span><span style=color:#b48ead;>virtual </span><span style=color:#8fa1b3;>~Base</span><span style=color:#eff1f5;>() {}
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Derived </span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>Base
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>	</span><span style=color:#b48ead;>inline void </span><span style=color:#8fa1b3;>who</span><span style=color:#eff1f5;>()  </span><span style=color:#65737e;>// 不写inline时隐式内联
</span><span style=color:#eff1f5;>	{
</span><span style=color:#eff1f5;>		cout </span><span><< "</span><span style=color:#a3be8c;>I am Derived</span><span style=color:#96b5b4;>\n</span><span>"</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>	}
</span><span style=color:#eff1f5;>}</span><span>;
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>()
</span><span>{
</span><span>	</span><span style=color:#65737e;>// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
</span><span>	Base b;
</span><span>	b.</span><span style=color:#bf616a;>who</span><span>();
</span><span>
</span><span>	</span><span style=color:#65737e;>// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
</span><span>	Base *ptr = </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>Derived</span><span>();
</span><span>	ptr-></span><span style=color:#bf616a;>who</span><span>();
</span><span>
</span><span>	</span><span style=color:#65737e;>// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</span><span>	</span><span style=color:#b48ead;>delete</span><span> ptr;
</span><span>	ptr = </span><span style=color:#d08770;>nullptr</span><span>;
</span><span>
</span><span>	</span><span style=color:#96b5b4;>system</span><span>("</span><span style=color:#a3be8c;>pause</span><span>");
</span><span>	</span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>} 
</span></code></pre><h3 id=volatile-c-11yi-hou>volatile（C++11以后）</h3><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可能被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化，每次都要重新读取值<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）<li>const 可以是 volatile （如只读的状态寄存器）<li>指针可以是 volatile</ul><h3 id=assert>assert()</h3><p>断言，是一个宏，不是函数。<p>assert 宏的原型定义在 <code>&LTassert.h></code>（C）、<code>&LTcassert></code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。<p>频繁的调用assert会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含<code>#include &LTassert.h></code>的语句之前插入<code>#define NDEBUG</code> 来禁用assert调用。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdio.h</span><span>>
</span><span style=color:#b48ead;>#define </span><span>NDEBUG
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>assert.h</span><span>>
</span></code></pre><p><code>NDEBUG</code>宏是Standard C中定义的宏，专门用来控制<code>assert()</code>的行为。如果定义了这个宏，则<code>assert</code>不会起作用。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#ifdef</span><span> NDEBUG
</span><span style=color:#b48ead;>#define </span><span style=color:#8fa1b3;>assert</span><span>(</span><span style=color:#bf616a;>x</span><span>) ((</span><span style=color:#b48ead;>void</span><span>)</span><span style=color:#d08770;>0</span><span>)
</span><span style=color:#b48ead;>#else
</span><span>...
</span></code></pre><p>注意：<ul><li><p>通常是在<strong>函数开始处</strong>通过assert检验传入参数的合法性</p><li><p>每个assert只检验一个条件，当多个条件通过<code>&&</code>同时检验时，如果断言失败，无法直观的判断是哪个条件失败，当有多个检验条件时应分开assert</p><li><p>不要在assert检验条件里使用改变环境的语句，如对变量的自增、自减</p><li><p>assert和后面的语句应空一行，以形成逻辑和视觉上的一致感</p><li><p>有的地方，assert不能代替条件过滤：assert是用来避免显而易见的错误的，而不是处理异常的。错误和异常是不一样的，错误是不应该出现的，异常是不可避免的，需要判断并处理异常</p></ul><h3 id=shu-zu-he-zhi-zhen-de-qu-bie>数组和指针的区别</h3><p>数组：数组是用于储存多个相同类型数据的集合。<p>指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。<p>区别：<ol><li><strong>赋值</strong>：同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝<li><strong>存储方式</strong>： <ul><li>数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。<li>指针：指针本身就是一个变量，32位机器上，一个指针占4个字节；64位机器上，一个指针占8个字节</ul><li><strong>求sizeof</strong> <ul><li>sizeof(数组名)：数组所占存储空间的内存<li>sizeof(指针名)：指针变量占据的字节数</ul></ol><p>数组名是数组对象的名字，其值等于数组首元素存放的地址，由于数组存储空间是连续的，其值也就等于存放数组的地址。<p>数组名的值是一个地址，可存放到一个指针变量里。<h3 id=zhi-zhen-he-yin-yong-de-qu-bie>指针和引用的区别</h3><p>引用是一个已经存在的对象的别名，指针存放某个对象的地址。<p>指针是对象，引用不是对象，程序为指针变量分配内存区域，而不为引用分配内存区域。<p>定义引用时必须初始化，之后无法改变。指针无须定义时赋初值，指针本身就是一个对象，允许指针赋值和拷贝，可以修改指向。因此没有空引用而有空指针，且指针总是应该被测试是否为空。<p>对引用使用<code>sizeof()</code>得到的是所指向的变量(对象)在内存空间的大小，对指针使用<code>sizeof()</code>得到的是指针变量在内存空间的大小。<p>引用是对象的别名，且引用不是对象，所以不存在引用的引用；可以有指针的指针。<p>++引用作用到引用所指的对象，++指针作用到指针自身，使指针指向下一个对象，而不是改变所指对象的内容。<h4 id=wei-shi-yao-you-liao-zhi-zhen-huan-yao-you-yin-yong>为什么有了指针还要有引用</h4><p>引用的底层也是指针实现的，引用和指针在编译结束之后汇编指令是一样的，引用会占用和指针相同大小的数据空间。<p>引用传递，只是明面上，没有使用值传递，值传递本身是不可避免的。编译器，暗地里通过指针（或者其他可以替代指针的数据类型）的值传递，替换了引用传递。<p>引用能实现的基本上指针都可以实现，那为什么C++还需要引入引用呢？<p><strong>直接原因</strong>：是为了支持运算符重载。<p>如果没有引用，则得用指针来operator overloading操作。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>A </span><span style=color:#8fa1b3;>operator +</span><span>(</span><span style=color:#b48ead;>const</span><span> A *</span><span style=color:#bf616a;>a</span><span>, </span><span style=color:#b48ead;>const</span><span> A *</span><span style=color:#bf616a;>_a</span><span>);  
</span></code></pre><p>那么使用的时候，&a + &b，这样看起来是不是很难受。而引入引用的概念，既可以满足overload operator，也不失重载value和pointer的灵活性。而且引用还带来一个指针无法替代的特性: 引用临时对象。因为引用必须在定义的时候就赋值，以后无法更改。<p><strong>引用带来的好处：</strong><br> 用指针的使用经常犯得错：<ol><li>操作空指针<li>操作野指针<li>误操作改变了指针的值，而后还以为该指针正常。</ol><p>如果我们要正确的使用指针，我们不得不人为地保证这三个条件。而引用的提出就解决了这个问题。<p>引用区别于指针的特性是：<ol><li>不存在空引用（保证不操作空指针）<li>必须初始化（保证不是野指针）<li>一个引用永远指向他初始化的那个对象，一旦初始化就不能改变初始化的值（保证指针值不变）。</ol><p><strong>人为保证变为了编译器来保证，更加安全</strong>。<p><strong>注意事项：</strong><p>用户自定义的类型最好用引用传参，这样可以避免不必要的构造函数和析构函数调用，但是对于像int、long、char一类的<strong>内置类型，按值传参会比按引用传参更高效。</strong><h4 id=wei-shi-yao-you-liao-yin-yong-huan-yao-you-zhi-zhen>为什么有了引用还要有指针</h4><p>为了兼容C语言，必然要支持指针<h3 id=sizeofhe-strlende-qu-bie>sizeof和strlen的区别</h3><p>sizeof 运算符：查询对象或类型的大小，在必须知道对象实际大小时使用。<ul><li>sizeof 对数组，得到整个数组所占空间大小。<li>sizeof 对指针，得到指针本身所占空间大小。</ul><p>strlen函数：位于头文件&LTstring.h>，查询空终止字节字符串 <code>str</code> 的长度。<h4 id=yu-fa>语法</h4><ol><li><p>sizeof 运算符</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//返回 size_t 类型值
</span><span>sizeof(类型);
</span><span>sizeof 表达式;
</span></code></pre> <ol><li>返回 类型 的对象表示的字节大小<li>返回 表达式 类型的对象表示的字节大小，不应用隐式转换到表达式</ol> <p><strong>不能用于函数类型、不完整类型（含void）或位域左值</strong></p><li><p>strlen函数</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>size_t </span><span style=color:#8fa1b3;>strlen</span><span>(</span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>str</span><span>);
</span></code></pre> <p>返回<strong>空终止字节字符串</strong> <code>str</code> 的长度。</p></ol><h4 id=qu-bie>区别</h4><ol><li>strlen计算的是字符串的字符个数<li>sizeof计算的是分配空间的字节数<li>strlen是函数，在程序运行时计算，要求字符串以空字符（‘\0’）结尾<li>sizeof是关键字，在程序编译时计算，<del>不能用于返回动态分配的内存空间大小</del>(没想到测试用例，可能意思是用sizeof得不到想要的结果，但是语法上是可以的)</ol><p><strong>32位机器上，一个指针占4个字节；64位机器上，一个指针占8个字节</strong><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>d#include &LTiostream>
</span><span>
</span><span style=color:#b48ead;>using</span><span> std::cin;
</span><span style=color:#b48ead;>using</span><span> std::cout;
</span><span style=color:#b48ead;>using</span><span> std::endl;
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>t1</span><span>() {
</span><span>    cout << "</span><span style=color:#a3be8c;>hello</span><span>";
</span><span>}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>t2</span><span>() {
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>1</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead;>#pragma</span><span> pack(push) </span><span style=color:#65737e;>//保存对齐状态
</span><span style=color:#b48ead;>#pragma</span><span> pack(4)</span><span style=color:#65737e;>//设定为4字节对齐
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>t3 </span><span style=color:#eff1f5;>{
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>char</span><span style=color:#eff1f5;> c;
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>int</span><span style=color:#eff1f5;> a;
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>double</span><span style=color:#eff1f5;> b;
</span><span style=color:#eff1f5;>}</span><span>;
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>t4</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>a</span><span>[</span><span style=color:#d08770;>10</span><span>]) {
</span><span>    cout << sizeof(a) << endl;
</span><span>}
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>t5</span><span>(</span><span style=color:#b48ead;>char </span><span style=color:#bf616a;>a</span><span>[</span><span style=color:#d08770;>10</span><span>]) {
</span><span>    cout << sizeof(a) << endl;
</span><span>}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]) {
</span><span>    </span><span style=color:#b48ead;>int</span><span> a[</span><span style=color:#d08770;>10</span><span>] = { </span><span style=color:#d08770;>0 </span><span>};
</span><span>    </span><span style=color:#b48ead;>int</span><span>* b = </span><span style=color:#b48ead;>new int</span><span>[</span><span style=color:#d08770;>10</span><span>]{ </span><span style=color:#d08770;>0 </span><span>};
</span><span>    </span><span style=color:#b48ead;>char</span><span> c[] = "</span><span style=color:#a3be8c;>hello,world</span><span>";
</span><span>    </span><span style=color:#b48ead;>char</span><span> d[</span><span style=color:#d08770;>3</span><span>] = { '</span><span style=color:#a3be8c;>a</span><span>', '</span><span style=color:#a3be8c;>b</span><span>', '</span><span style=color:#a3be8c;>c</span><span>' };
</span><span>    t3* i = </span><span style=color:#b48ead;>new</span><span> t3[</span><span style=color:#d08770;>10</span><span>]{ </span><span style=color:#d08770;>0</span><span>, </span><span style=color:#d08770;>0 </span><span>};
</span><span>
</span><span>    cout << sizeof(a) << endl;  </span><span style=color:#65737e;>//输出：40     数组所占字节数
</span><span>    cout << sizeof(b) << endl;  </span><span style=color:#65737e;>//输出：4      指针所占字节数
</span><span>    cout << </span><span style=color:#96b5b4;>strlen</span><span>(c) << endl;  </span><span style=color:#65737e;>//输出：11     第一个'\0'字符前面的字符个数
</span><span>    cout << sizeof(c) << endl;  </span><span style=color:#65737e;>//输出：12     字符串（包括'\0'字符）所占字节数
</span><span>    cout << </span><span style=color:#96b5b4;>strlen</span><span>(d) << endl;  </span><span style=color:#65737e;>//输出：23     结果随机，无法预料，无意义
</span><span>    cout << sizeof(d) << endl;  </span><span style=color:#65737e;>//输出：3      数组所占字节数
</span><span>    cout << sizeof(</span><span style=color:#b48ead;>int</span><span>) << endl;</span><span style=color:#65737e;>//输出：4      int类型的对象所占的字节数
</span><span>    </span><span style=color:#65737e;>//cout << sizeof(t1) << endl;   无法将函数作为参数，无论返回值是void还是int之类的
</span><span>    </span><span style=color:#65737e;>//cout << sizeof(t2) << endl;
</span><span>    cout << sizeof(*i) << endl; </span><span style=color:#65737e;>//输出：16     对象所占的字节数
</span><span>    </span><span style=color:#65737e;>//数组传递给函数作参数时，已经隐式转换成指针了
</span><span>    </span><span style=color:#bf616a;>t4</span><span>(a);  </span><span style=color:#65737e;>//输出：4      指针所占字节数
</span><span>    </span><span style=color:#bf616a;>t4</span><span>(b);  </span><span style=color:#65737e;>//输出：4      指针所占字节数
</span><span>
</span><span>    </span><span style=color:#bf616a;>t5</span><span>(c);  </span><span style=color:#65737e;>//输出：4      指针所占字节数
</span><span>    </span><span style=color:#bf616a;>t5</span><span>(d);  </span><span style=color:#65737e;>//输出：4      指针所占字节数
</span><span>    </span><span style=color:#b48ead;>delete[]</span><span> i;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h4 id=jin-jie>进阶</h4><p>空类型的实例仍会占据内存空间，应为声明空类型实例时，必须在内存占有一定空间，否则无法使用这些实例。占多少内存由编译器决定。<p>Visual Studio中，每个空类型的的实例占用1字节的空间。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span>
</span><span style=color:#b48ead;>using</span><span> std::cin;
</span><span style=color:#b48ead;>using</span><span> std::cout;
</span><span style=color:#b48ead;>using</span><span> std::endl;
</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Y1 </span><span style=color:#eff1f5;>{
</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>;
</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Y2 </span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#8fa1b3;>Y2</span><span style=color:#eff1f5;>() </span><span>= </span><span style=color:#b48ead;>default</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>    </span><span style=color:#8fa1b3;>~Y2</span><span style=color:#eff1f5;>() </span><span>= </span><span style=color:#b48ead;>default</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>}</span><span>;
</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Y3 </span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual </span><span style=color:#8fa1b3;>~Y3</span><span style=color:#eff1f5;>() {}
</span><span style=color:#eff1f5;>}</span><span>;
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]) {
</span><span>    Y1 a;
</span><span>    Y2 b;
</span><span>    Y3 c;
</span><span>    cout << sizeof(a) << endl;  </span><span style=color:#65737e;>//1
</span><span>    cout << sizeof(b) << endl;  </span><span style=color:#65737e;>//1
</span><span>    cout << sizeof(c) << endl;  </span><span style=color:#65737e;>//4
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><p>C++的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每个实例中添加一个指向虚函数表的指针。<h3 id=pragma-pack-n>#pragma pack(n)</h3><p>设定结构体、联合以及类成员变量以 n 字节方式对齐<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#pragma</span><span> pack(push)  </span><span style=color:#65737e;>// 保存对齐状态
</span><span style=color:#b48ead;>#pragma</span><span> pack(4)     </span><span style=color:#65737e;>// 设定为 4 字节对齐
</span><span>
</span><span style=color:#b48ead;>struct </span><span>test
</span><span>{
</span><span>    </span><span style=color:#b48ead;>char</span><span> m1;
</span><span>    </span><span style=color:#b48ead;>double</span><span> m4;
</span><span>    </span><span style=color:#b48ead;>int</span><span> m3;
</span><span>};
</span><span>
</span><span style=color:#b48ead;>#pragma</span><span> pack(pop)   </span><span style=color:#65737e;>// 恢复对齐状态
</span></code></pre><h3 id=wei-yu>位域</h3><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>Bit mode: </span><span style=color:#d08770;>2</span><span>;    </span><span style=color:#65737e;>// mode 占 2 位
</span></code></pre><p>类可以将其（非静态）<strong>数据成员</strong>定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。<ul><li>位域在内存中的布局是与机器有关的<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定<li>取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域</ul><h3 id=extern-c>extern "C"</h3><ul><li>外部声明：被 extern 限定的函数或变量是 extern 类型的，标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。extern 将声明和定义区分开来，如果想要声明一个变量而非定义它，就在变量名添加关键字extern，并不要显示地初始化变量。<strong>【任何包含了显示初始化的声明即成为定义】</strong><li>链接指定：被 <code>extern "C"</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</ul><p><code>extern "C"</code> 的作用是让 C++ 编译器将 <code>extern "C"</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#ifdef</span><span> __cplusplus
</span><span style=color:#b48ead;>extern </span><span>"</span><span style=color:#a3be8c;>C</span><span>" {
</span><span style=color:#b48ead;>#endif
</span><span>
</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#8fa1b3;>memset</span><span>(</span><span style=color:#b48ead;>void </span><span>*, </span><span style=color:#bf616a;>int</span><span>, </span><span style=color:#bf616a;>size_t</span><span>);
</span><span>
</span><span style=color:#b48ead;>#ifdef</span><span> __cplusplus
</span><span>}
</span><span style=color:#b48ead;>#endif
</span></code></pre><h3 id=struct-he-typedef-struct>struct 和 typedef struct</h3><p>【详见文章：typedef与struct结构体定义】<p><strong>C语言中：</strong><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>// c
</span><span style=color:#b48ead;>typedef struct</span><span> Student {
</span><span>    </span><span style=color:#b48ead;>int</span><span> age; 
</span><span>} S;
</span></code></pre><p>等价于<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>// c
</span><span style=color:#b48ead;>struct </span><span>Student { 
</span><span>    </span><span style=color:#b48ead;>int</span><span> age; 
</span><span>};
</span><span>
</span><span style=color:#b48ead;>typedef struct</span><span> Student S;
</span></code></pre><p>等价于<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>// c
</span><span style=color:#b48ead;>typedef struct</span><span> Student { 
</span><span>    </span><span style=color:#b48ead;>int</span><span> age; 
</span><span>}S;
</span></code></pre><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。<p>另外还可以定义与 <code>struct Student</code> 不冲突的<strong>同名函数</strong> <code>void Student() {}</code>。<p><strong>C++中：</strong><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。<p>如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索，即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>// cpp
</span><span style=color:#b48ead;>struct </span><span>Student { 
</span><span>    </span><span style=color:#b48ead;>int</span><span> age; 
</span><span>};
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>f</span><span>( Student </span><span style=color:#bf616a;>me </span><span>);       </span><span style=color:#65737e;>// 正确，"struct" 关键字可省略
</span></code></pre><p>若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>typedef struct</span><span> Student { 
</span><span>    </span><span style=color:#b48ead;>int</span><span> age; 
</span><span>} S;
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>Student</span><span>() {}           </span><span style=color:#65737e;>// 正确，定义后 "Student" 只代表此函数
</span><span>
</span><span style=color:#65737e;>//void S() {}               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {
</span><span>    </span><span style=color:#bf616a;>Student</span><span>(); 
</span><span>    </span><span style=color:#b48ead;>struct</span><span> Student me;      </span><span style=color:#65737e;>// 或者 "S me";
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=c-zhong-struct-he-class>C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。<p><strong>区别：</strong><ul><li>最本质的一个区别就是默认的访问控制 <ul><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</ul></ul><p>C++中匿名结构体不会生成默认构造函数，但可用RAII实现构造功能。<h3 id=union-lian-he>union 联合</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在<strong>任意时刻只有一个数据成员可以有值</strong>。当某个成员被赋值后其他成员变为未定义状态。<p>联合有如下<strong>特点：</strong><ul><li>默认访问控制符为 public<li>可以含有构造函数、析构函数<li>不能含有引用类型的成员<li>不能继承自其他类，不能作为基类<li>不能含有虚函数<li>匿名 union 在定义所在作用域可直接访问 union 成员<li>匿名 union 不能包含 protected 成员或 private 成员<li>全局匿名联合必须是静态（static）的</ul><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#include</span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span>
</span><span style=color:#b48ead;>union </span><span>UnionTest {
</span><span>    </span><span style=color:#8fa1b3;>UnionTest</span><span>() : </span><span style=color:#bf616a;>i</span><span>(</span><span style=color:#d08770;>10</span><span>) {};
</span><span>    </span><span style=color:#b48ead;>int</span><span> i;
</span><span>    </span><span style=color:#b48ead;>double</span><span> d;
</span><span>};
</span><span>
</span><span style=color:#b48ead;>static union </span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span> i;
</span><span>    </span><span style=color:#b48ead;>double</span><span> d;
</span><span>};
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {
</span><span>    UnionTest u;
</span><span>
</span><span>    </span><span style=color:#b48ead;>union </span><span>{
</span><span>        </span><span style=color:#b48ead;>int</span><span> i;
</span><span>        </span><span style=color:#b48ead;>double</span><span> d;
</span><span>    };
</span><span>
</span><span>    std::cout << u.</span><span style=color:#bf616a;>i </span><span><< std::endl;  </span><span style=color:#65737e;>// 输出 UnionTest 联合的 10
</span><span>
</span><span>    ::i = </span><span style=color:#d08770;>20</span><span>;
</span><span>    std::cout << ::i << std::endl;  </span><span style=color:#65737e;>// 输出全局静态匿名联合的 20
</span><span>
</span><span>    i = </span><span style=color:#d08770;>30</span><span>;
</span><span>    std::cout << i << std::endl;    </span><span style=color:#65737e;>// 输出局部匿名联合的 30
</span><span>
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=c-shi-xian-c-lei>C 实现 C++ 类</h3><p>C 实现 C++ 的面向对象特性（封装、继承、多态）<ul><li>封装：使用函数指针把属性与方法封装到结构体中<li>继承：结构体嵌套<li>多态：父类与子类方法的函数指针不同</ul><h3 id=explicit-xian-shi-guan-jian-zi>explicit（显式）关键字</h3><p>【详见C++ Primer第7章笔记】<ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href=https://zh.cppreference.com/w/cpp/language/implicit_conversion>按语境转换</a> 除外</ul><p><strong>关键字explicit只对一个实参的构造函数有效</strong>，需要多个实参的构造函数不能用于隐式转换，所以无须声明explicit。<strong>explicit声明只能在类内声明，类外部定义时不应重复</strong>。<p>发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=），此时只能使用直接初始化而不能使用explicit构造函数<p>尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显示地强制进行转换：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>explicit </span><span style=color:#bf616a;>Sales_data</span><span>(</span><span style=color:#b48ead;>const</span><span> std::string &s): </span><span style=color:#bf616a;>bookNo</span><span>(s){}
</span><span style=color:#b48ead;>explicit </span><span style=color:#bf616a;>Sales_data</span><span>(std::istream&){}
</span><span>
</span><span style=color:#65737e;>//正确：实参是一个显示构造的Sales_data对象
</span><span>item.</span><span style=color:#bf616a;>combine</span><span>(</span><span style=color:#bf616a;>Sales_data</span><span>(null_book));
</span><span style=color:#65737e;>//正确：static_cast使用explicit的构造函数创建了一个临时的Sales_data对象
</span><span>item.</span><span style=color:#bf616a;>combine</span><span>(static_cast&LTSales_data>(cin));
</span></code></pre><p><strong>explicit 使用：</strong><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>struct </span><span>A
</span><span>{
</span><span>    </span><span style=color:#bf616a;>A</span><span>(</span><span style=color:#b48ead;>int</span><span>) { }
</span><span>    </span><span style=color:#b48ead;>operator </span><span style=color:#8fa1b3;>bool</span><span>() </span><span style=color:#b48ead;>const </span><span>{ </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>true</span><span>; }
</span><span>};
</span><span>
</span><span style=color:#b48ead;>struct </span><span>B
</span><span>{
</span><span>    </span><span style=color:#b48ead;>explicit </span><span style=color:#bf616a;>B</span><span>(</span><span style=color:#b48ead;>int</span><span>) {}
</span><span>    </span><span style=color:#b48ead;>explicit operator </span><span style=color:#8fa1b3;>bool</span><span>() </span><span style=color:#b48ead;>const </span><span>{ </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>true</span><span>; }
</span><span>};
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>doA</span><span>(A </span><span style=color:#bf616a;>a</span><span>) {}
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>doB</span><span>(B </span><span style=color:#bf616a;>b</span><span>) {}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>()
</span><span>{
</span><span>    A </span><span style=color:#bf616a;>a1</span><span>(</span><span style=color:#d08770;>1</span><span>);        </span><span style=color:#65737e;>// OK：直接初始化
</span><span>    A a2 = </span><span style=color:#d08770;>1</span><span>;        </span><span style=color:#65737e;>// OK：复制初始化
</span><span>    A </span><span style=color:#bf616a;>a3</span><span>{ </span><span style=color:#d08770;>1 </span><span>};        </span><span style=color:#65737e;>// OK：直接列表初始化
</span><span>    A a4 = { </span><span style=color:#d08770;>1 </span><span>};        </span><span style=color:#65737e;>// OK：复制列表初始化
</span><span>    A a5 = (A)</span><span style=color:#d08770;>1</span><span>;        </span><span style=color:#65737e;>// OK：允许 static_cast 的显式转换 
</span><span>    </span><span style=color:#bf616a;>doA</span><span>(</span><span style=color:#d08770;>1</span><span>);            </span><span style=color:#65737e;>// OK：允许从 int 到 A 的隐式转换
</span><span>    </span><span style=color:#b48ead;>if </span><span>(a1);        </span><span style=color:#65737e;>// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span>    </span><span style=color:#b48ead;>bool</span><span> a6（a1）;        </span><span style=color:#65737e;>// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span>    </span><span style=color:#b48ead;>bool</span><span> a7 = a1;        </span><span style=color:#65737e;>// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span>    </span><span style=color:#b48ead;>bool</span><span> a8 = static_cast<</span><span style=color:#b48ead;>bool</span><span>>(a1);  </span><span style=color:#65737e;>// OK ：static_cast 进行直接初始化
</span><span>
</span><span>    B </span><span style=color:#bf616a;>b1</span><span>(</span><span style=color:#d08770;>1</span><span>);        </span><span style=color:#65737e;>// OK：直接初始化
</span><span>    B b2 = </span><span style=color:#d08770;>1</span><span>;        </span><span style=color:#65737e;>// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
</span><span>    B </span><span style=color:#bf616a;>b3</span><span>{ </span><span style=color:#d08770;>1 </span><span>};        </span><span style=color:#65737e;>// OK：直接列表初始化
</span><span>    B b4 = { </span><span style=color:#d08770;>1 </span><span>};        </span><span style=color:#65737e;>// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
</span><span>    B b5 = (B)</span><span style=color:#d08770;>1</span><span>;        </span><span style=color:#65737e;>// OK：允许 static_cast 的显式转换
</span><span>    </span><span style=color:#bf616a;>doB</span><span>(</span><span style=color:#d08770;>1</span><span>);            </span><span style=color:#65737e;>// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
</span><span>    </span><span style=color:#b48ead;>if </span><span>(b1);        </span><span style=color:#65737e;>// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
</span><span>    </span><span style=color:#b48ead;>bool </span><span style=color:#bf616a;>b6</span><span>(b1);        </span><span style=color:#65737e;>// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
</span><span>    </span><span style=color:#b48ead;>bool</span><span> b7 = b1;        </span><span style=color:#65737e;>// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
</span><span>    </span><span style=color:#b48ead;>bool</span><span> b8 = static_cast<</span><span style=color:#b48ead;>bool</span><span>>(b1);  </span><span style=color:#65737e;>// OK：static_cast 进行直接初始化
</span><span>
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=friend-you-yuan-lei-he-you-yuan-han-shu>friend 友元类和友元函数</h3><ul><li>能访问私有成员<li>破坏封装性<li>友元关系不可传递<li>友元关系的单向性<li>友元声明的形式及数量不受限制</ul><h3 id=using>using</h3><p>【详见文章：namespace命名空间】<h4 id=using-sheng-ming>using 声明</h4><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>using</span><span> namespace_name::name;
</span></code></pre><p>引入声明可隐藏另一个同名的引入声明，但如果本身存在一个声明与引入声明同名，则出现重复声明错误。<p><strong>构造函数的 using 声明</strong><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。<p>可重复声明，但必须明确使用。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Derived </span><span style=color:#eff1f5;>: </span><span style=color:#a3be8c;>Base </span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>using</span><span style=color:#eff1f5;> Base::Base;
</span><span style=color:#eff1f5;>    </span><span style=color:#65737e;>/* ... */
</span><span style=color:#eff1f5;>}</span><span>;
</span></code></pre><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#bf616a;>Derived</span><span>(parms) : </span><span style=color:#bf616a;>Base</span><span>(args) { }
</span></code></pre><h4 id=using-zhi-ling>using 指令</h4><p><code>using 指令</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>using </span><span>namespace_name name;
</span></code></pre><p><strong>尽量少使用 <code>using 指令</code> 污染命名空间</strong><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</blockquote><p>using 使用<p>尽量少使用 <code>using 指令</code><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>using namespace</span><span> std;
</span></code></pre><p>应该多使用 <code>using 声明</code><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int</span><span> x;
</span><span>std::cin >> x ;
</span><span>std::cout << x << std::endl;
</span></code></pre><p>或者<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>using</span><span> std::cin;
</span><span style=color:#b48ead;>using</span><span> std::cout;
</span><span style=color:#b48ead;>using</span><span> std::endl;
</span><span style=color:#b48ead;>int</span><span> x;
</span><span>cin >> x;
</span><span>cout << x << endl;
</span></code></pre><h3 id=fan-wei-jie-xi-yun-suan-fu><code>::</code> 范围解析运算符</h3><p><strong>分类：</strong><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</ol><p><strong>使用：</strong><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int</span><span> count = </span><span style=color:#d08770;>11</span><span>;         </span><span style=color:#65737e;>// 全局（::）的 count
</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>A </span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>static int</span><span style=color:#eff1f5;> count;   </span><span style=color:#65737e;>// 类 A 的 count（A::count）
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>int</span><span> A::count = </span><span style=color:#d08770;>21</span><span>;
</span><span>
</span><span style=color:#b48ead;>namespace </span><span>B {
</span><span>    </span><span style=color:#b48ead;>int</span><span> count = </span><span style=color:#d08770;>12</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {
</span><span>    ::count = </span><span style=color:#d08770;>12</span><span>;       </span><span style=color:#65737e;>// 测试 1：设置全局的 count 的值为 12
</span><span>
</span><span>    A::count = </span><span style=color:#d08770;>22</span><span>;      </span><span style=color:#65737e;>// 测试 2：设置类 A 的 count 为 22
</span><span>
</span><span>    B::count = </span><span style=color:#d08770;>32</span><span>;      </span><span style=color:#65737e;>// 测试 3：设置命名空间 B 的count 为 32
</span><span>
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=enum-mei-ju-lei-xing>enum 枚举类型</h3><p><strong>限定作用域的枚举类型</strong><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>enum class </span><span>open_modes { input, output, append };
</span></code></pre><p><strong>不限定作用域的枚举类型</strong><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>enum </span><span>color { red, yellow, green };
</span><span style=color:#b48ead;>enum </span><span>{ floatPrec = </span><span style=color:#d08770;>6</span><span>, doublePrec = </span><span style=color:#d08770;>10 </span><span>};
</span></code></pre><h3 id=decltype>decltype</h3><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>decltype </span><span>( expression )
</span></code></pre><p>decltype 使用<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>// 尾置返回允许我们在参数列表之后声明返回类型
</span><span style=color:#b48ead;>template </span><span><</span><span style=color:#b48ead;>typename</span><span> It>
</span><span style=color:#b48ead;>auto </span><span style=color:#8fa1b3;>fcn</span><span>(It </span><span style=color:#bf616a;>beg</span><span>, It </span><span style=color:#bf616a;>end</span><span>) -> </span><span style=color:#b48ead;>decltype</span><span>(*beg)
</span><span>{
</span><span>    </span><span style=color:#65737e;>// 处理序列
</span><span>    </span><span style=color:#b48ead;>return </span><span>*beg;    </span><span style=color:#65737e;>// 返回序列中一个元素的引用
</span><span>}
</span><span style=color:#65737e;>// 为了使用模板参数成员，必须用 typename
</span><span style=color:#b48ead;>template </span><span><</span><span style=color:#b48ead;>typename</span><span> It>
</span><span style=color:#b48ead;>auto </span><span style=color:#8fa1b3;>fcn2</span><span>(It </span><span style=color:#bf616a;>beg</span><span>, It </span><span style=color:#bf616a;>end</span><span>) -> </span><span style=color:#b48ead;>typename</span><span> remove_reference<</span><span style=color:#b48ead;>decltype</span><span>(*beg)>::type
</span><span>{
</span><span>    </span><span style=color:#65737e;>// 处理序列
</span><span>    </span><span style=color:#b48ead;>return </span><span>*beg;    </span><span style=color:#65737e;>// 返回序列中一个元素的拷贝
</span><span>}
</span></code></pre><h3 id=yin-yong>引用</h3><h4 id=zuo-zhi-yin-yong>左值引用</h4><p>常规引用，一般表示对象的身份。<h4 id=you-zhi-yin-yong>右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。<p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：<ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。<li>能够更简洁明确地定义泛型函数。</ul><h4 id=yin-yong-zhe-die>引用折叠</h4><ul><li><code>X& &</code>、<code>X& &&</code>、<code>X&& &</code> 可折叠成 <code>X&</code><li><code>X&& &&</code> 可折叠成 <code>X&&</code></ul><h3 id=hong>宏</h3><p>预处理阶段实现替换。<p>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的<strong>替换</strong>。<h3 id=cheng-yuan-chu-shi-hua-lie-biao>成员初始化列表</h3><p>好处<ul><li>更高效：少了一次调用默认构造函数的过程。<li>有些场合必须要用初始化列表： <ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</ol></ul><h3 id=initializer-list-lie-biao-chu-shi-hua>initializer_list 列表初始化</h3><p>用<strong>花括号初始化器列表</strong>初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.<p>initializer_list 使用<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>vector</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>initializer_list</span><span>>
</span><span>
</span><span style=color:#b48ead;>template </span><span><</span><span style=color:#b48ead;>class</span><span> T>
</span><span style=color:#b48ead;>struct </span><span>S {
</span><span>    std::vector&LTT> v;
</span><span>    </span><span style=color:#8fa1b3;>S</span><span>(std::initializer_list&LTT> </span><span style=color:#bf616a;>l</span><span>) : </span><span style=color:#bf616a;>v</span><span>(l) {
</span><span>         std::cout << "</span><span style=color:#a3be8c;>constructed with a </span><span>" << l.</span><span style=color:#bf616a;>size</span><span>() << "</span><span style=color:#a3be8c;>-element list</span><span style=color:#96b5b4;>\n</span><span>";
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>append</span><span>(std::initializer_list&LTT> </span><span style=color:#bf616a;>l</span><span>) {
</span><span>        v.</span><span style=color:#bf616a;>insert</span><span>(v.</span><span style=color:#bf616a;>end</span><span>(), l.</span><span style=color:#bf616a;>begin</span><span>(), l.</span><span style=color:#bf616a;>end</span><span>());
</span><span>    }
</span><span>    std::pair<</span><span style=color:#b48ead;>const</span><span> T*, std::size_t> </span><span style=color:#8fa1b3;>c_arr</span><span>() </span><span style=color:#b48ead;>const </span><span>{
</span><span>        </span><span style=color:#b48ead;>return </span><span>{&v[</span><span style=color:#d08770;>0</span><span>], v.</span><span style=color:#bf616a;>size</span><span>()};  </span><span style=color:#65737e;>// 在 return 语句中复制列表初始化
</span><span>                                   </span><span style=color:#65737e;>// 这不使用 std::initializer_list
</span><span>    }
</span><span>};
</span><span>
</span><span style=color:#b48ead;>template </span><span><</span><span style=color:#b48ead;>typename</span><span> T>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>templated_fn</span><span>(</span><span style=color:#bf616a;>T</span><span>) {}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>()
</span><span>{
</span><span>    S<</span><span style=color:#b48ead;>int</span><span>> s = {</span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>2</span><span>, </span><span style=color:#d08770;>3</span><span>, </span><span style=color:#d08770;>4</span><span>, </span><span style=color:#d08770;>5</span><span>}; </span><span style=color:#65737e;>// 复制初始化
</span><span>    s.</span><span style=color:#bf616a;>append</span><span>({</span><span style=color:#d08770;>6</span><span>, </span><span style=color:#d08770;>7</span><span>, </span><span style=color:#d08770;>8</span><span>});      </span><span style=color:#65737e;>// 函数调用中的列表初始化
</span><span>
</span><span>    std::cout << "</span><span style=color:#a3be8c;>The vector size is now </span><span>" << s.</span><span style=color:#bf616a;>c_arr</span><span>().</span><span style=color:#bf616a;>second </span><span><< "</span><span style=color:#a3be8c;> ints:</span><span style=color:#96b5b4;>\n</span><span>";
</span><span>
</span><span>    </span><span style=color:#b48ead;>for </span><span>(</span><span style=color:#b48ead;>auto</span><span> n : s.</span><span style=color:#bf616a;>v</span><span>)
</span><span>        std::cout << n << ' ';
</span><span>    std::cout << '</span><span style=color:#96b5b4;>\n</span><span>';
</span><span>
</span><span>    std::cout << "</span><span style=color:#a3be8c;>Range-for over brace-init-list: </span><span style=color:#96b5b4;>\n</span><span>";
</span><span>
</span><span>    </span><span style=color:#b48ead;>for </span><span>(</span><span style=color:#b48ead;>int</span><span> x : {-</span><span style=color:#d08770;>1</span><span>, -</span><span style=color:#d08770;>2</span><span>, -</span><span style=color:#d08770;>3</span><span>}) </span><span style=color:#65737e;>// auto 的规则令此带范围 for 工作
</span><span>        std::cout << x << ' ';
</span><span>    std::cout << '</span><span style=color:#96b5b4;>\n</span><span>';
</span><span>
</span><span>    </span><span style=color:#b48ead;>auto</span><span> al = {</span><span style=color:#d08770;>10</span><span>, </span><span style=color:#d08770;>11</span><span>, </span><span style=color:#d08770;>12</span><span>};   </span><span style=color:#65737e;>// auto 的特殊规则
</span><span>
</span><span>    std::cout << "</span><span style=color:#a3be8c;>The list bound to auto has size() = </span><span>" << al.</span><span style=color:#bf616a;>size</span><span>() << '</span><span style=color:#96b5b4;>\n</span><span>';
</span><span>
</span><span style=color:#65737e;>//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，
</span><span>                             </span><span style=color:#65737e;>// 它无类型，故 T 无法推导
</span><span>    templated_fn&LTstd::initializer_list<</span><span style=color:#b48ead;>int</span><span>>>({</span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>2</span><span>, </span><span style=color:#d08770;>3</span><span>}); </span><span style=color:#65737e;>// OK
</span><span>    templated_fn&LTstd::vector<</span><span style=color:#b48ead;>int</span><span>>>({</span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>2</span><span>, </span><span style=color:#d08770;>3</span><span>});           </span><span style=color:#65737e;>// 也 OK
</span><span>}
</span></code></pre><h3 id=mian-xiang-dui-xiang>面向对象</h3><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。<p>面向对象三大特征 —— 封装、继承、多态<p><img alt=面向对象特征 src=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png><h3 id=feng-zhuang>封装</h3><p>把客观事物<strong>封装成抽象</strong>的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<p>关键字：public, protected, private。默认为 private。<ul><li><code>public</code> 成员：可以被任意实体访问<li><code>protected</code> 成员：只允许被子类及本类的成员函数访问<li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</ul><h3 id=ji-cheng>继承</h3><ul><li>基类（父类）——> 派生类（子类）</ul><h3 id=duo-tai>多态</h3><ul><li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。<li>多态是以封装和继承为基础的<li>C++ 多态分类及实现： <ul><li>分类：编译时多态（静态）、运行时多态（动态）<li>实现： <ul><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载<li>子类型多态（Subtype Polymorphism，运行期）：虚函数<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</ul></ul></ul><h4 id=bian-yi-shi-duo-tai>编译时多态</h4><p>函数重载<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>A
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>void do</span><span style=color:#eff1f5;>(</span><span style=color:#b48ead;>int</span><span style=color:#eff1f5;> a);
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>void do</span><span style=color:#eff1f5;>(</span><span style=color:#b48ead;>int</span><span style=color:#eff1f5;> a, </span><span style=color:#b48ead;>int</span><span style=color:#eff1f5;> b);
</span><span style=color:#eff1f5;>}</span><span>;
</span></code></pre><h4 id=yun-xing-shi-duo-tai>运行时多态</h4><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</ul><p><strong>注意：</strong><ul><li>普通函数（非类成员函数）不能是虚函数<li>静态函数（static）不能是虚函数<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）<li>内联函数不能是表现多态性时的虚函数</ul><p>动态多态使用<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Shape                     </span><span style=color:#65737e;>// 形状类
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual double </span><span style=color:#8fa1b3;>calcArea</span><span style=color:#eff1f5;>()
</span><span style=color:#eff1f5;>    {
</span><span style=color:#eff1f5;>        </span><span>...
</span><span style=color:#eff1f5;>    }
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual </span><span style=color:#8fa1b3;>~Shape</span><span style=color:#eff1f5;>();
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Circle </span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>Shape     </span><span style=color:#65737e;>// 圆形类
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual double </span><span style=color:#8fa1b3;>calcArea</span><span style=color:#eff1f5;>();
</span><span style=color:#eff1f5;>    </span><span>...
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Rect </span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>Shape       </span><span style=color:#65737e;>// 矩形类
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual double </span><span style=color:#8fa1b3;>calcArea</span><span style=color:#eff1f5;>();
</span><span style=color:#eff1f5;>    </span><span>...
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>()
</span><span>{
</span><span>    Shape * shape1 = </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>Circle</span><span>(</span><span style=color:#d08770;>4.0</span><span>);
</span><span>    Shape * shape2 = </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>Rect</span><span>(</span><span style=color:#d08770;>5.0</span><span>, </span><span style=color:#d08770;>6.0</span><span>);
</span><span>    shape1-></span><span style=color:#bf616a;>calcArea</span><span>();         </span><span style=color:#65737e;>// 调用圆形类里面的方法
</span><span>    shape2-></span><span style=color:#bf616a;>calcArea</span><span>();         </span><span style=color:#65737e;>// 调用矩形类里面的方法
</span><span>    </span><span style=color:#b48ead;>delete</span><span> shape1;
</span><span>    shape1 = </span><span style=color:#d08770;>nullptr</span><span>;
</span><span>    </span><span style=color:#b48ead;>delete</span><span> shape2;
</span><span>    shape2 = </span><span style=color:#d08770;>nullptr</span><span>;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=qu-fen-ji-cheng-fu-gai-yin-cang-zhong-zai>区分继承、覆盖、隐藏、重载</h3><p><strong>继承</strong>：子类继承父类的部分成员变量和成员函数<p><strong>覆盖</strong>：父类存在虚函数，子类重新实现该虚函数，可用override显示声明<p><strong>隐藏</strong>：子类同名成员隐藏父类同名成员<p><strong>重载</strong>：相同作用域中的不同函数（函数声明不同，但函数名相同）<h3 id=xu-xi-gou-han-shu>虚析构函数</h3><p>虚析构函数是为了解决<strong>基类的指针</strong>指向<strong>派生类对象</strong>，并用基类的指针删除派生类对象。<p>虚析构函数使用<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Shape
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#8fa1b3;>Shape</span><span style=color:#eff1f5;>();                    </span><span style=color:#65737e;>// 构造函数不能是虚函数
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual double </span><span style=color:#8fa1b3;>calcArea</span><span style=color:#eff1f5;>();
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual </span><span style=color:#8fa1b3;>~Shape</span><span style=color:#eff1f5;>();           </span><span style=color:#65737e;>// 虚析构函数
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Circle </span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>Shape     </span><span style=color:#65737e;>// 圆形类
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual double </span><span style=color:#8fa1b3;>calcArea</span><span style=color:#eff1f5;>();
</span><span style=color:#eff1f5;>    </span><span>...
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>()
</span><span>{
</span><span>    Shape * shape1 = </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>Circle</span><span>(</span><span style=color:#d08770;>4.0</span><span>);
</span><span>    shape1-></span><span style=color:#bf616a;>calcArea</span><span>();    
</span><span>    </span><span style=color:#b48ead;>delete</span><span> shape1;  </span><span style=color:#65737e;>// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
</span><span>    shape1 = </span><span style=color:#d08770;>NULL</span><span>;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>；
</span><span>}
</span></code></pre><h3 id=chun-xu-han-shu>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。<p>含有纯虚函数的类不能实例化。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>virtual int </span><span style=color:#8fa1b3;>A</span><span>() = </span><span style=color:#d08770;>0</span><span>;
</span></code></pre><h3 id=xu-han-shu-chun-xu-han-shu>虚函数、纯虚函数</h3><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面<strong>可以被覆盖</strong>（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并实现覆盖纯虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。<li>虚基类是虚继承中的基类</ul><h3 id=xu-han-shu-zhi-zhen-xu-han-shu-biao>虚函数指针、虚函数表</h3><ul><li>虚函数指针：存在含有虚函数的类的<strong>对象</strong>中，指向虚函数表，在运行时确定。<li>虚函数表：在程序只读数据段（<code>.rodata section</code>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</ul><h3 id=xu-ji-cheng>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。<h3 id=xu-ji-cheng-xu-han-shu>虚继承、虚函数</h3><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）<li>不同之处： <ul><li>虚继承 <ul><li>虚基类依旧存在继承类中，只占用存储空间<li>虚基类表存储的是虚基类相对直接继承类的偏移</ul><li>虚函数 <ul><li>虚函数不占用存储空间<li>虚函数表存储的是虚函数地址</ul></ul></ul><h3 id=mo-ban-lei-cheng-yuan-mo-ban-xu-han-shu>模板类、成员模板、虚函数</h3><ul><li>模板类中可以使用虚函数<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</ul><h3 id=chou-xiang-lei-jie-kou-lei-ju-he-lei>抽象类、接口类、聚合类</h3><ul><li>抽象类：含有纯虚函数的类<li>接口类：仅含有纯虚函数的抽象类<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： <ul><li>所有成员都是 public<li>没有定义任何构造函数<li>没有类内初始化<li>没有基类，也没有 virtual 函数</ul></ul><h3 id=nei-cun-fen-pei-he-guan-li>内存分配和管理</h3><h4 id=cde-shen-qing-nei-cun>C的申请内存</h4><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</ol><blockquote><p>malloc后要判断是否申请成功<p>free后要将指针置空</blockquote><p>malloc：<ul><li>若分配成功，则返回指向分配内存块最低位（首位）字节的，为任何拥有基础对齐的对象类型对齐的指针。<li>若 <code>size</code> 为零，则行为是实现定义的（可返回空指针，或返回不会用于访问存储但必须传递给 <code>free</code>的非空指针）。使用完后必须用 <code>free()</code>或 <code>realloc()</code> 解分配返回的指针<li><code>malloc</code> 是线程安全的：它表现得如同只访问通过其参数可见的内存区域，而非任何静态存储。</ul><h4 id=c-de-shen-qing-nei-cun>C++的申请内存</h4><ol><li>new / new[]：完成两件事，先底层调用 malloc <strong>分配</strong>了内存，然后调用<strong>构造</strong>函数（创建对象）。<li>delete/delete[]：也完成两件事，先调用<strong>析构</strong>函数（清理资源），然后底层调用 free <strong>释放</strong>空间。<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</ol><p>new、delete 使用<p>申请内存，<strong>确认new是否申请成功无法通过判空判断</strong><h4 id=placement-new>placement new</h4><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>new </span><span>(place_address) type
</span><span style=color:#b48ead;>new </span><span>(place_address) </span><span style=color:#bf616a;>type </span><span>(initializers)
</span><span style=color:#b48ead;>new </span><span>(place_address) type [size]
</span><span style=color:#b48ead;>new </span><span>(place_address) type [size] { braced initializer list }
</span></code></pre><ul><li><code>place_address</code> 是个指针<li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</ul><h4 id=newyu-mallocde-qu-bie-deletehe-freede-qu-bie>new与malloc的区别，delete和free的区别</h4><ol><li>new和delete是关键字，需要编译器的支持；malloc和free是库函数，需要包含库头文件。<li>malloc/free是c/c++标准库的函数，只负责动态地申请和释放内存。new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。<li>malloc/free需要手动计算类型大小且返回值是void*，new/delete可以自己计算类型大小，返回对应的指针。</ol><h3 id=delete-this-shi-fou-he-fa>delete this 是否合法</h3><p>合法，但：<ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了<li>必须保证 <code>delete this</code> 后没有人使用了</ol><h3 id=kong-zhi-lei-dui-xiang-sheng-cheng>控制类对象生成</h3><h4 id=zhi-neng-zai-dui-shang>只能在堆上</h4><p>方法：将析构函数设置为私有<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。<h4 id=zhi-neng-zai-zhan-shang>只能在栈上</h4><p>方法：将 new 和 delete 重载为私有<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。<h3 id=zhi-neng-zhi-zhen>智能指针</h3><h4 id=c-biao-zhun-ku-stl-zhong>C++ 标准库（STL）中</h4><p>头文件：<code>#include &LTmemory></code><h4 id=c-98>C++ 98</h4><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>std::auto_ptr&LTstd::string> </span><span style=color:#8fa1b3;>ps </span><span>(</span><span style=color:#b48ead;>new </span><span>std::</span><span style=color:#bf616a;>string</span><span>(str))；
</span></code></pre><h4 id=c-11-shi-ji-yi-yi-shang-de-zhi-neng-zhi-zhen>C++ 11（实际意义上的智能指针）</h4><ol><li>shared_ptr<li>unique_ptr<li>weak_ptr<li>auto_ptr（被 C++11 弃用）</ol><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</ul><p><strong>shared_ptr</strong><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。<ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</ul><p><strong>weak_ptr</strong><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。<ul><li>可打破循环引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</ul><p><strong>unique_ptr</strong><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有者被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。<ul><li>unique_ptr 用于取代 auto_ptr</ul><h5 id=auto-ptr>auto_ptr</h5><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。<h5 id=auto-ptr-yu-unique-ptr-bi-jiao>auto_ptr 与 unique_ptr 比较</h5><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；<li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</ul><h3 id=qiang-zhi-lei-xing-zhuan-huan-yun-suan-fu>强制类型转换运算符</h3><p><a href=CppPrimer-%E7%AC%AC4%E7%AB%A0.md#4%2011%203%20%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2>显示转换</a><p><strong>static_cast</strong><ul><li>用于非多态类型的转换<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）<li>通常用于转换数值数据类型（如 float -> int）<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</ul><blockquote><p>向上转换是一种隐式转换。</blockquote><p><strong>dynamic_cast</strong><ul><li>用于多态类型的转换<li>执行行运行时类型检查<li>只适用于指针或引用<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</ul><p><strong>const_cast</strong><ul><li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</ul><p>reinterpret_cast<ul><li>用于位的简单重新解释<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。<li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）<li>也允许将任何整数类型转换为任何指针类型以及反向转换。<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。<li>reinterpret_cast 的一个实际用途是在哈希函数中，即通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</ul><h4 id=bad-cast>bad_cast</h4><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</ul><p>bad_cast 使用<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>try </span><span>{  
</span><span>    Circle& ref_circle = dynamic_cast&LTCircle&>(ref_shape);   
</span><span>}  
</span><span style=color:#b48ead;>catch </span><span>(bad_cast b) {  
</span><span>    cout << "</span><span style=color:#a3be8c;>Caught: </span><span>" << b.</span><span style=color:#bf616a;>what</span><span>();  
</span><span>} 
</span></code></pre><h3 id=yun-xing-shi-lei-xing-xin-xi-rtti>运行时类型信息 (RTTI)</h3><h4 id=dynamic-cast>dynamic_cast</h4><ul><li>用于多态类型的转换</ul><h4 id=typeid>typeid</h4><ul><li>typeid 运算符允许在运行时确定对象的类型<li>type_id 返回一个 type_info 对象的引用<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数<li>只能获取对象的实际类型</ul><h4 id=type-info>type_info</h4><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。<li>头文件：<code>typeinfo</code></ul><p>typeid、type_info 使用<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>using namespace</span><span> std;
</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Flyable                       </span><span style=color:#65737e;>// 能飞的
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual void </span><span style=color:#8fa1b3;>takeoff</span><span style=color:#eff1f5;>() </span><span>= </span><span style=color:#d08770;>0</span><span style=color:#eff1f5;>;     </span><span style=color:#65737e;>// 起飞
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual void </span><span style=color:#8fa1b3;>land</span><span style=color:#eff1f5;>() </span><span>= </span><span style=color:#d08770;>0</span><span style=color:#eff1f5;>;        </span><span style=color:#65737e;>// 降落
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Bird </span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>Flyable         </span><span style=color:#65737e;>// 鸟
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>foraging</span><span style=color:#eff1f5;>() {</span><span>...</span><span style=color:#eff1f5;>}           </span><span style=color:#65737e;>// 觅食
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual void </span><span style=color:#8fa1b3;>takeoff</span><span style=color:#eff1f5;>() {</span><span>...</span><span style=color:#eff1f5;>}
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual void </span><span style=color:#8fa1b3;>land</span><span style=color:#eff1f5;>() {</span><span>...</span><span style=color:#eff1f5;>}
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual </span><span style=color:#8fa1b3;>~Bird</span><span style=color:#eff1f5;>(){}
</span><span style=color:#eff1f5;>}</span><span>;
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Plane </span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>Flyable        </span><span style=color:#65737e;>// 飞机
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>carry</span><span style=color:#eff1f5;>() {</span><span>...</span><span style=color:#eff1f5;>}              </span><span style=color:#65737e;>// 运输
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual void </span><span style=color:#8fa1b3;>takeoff</span><span style=color:#eff1f5;>() {</span><span>...</span><span style=color:#eff1f5;>}
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual void </span><span style=color:#8fa1b3;>land</span><span style=color:#eff1f5;>() {</span><span>...</span><span style=color:#eff1f5;>}
</span><span style=color:#eff1f5;>}</span><span>;
</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>type_info
</span><span style=color:#eff1f5;>{
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>const char</span><span>* </span><span style=color:#8fa1b3;>name</span><span style=color:#eff1f5;>() </span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>bool </span><span style=color:#8fa1b3;>operator == </span><span style=color:#eff1f5;>(</span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;> type_info </span><span>& </span><span style=color:#bf616a;>rhs</span><span style=color:#eff1f5;>) </span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>bool </span><span style=color:#8fa1b3;>operator != </span><span style=color:#eff1f5;>(</span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;> type_info </span><span>& </span><span style=color:#bf616a;>rhs</span><span style=color:#eff1f5;>) </span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>before</span><span style=color:#eff1f5;>(</span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;> type_info </span><span>& </span><span style=color:#bf616a;>rhs</span><span style=color:#eff1f5;>) </span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>virtual </span><span style=color:#8fa1b3;>~type_info</span><span style=color:#eff1f5;>();
</span><span style=color:#b48ead;>private</span><span style=color:#eff1f5;>:
</span><span style=color:#eff1f5;>    </span><span>...
</span><span style=color:#eff1f5;>}</span><span>;
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>doSomething</span><span>(Flyable *</span><span style=color:#bf616a;>obj</span><span>)                 </span><span style=color:#65737e;>// 做些事情
</span><span>{
</span><span>    obj-></span><span style=color:#bf616a;>takeoff</span><span>();
</span><span>
</span><span>    cout << typeid(*obj).</span><span style=color:#bf616a;>name</span><span>() << endl;        </span><span style=color:#65737e;>// 输出传入对象类型（"class Bird" or "class Plane"）
</span><span>
</span><span>    </span><span style=color:#b48ead;>if</span><span>(typeid(*obj) == typeid(Bird))            </span><span style=color:#65737e;>// 判断对象类型
</span><span>    {
</span><span>        Bird *bird = dynamic_cast&LTBird *>(obj); </span><span style=color:#65737e;>// 对象转化
</span><span>        bird-></span><span style=color:#bf616a;>foraging</span><span>();
</span><span>    }
</span><span>
</span><span>    obj-></span><span style=color:#bf616a;>land</span><span>();
</span><span>}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(){
</span><span>    Bird *b = </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>Bird</span><span>();
</span><span>    </span><span style=color:#bf616a;>doSomething</span><span>(b);
</span><span>    </span><span style=color:#b48ead;>delete</span><span> b;
</span><span>    b = </span><span style=color:#d08770;>nullptr</span><span>;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h2 id=effective-c>Effective C++</h2><ol><li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）<li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）<li>尽可能使用 const<li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）<li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）<li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）<li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）<li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）<li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）<li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）<li>在 <code>operator=</code> 中处理 “自我赋值”<li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）<li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））<li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））<li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）<li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）<li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）<li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）<li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。<li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）<li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）<li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）<li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）<li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数<li>考虑写一个不抛异常的 swap 函数<li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）<li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&LTT>(expression)</code>、<code>dynamic_cast&LTT>(expression)</code>、<code>reinterpret_cast&LTT>(expression)</code>、<code>static_cast&LTT>(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）<li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）<li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）<li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）<li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）<li>确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）<li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）<li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）<li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）<li>绝不重新定义继承而来的 non-virtual 函数<li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）<li>通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））<li>明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）<li>明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）<li>了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）<li>了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）<li>学习处理模板化基类内的名称（可在 derived class templates 内通过 <code>this-></code> 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）<li>将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）<li>运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）<li>需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）<li>请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if...else 测试）<li>认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）<li>了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）<li>了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）<li>编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）<li>写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）<li>不要轻忽编译器的警告<li>让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）<li>让自己熟悉 Boost（准标准库）</ol><h2 id=more-effective-c>More Effective C++</h2><ol><li>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）<li>最好使用 C++ 转型操作符（<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>）<li>绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）<li>非必要不提供 default constructor（避免对象中的字段被无意义地初始化）<li>对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）<li>区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）<li>千万不要重载 <code>&&</code>，<code>||</code> 和 <code>,</code> 操作符（<code>&&</code> 与 <code>||</code> 的重载会用 “函数调用语义” 取代 “骤死式语义”；<code>,</code> 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）<li>了解各种不同意义的 new 和 delete（<code>new operator</code>、<code>operator new</code>、<code>placement new</code>、<code>operator new[]</code>；<code>delete operator</code>、<code>operator delete</code>、<code>destructor</code>、<code>operator delete[]</code>）<li>利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）<li>在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try...catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）<li>禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）<li>了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）<li>以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）<li>明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）<li>了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）<li>谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）<li>考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）<li>分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）</ol><h2 id=google-c-style-guide>Google C++ Style Guide</h2><ul><li>英文：<a href=https://google.github.io/styleguide/cppguide.html>Google C++ Style Guide</a><li>中文：<a href=https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/>C++ 风格指南</a></ul><h2 id=qi-ta>其他</h2><ul><li><a href=http://www.stroustrup.com/bs_faq.html>Bjarne Stroustrup 的常见问题</a><li><a href=http://www.stroustrup.com/bs_faq2.html>Bjarne Stroustrup 的 C++ 风格和技巧常见问题</a></ul><h2 id=shu-ju-jie-gou>数据结构</h2><p>【详见文章：数据结构】<h2 id=suan-fa-algorithm>算法（Algorithm）</h2><h3 id=di-gui>递归</h3><p>概念：函数直接或间接地调用自身<h4 id=di-gui-yu-fen-zhi>递归与分治</h4><ul><li>分治法 <ul><li>问题的分解<li>问题规模的分解</ul><li>折半查找（递归）<li>归并排序（递归）<li>快速排序（递归）</ul><h4 id=di-gui-yu-die-dai>递归与迭代</h4><ul><li>迭代：反复利用变量旧值推出新值<li>折半查找（迭代）<li>归并排序（迭代）</ul><h3 id=pai-xu>排序</h3><h3 id=cha-zhao>查找</h3><h3 id=tu-sou-suo>图搜索</h3><table><thead><tr><th>图搜索算法<th>数据结构<th>遍历时间复杂度<th>空间复杂度<tbody><tr><td>BFS广度优先搜索<td>邻接矩阵<br>邻接链表<td>O(|v|2)<br>O(|v|+|E|)<td>O(|v|2)<br>O(|v|+|E|)<tr><td>DFS深度优先搜索<td>邻接矩阵<br>邻接链表<td>O(|v|2)<br>O(|v|+|E|)<td>O(|v|2)<br>O(|v|+|E|)</table><h3 id=suan-fa-ce-lue>算法策略</h3><table><thead><tr><th>算法<th>思想<th>应用<tbody><tr><td>分治法<td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并<td>循环赛日程安排问题、排序算法（快速排序、归并排序）<tr><td>动态规划<td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题<td>背包问题、斐波那契数列<tr><td>贪心法<td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法<td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</table><h2 id=cao-zuo-xi-tong>操作系统</h2><h2 id=ji-suan-ji-wang-luo>计算机网络</h2><h2 id=unixwang-luo-bian-cheng>Unix网络编程</h2><h2 id=shu-ju-ku>数据库</h2><blockquote><p>本节部分知识点来自《数据库系统概论（第 5 版）》</blockquote><h3 id=ji-ben-gai-nian>基本概念</h3><ul><li>数据（data）：描述事物的符号记录称为数据。<li>数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有<strong>永久存储、有组织、可共享</strong>三个基本特点。<li>数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。<li>数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。<li>实体（entity）：客观存在并可相互区别的事物称为实体。<li>属性（attribute）：实体所具有的某一特性称为属性。<li>码（key）：唯一标识实体的属性集称为码。<li>实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。<li>实体集（entity set）：同一实体型的集合称为实体集。<li>联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。<li>模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。<li>外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。<li>内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。</ul><h3 id=chang-yong-shu-ju-mo-xing>常用数据模型</h3><ul><li>层次模型（hierarchical model）<li>网状模型（network model）<li>关系模型（relational model） <ul><li>关系（relation）：一个关系对应通常说的一张表<li>元组（tuple）：表中的一行即为一个元组<li>属性（attribute）：表中的一列即为一个属性<li>码（key）：表中可以唯一确定一个元组的某个属性组<li>域（domain）：一组具有相同数据类型的值的集合<li>分量：元组中的一个属性值<li>关系模式：对关系的描述，一般表示为 <code>关系名(属性1, 属性2, ..., 属性n)</code></ul><li>面向对象数据模型（object oriented data model）<li>对象关系数据模型（object relational data model）<li>半结构化数据模型（semistructure data model）</ul><h3 id=chang-yong-sql-cao-zuo>常用 SQL 操作</h3><table><thead><tr><th>对象类型<th>对象<th>操作类型<tbody><tr><td>数据库模式<td>模式<td><code>CREATE SCHEMA</code><tr><td>基本表<td><code>CREATE SCHEMA</code>，<code>ALTER TABLE</code><td><tr><td>视图<td><code>CREATE VIEW</code><td><tr><td>索引<td><code>CREATE INDEX</code><td><tr><td>数据<td>基本表和视图<td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code><tr><td>属性列<td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code><td></table><blockquote><p>SQL 语法教程：<a href=http://www.runoob.com/sql/sql-tutorial.html>runoob . SQL 教程</a></blockquote><h3 id=guan-xi-xing-shu-ju-ku>关系型数据库</h3><ul><li>基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改<li>关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性</ul><h4 id=suo-yin>索引</h4><ul><li>数据库索引：顺序索引、B+ 树索引、hash 索引<li><a href=http://blog.codinglabs.org/articles/theory-of-mysql-index.html>MySQL 索引背后的数据结构及算法原理</a></ul><h3 id=shu-ju-ku-wan-zheng-xing>数据库完整性</h3><ul><li>数据库的完整性是指数据的正确性和相容性。 <ul><li>完整性：为了防止数据库中存在不符合语义（不正确）的数据。<li>安全性：为了保护数据库防止恶意破坏和非法存取。</ul><li>触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。</ul><h3 id=guan-xi-shu-ju-li-lun>关系数据理论</h3><ul><li>数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。<li>最重要的数据依赖：函数依赖、多值依赖。</ul><h4 id=fan-shi>范式</h4><ul><li>第一范式（1NF）：属性（字段）是最小单位不可再分。<li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。<li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 非主属性对码的传递函数依赖）。<li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。<li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。</ul><h3 id=shu-ju-ku-hui-fu>数据库恢复</h3><ul><li>事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。<li>事物的 ACID 特性：原子性、一致性、隔离性、持续性。<li>恢复的实现技术：建立冗余数据 -> 利用冗余数据实施数据库恢复。<li>建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。</ul><h3 id=bing-fa-kong-zhi>并发控制</h3><ul><li>事务是并发控制的基本单位。<li>并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。<li>并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。<li>基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。<li>活锁死锁： <ul><li>活锁：事务永远处于等待状态，可通过先来先服务的策略避免。<li>死锁：事物永远不能结束 <ul><li>预防：一次封锁法、顺序封锁法；<li>诊断：超时法、等待图法；<li>解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。</ul></ul><li>可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。</ul><h2 id=she-ji-mo-shi>设计模式</h2><h3 id=she-ji-mo-shi-de-liu-da-yuan-ze>设计模式的六大原则</h3><ul><li>单一职责原则（SRP，Single Responsibility Principle）<li>里氏替换原则（LSP，Liskov Substitution Principle）<li>依赖倒置原则（DIP，Dependence Inversion Principle）<li>接口隔离原则（ISP，Interface Segregation Principle）<li>迪米特法则（LoD，Law of Demeter）<li>开放封闭原则（OCP，Open Close Principle）</ul><h2 id=lian-jie-zhuang-zai-ku>链接装载库</h2><blockquote><p>本节部分知识点来自《程序员的自我修养——链接装载库》</blockquote><h3 id=nei-cun-zhan-dui>内存、栈、堆</h3><p>一般应用程序内存空间有如下区域：<ul><li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文<li>堆：一般由程序员分配释放，若程序员不释放，程序结束时由操作系统回收，用来容纳应用程序动态分配的内存区域<li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</ul><h4 id=zhan>栈</h4><p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：<ul><li>函数的返回地址和参数<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量<li>保存上下文：包括函数调用前后需要保持不变的寄存器</ul><h4 id=dui>[堆</h4><p>堆分配算法：<ul><li>空闲链表（Free List）<li>位图（Bitmap）<li>对象池</ul><blockquote><ul><li>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。<li>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</ul></blockquote><h4 id=duan-cuo-wu-segment-fault-huo-fei-fa-cao-zuo-gai-nei-cun-di-zhi-bu-neng-read-write>“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</h4><p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。<p>普遍原因：<ul><li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针<li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</ul><h3 id=bian-yi-lian-jie>编译链接</h3><h4 id=ge-ping-tai-wen-jian-ge-shi>各平台文件格式</h4><table><thead><tr><th>平台<th>可执行文件<th>目标文件<th>动态库/共享对象<th>静态库<tbody><tr><td>Windows<td>exe<td>obj<td>dll<td>lib<tr><td>Unix/Linux<td>ELF、out<td>o<td>so<td>a<tr><td>Mac<td>Mach-O<td>o<td>dylib、tbd、framework<td>a、framework</table><h4 id=bian-yi-lian-jie-guo-cheng>编译链接过程</h4><ol><li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）<li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）<li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）<li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</ol><blockquote><p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</blockquote><blockquote><p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</blockquote><h4 id=mu-biao-wen-jian>目标文件</h4><p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。<blockquote><p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</blockquote><h5 id=mu-biao-wen-jian-ge-shi>目标文件格式</h5><ul><li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式<li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式<li>Intel/Microsoft 的 OMF（Object Module Format）<li>Unix 的 <code>a.out</code> 格式<li>MS-DOS 的 <code>.COM</code> 格式</ul><blockquote><p>PE 和 ELF 都是 COFF（Common File Format）的变种</blockquote><h5 id=mu-biao-wen-jian-cun-chu-jie-gou>目标文件存储结构</h5><table><thead><tr><th>段<th>功能<tbody><tr><td>File Header<td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）<tr><td>.text section<td>代码段，执行语句编译成的机器代码<tr><td>.data section<td>数据段，已初始化的全局变量和局部静态变量<tr><td>.bss section<td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）<tr><td>.rodata section<td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量<tr><td>.comment section<td>注释信息段，存放编译器版本信息<tr><td>.note.GNU-stack section<td>堆栈提示段</table><blockquote><p>其他段略</blockquote><h4 id=lian-jie-de-jie-kou-fu-hao>链接的接口——符号</h4><p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。<p>如下符号表（Symbol Table）：<table><thead><tr><th>Symbol（符号名）<th>Symbol Value （地址）<tbody><tr><td>main<td>0x100<tr><td>Add<td>0x123<tr><td>...<td>...</table><h3 id=linux-de-gong-xiang-ku-shared-library>Linux 的共享库（Shared Library）</h3><p>Linux 下的共享库就是普通的 ELF 共享对象。<p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容<h4 id=ming-ming>命名</h4><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>libname.so.x.y.z
</span></code></pre><ul><li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译<li>y：次版本号，高版本号向后兼容低版本号<li>z：发布版本号，不对接口进行更改，完全兼容</ul><h4 id=lu-jing>路径</h4><p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。<ul><li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等<li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库<li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</ul><blockquote><p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</blockquote><h4 id=huan-jing-bian-liang>环境变量</h4><ul><li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序<li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件<li><code>LD_DEBUG</code>：打开动态链接器的调试功能</ul><h4 id=so-gong-xiang-ku-de-bian-xie>so 共享库的编写</h4><p>使用 CLion 编写共享库<p>创建一个名为 MySharedLib 的共享库<p>CMakeLists.txt<pre class=language-cmake data-lang=cmake style=background-color:#2b303b;color:#c0c5ce;><code class=language-cmake data-lang=cmake><span style=color:#96b5b4;>cmake_minimum_required</span><span>(</span><span style=color:#bf616a;>VERSION </span><span>3.10)
</span><span style=color:#96b5b4;>project</span><span>(MySharedLib)
</span><span>
</span><span style=color:#96b5b4;>set</span><span>(</span><span style=color:#bf616a;>CMAKE_CXX_STANDARD </span><span>11)
</span><span>
</span><span style=color:#96b5b4;>add_library</span><span>(MySharedLib </span><span style=color:#bf616a;>SHARED </span><span>library.cpp library.h)
</span></code></pre><p>library.h<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#ifndef</span><span> MYSHAREDLIB_LIBRARY_H
</span><span style=color:#b48ead;>#define </span><span>MYSHAREDLIB_LIBRARY_H
</span><span>
</span><span style=color:#65737e;>// 打印 Hello World!
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>hello</span><span>();
</span><span>
</span><span style=color:#65737e;>// 使用可变模版参数求和
</span><span style=color:#b48ead;>template </span><span><</span><span style=color:#b48ead;>typename</span><span> T>
</span><span>T </span><span style=color:#8fa1b3;>sum</span><span>(T </span><span style=color:#bf616a;>t</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>return</span><span> t;
</span><span>}
</span><span style=color:#b48ead;>template </span><span><</span><span style=color:#b48ead;>typename</span><span> T, </span><span style=color:#b48ead;>typename </span><span>...Types>
</span><span>T </span><span style=color:#8fa1b3;>sum</span><span>(T </span><span style=color:#bf616a;>first</span><span>, Types ... </span><span style=color:#bf616a;>rest</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>return</span><span> first + </span><span style=color:#bf616a;>sum</span><span>&LTT>(rest...);
</span><span>}
</span><span>
</span><span style=color:#b48ead;>#endif
</span></code></pre><p>library.cpp<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>#include </span><span>"</span><span style=color:#a3be8c;>library.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>hello</span><span>() {
</span><span>    std::cout << "</span><span style=color:#a3be8c;>Hello, World!</span><span>" << std::endl;
</span><span>}
</span></code></pre><h4 id=so-gong-xiang-ku-de-shi-yong-bei-ke-zhi-xing-xiang-mu-diao-yong>so 共享库的使用（被可执行项目调用）</h4><p>使用 CLion 调用共享库<p>创建一个名为 TestSharedLib 的可执行项目<p>CMakeLists.txt<pre class=language-cmake data-lang=cmake style=background-color:#2b303b;color:#c0c5ce;><code class=language-cmake data-lang=cmake><span style=color:#96b5b4;>cmake_minimum_required</span><span>(</span><span style=color:#bf616a;>VERSION </span><span>3.10)
</span><span style=color:#96b5b4;>project</span><span>(TestSharedLib)
</span><span>
</span><span style=color:#65737e;># C++11 编译
</span><span style=color:#96b5b4;>set</span><span>(</span><span style=color:#bf616a;>CMAKE_CXX_STANDARD </span><span>11)
</span><span>
</span><span style=color:#65737e;># 头文件路径
</span><span style=color:#96b5b4;>set</span><span>(</span><span style=color:#bf616a;>INC_DIR </span><span>/home/xx/code/clion/MySharedLib)
</span><span style=color:#65737e;># 库文件路径
</span><span style=color:#96b5b4;>set</span><span>(</span><span style=color:#bf616a;>LIB_DIR </span><span>/home/xx/code/clion/MySharedLib/cmake-build-debug)
</span><span>
</span><span style=color:#96b5b4;>include_directories</span><span>(${</span><span style=color:#bf616a;>INC_DIR</span><span>})
</span><span style=color:#96b5b4;>link_directories</span><span>(${</span><span style=color:#bf616a;>LIB_DIR</span><span>})
</span><span style=color:#96b5b4;>link_libraries</span><span>(MySharedLib)
</span><span>
</span><span style=color:#96b5b4;>add_executable</span><span>(TestSharedLib main.cpp)
</span><span>
</span><span style=color:#65737e;># 链接 MySharedLib 库
</span><span style=color:#96b5b4;>target_link_libraries</span><span>(TestSharedLib MySharedLib)
</span></code></pre><p>main.cpp<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>#include </span><span>"</span><span style=color:#a3be8c;>library.h</span><span>"
</span><span style=color:#b48ead;>using</span><span> std::cout;
</span><span style=color:#b48ead;>using</span><span> std::endl;
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>() {
</span><span>
</span><span>    </span><span style=color:#bf616a;>hello</span><span>();
</span><span>    cout << "</span><span style=color:#a3be8c;>1 + 2 = </span><span>" << </span><span style=color:#bf616a;>sum</span><span>(</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>) << endl;
</span><span>    cout << "</span><span style=color:#a3be8c;>1 + 2 + 3 = </span><span>" << </span><span style=color:#bf616a;>sum</span><span>(</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>3</span><span>) << endl;
</span><span>
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><p>执行结果<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>Hello, World!
</span><span>1 + 2 = 3
</span><span>1 + 2 + 3 = 6
</span></code></pre><h3 id=yun-xing-shi-ku-runtime-library>运行时库（Runtime Library）</h3><h4 id=dian-xing-cheng-xu-yun-xing-bu-zou>典型程序运行步骤</h4><ol><li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）<li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。<li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。<li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</ol><blockquote><p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</blockquote><h4 id=glibc-ru-kou>glibc 入口</h4><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>_start -> __libc_start_main -> exit -> _exit
</span></code></pre><p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。<h4 id=msvc-crt-ru-kou>MSVC CRT 入口</h4><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>int mainCRTStartup(void)
</span></code></pre><p>执行如下操作：<ol><li>初始化和 OS 版本有关的全局变量。<li>初始化堆。<li>初始化 I/O。<li>获取命令行参数和环境变量。<li>初始化 C 库的一些数据。<li>调用 main 并记录返回值。<li>检查错误并将 main 的返回值返回。</ol><h4 id=c-yu-yan-yun-xing-ku-crt>C 语言运行库（CRT）</h4><p>大致包含如下功能：<ul><li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。<li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。<li>I/O：I/O 功能的封装和实现。<li>堆：堆的封装和实现。<li>语言实现：语言中一些特殊功能的实现。<li>调试：实现调试功能的代码。</ul><h4 id=cyu-yan-biao-zhun-ku-ansi-c>C语言标准库（ANSI C）</h4><p>包含：<ul><li>标准输入输出（stdio.h）<li>文件操作（stdio.h）<li>字符操作（ctype.h）<li>字符串操作（string.h）<li>数学函数（math.h）<li>资源管理（stdlib.h）<li>格式转换（stdlib.h）<li>时间/日期（time.h）<li>断言（assert.h）<li>各种类型上的常数（limits.h & float.h）<li>变长参数（stdarg.h）<li>非局部跳转（setjmp.h）</ul><h2 id=c-c-fa-zhan-fang-xiang>C/C++发展方向</h2><blockquote><p>C/C++ 发展方向甚广，包括不限于以下方向， 以下列举一些大厂校招岗位要求。</blockquote><h3 id=hou-tai-fu-wu-qi>后台/服务器</h3><p>【后台开发】<ul><li>编程基本功扎实，掌握 C/C++/JAVA 等开发语言、常用算法和数据结构；<li>熟悉 TCP/UDP 网络协议及相关编程、进程间通讯编程；<li>了解 Python、Shell、Perl 等脚本语言；<li>了解 MYSQL 及 SQL 语言、编程，了解 NoSQL, key-value 存储原理；<li>全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识；<li>了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。</ul><h3 id=zhuo-mian-ke-hu-duan>桌面客户端</h3><p>【PC 客户端开发】<ul><li>计算机软件相关专业本科或以上学历，热爱编程，基础扎实，理解算法和数据结构相关知识；<li>熟悉 windows 操作系统的内存管理、文件系统、进程线程调度；<li>熟悉 MFC/windows 界面实现机制，熟练使用 VC，精通 C/C++，熟练使用 STL，以及 Windows 下网络编程经验；<li>熟练掌握 Windows 客户端开发、调试，有 Windows 应用软件开发经验优先；<li>对于创新及解决具有挑战性的问题充满激情，具有良好的算法基础及系统分析能力。</ul><h3 id=tu-xing-xue-you-xi-vr-ar>图形学/游戏/VR/AR</h3><p>【游戏客户端开发】<ul><li>计算机科学/工程相关专业本科或以上学历，热爱编程，基础扎实，理解算法、数据结构、软件设计相关知识；<li>至少掌握一种游戏开发常用的编程语言，具 C++/C# 编程经验优先；<li>具游戏引擎（如 Unity、Unreal）使用经验者优先；<li>了解某方面的游戏客户端技术（如图形、音频、动画、物理、人工智能、网络同步）者优先考虑；<li>对于创新及解决具有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力，具备良好的团队合作意识；<li>具阅读英文技术文档能力；<li>热爱游戏。</ul><h3 id=ce-shi-kai-fa>测试开发</h3><p>【测试开发】<ul><li>计算机或相关专业本科及以上学历；<li>一至两年的 C/C++/Python 或其他计算机语言的编程经验；<li>具备撰写测试计划、测试用例、以及实现性能和安全等测试的能力；<li>具备实现自动化系统的能力；<li>具备定位调查产品缺陷能力、以及代码级别调试缺陷的能力；<li>工作主动积极，有责任心，具有良好的团队合作精神。</ul><h3 id=wang-luo-an-quan-ni-xiang>网络安全/逆向</h3><p>【安全技术】<ul><li>热爱互联网，对操作系统和网络安全有狂热的追求，专业不限；<li>熟悉漏洞挖掘、网络安全攻防技术，了解常见黑客攻击手法；<li>掌握基本开发能力，熟练使用 C/C++ 语言；<li>对数据库、操作系统、网络原理有较好掌握；<li>具有软件逆向，网络安全攻防或安全系统开发经验者优先。</ul><h3 id=qian-ru-shi-wu-lian-wang>嵌入式/物联网</h3><p>【嵌入式应用开发】<ul><li>有良好的编程基础，熟练掌握 C/C++ 语言；<li>掌握操作系统、数据结构等软件开发必备知识；<li>具备较强的沟通理解能力及良好的团队合作意识；<li>有 Linux/Android 系统平台的开发经验者优先。</ul><h3 id=yin-shi-pin-liu-mei-ti-sdk>音视频/流媒体/SDK</h3><p>【音视频编解码】<ol><li>硕士及以上学历，计算机、信号处理、数学、信息类及相关专业和方向；<li>视频编解码基础扎实，熟常用的 HEVC 或 H264，有较好的数字信号处理基础；<li>掌握 C/C++，代码能力强, 熟悉一种汇编语言尤佳；<li>较强的英文文献阅读能力；<li>学习能力强，具有团队协作精神，有较强的抗压能力。</ol><h3 id=ji-suan-ji-shi-jue-ji-qi-xue-xi>计算机视觉/机器学习</h3><p>【计算机视觉研究】<ul><li>计算机、应用数学、模式识别、人工智能、自控、统计学、运筹学、生物信息、物理学/量子计算、神经科学、社会学/心理学等专业，图像处理、模式识别、机器学习相关研究方向，本科及以上，博士优先；<li>熟练掌握计算机视觉和图像处理相关的基本算法及应用；<li>较强的算法实现能力，熟练掌握 C/C++ 编程，熟悉 Shell/Python/Matlab 至少一种编程语言；<li>在计算机视觉、模式识别等学术会议或者期刊上发表论文、相关国际比赛获奖、及有相关专利者优先。</ul></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>