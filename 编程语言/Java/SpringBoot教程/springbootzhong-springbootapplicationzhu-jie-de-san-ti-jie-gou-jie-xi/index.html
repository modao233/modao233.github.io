<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/编程语言/Java/SpringBoot教程/springbootzhong-springbootapplicationzhu-jie-de-san-ti-jie-gou-jie-xi/>SpringBoot中@SpringBootApplication注解的三体结构解析</a></h1><div class=post-meta-inline><span class=post-date> 2021-01-13 </span></div><div class=post-content><p>原文：http://c.biancheng.net/view/4625.html<p>@SpringBootApplication 是一个“三体”结构，实际上它是一个复合 Annotation：<pre class=language-java data-lang=java style=background-color:#2b303b;color:#c0c5ce;><code class=language-java data-lang=java><span>@</span><span style=color:#bf616a;>Target</span><span>(</span><span style=color:#ebcb8b;>ElementType</span><span>.</span><span style=color:#d08770;>TYPE</span><span>)</span><span>
</span><span>@</span><span style=color:#bf616a;>Retention</span><span>(</span><span style=color:#ebcb8b;>RetentionPolicy</span><span>.</span><span style=color:#d08770;>RUNTIME</span><span>)</span><span>
</span><span>@</span><span style=color:#bf616a;>Documented</span><span>
</span><span>@</span><span style=color:#bf616a;>Inherited</span><span>
</span><span>@</span><span style=color:#bf616a;>Configuration</span><span>
</span><span>@</span><span style=color:#bf616a;>EnableAutoConfiguration</span><span>
</span><span>@</span><span style=color:#bf616a;>ComponentScanpublic</span><span>
</span><span style=color:#b48ead;>@interface</span><span style=color:#eff1f5;>
</span><span style=color:#ebcb8b;>SpringBootApplication</span><span style=color:#eff1f5;>{...}</span><span>
</span></code></pre><p>虽然它的定义使用了多个 Annotation 进行元信息标注，但实际上对于 SpringBoot 应用来说，重要的只有三个 Annotation，而“三体”结构实际上指的就是这三个 Annotation：<ul><li>@Configuration<li>@EnableAutoConfiguration<li>@ComponentScan</ul><p>所以，如果我们使用如下的 SpringBoot 启动类，整个 SpringBoot 应用依然可以与之前的启动类功能对等：<pre class=language-java data-lang=java style=background-color:#2b303b;color:#c0c5ce;><code class=language-java data-lang=java><span>@</span><span style=color:#bf616a;>Configuration</span><span>
</span><span>@</span><span style=color:#bf616a;>EnableAutoConfiguration</span><span>
</span><span>@</span><span style=color:#bf616a;>ComponentScanpublic</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>DemoApplication </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>public static void </span><span style=color:#8fa1b3;>main</span><span style=color:#eff1f5;>(</span><span style=color:#ebcb8b;>String</span><span style=color:#b48ead;>[] </span><span style=color:#bf616a;>args</span><span style=color:#eff1f5;>) {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>        </span><span style=color:#ebcb8b;>SpringApplication</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>run</span><span style=color:#eff1f5;>(</span><span style=color:#ebcb8b;>DemoApplication</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>class</span><span style=color:#eff1f5;>, args);</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    }</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>
</span></code></pre><p>但每次都写三个 Annotation 显然过于繁琐，所以写一个 @SpringBootApplication 这样的一站式复合 Annotation 显然更方便些。<h2 id=configuration-chuang-shi-ji>Configuration 创世纪</h2><p>这里的 @Configuration 对我们来说并不陌生，它就是 JavaConfig 形式的 Spring IoC 容器的配置类使用的那个 @Configuration，既然 SpringBoot 应用骨子里就是一个 Spring 应用，那么，自然也需要加载某个 IoC 容器的配置，而 SpringBoot 社区推荐使用基于 JavaConfig 的配置形式，所以，很明显，这里的启动类标注了 @Configuration 之后，本身其实也是一个 IoC 容器的配置类！<p>很多 SpringBoot 的代码示例都喜欢在启动类上直接标注 @Configuration 或者 @SpringBootApplication，对于初接触 SpringBoot 的开发者来说，其实这种做法不便于理解，如果我们将上面的 SpringBoot 启动类拆分为两个独立的 Java 类，整个形势就明朗了：<pre class=language-java data-lang=java style=background-color:#2b303b;color:#c0c5ce;><code class=language-java data-lang=java><span>@</span><span style=color:#bf616a;>Configuration</span><span>
</span><span>@</span><span style=color:#bf616a;>EnableAutoConfiguration</span><span>
</span><span>@</span><span style=color:#bf616a;>ComponentScan</span><span>
</span><span style=color:#b48ead;>public class </span><span style=color:#ebcb8b;>DemoConfiguration </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    @</span><span style=color:#bf616a;>Bean</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>public </span><span style=color:#ebcb8b;>Controller </span><span style=color:#8fa1b3;>controller</span><span style=color:#eff1f5;>() {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>        </span><span style=color:#b48ead;>return new </span><span style=color:#ebcb8b;>Controller</span><span style=color:#eff1f5;>();</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    }</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>
</span></code></pre><pre class=language-java data-lang=java style=background-color:#2b303b;color:#c0c5ce;><code class=language-java data-lang=java><span style=color:#b48ead;>public class </span><span style=color:#ebcb8b;>DemoApplication </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>public static void </span><span style=color:#8fa1b3;>main</span><span style=color:#eff1f5;>(</span><span style=color:#ebcb8b;>String</span><span style=color:#b48ead;>[] </span><span style=color:#bf616a;>args</span><span style=color:#eff1f5;>) {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>        </span><span style=color:#ebcb8b;>SpringApplication</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>run</span><span style=color:#eff1f5;>(</span><span style=color:#ebcb8b;>DemoConfiguration</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>class</span><span style=color:#eff1f5;>, args);</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    }</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>
</span></code></pre><p>所以，启动类 DemoApplication 其实就是一个标准的 Standalone 类型 Java 程序的 main 函数启动类，没有什么特殊的。而 @Configuration 标注的 DemoConfiguration 定义其实也是一个普通的 JavaConfig 形式的 IoC 容器配置类。<h2 id=enableautoconfiguration-de-gong-xiao>@EnableAutoConfiguration 的功效</h2><p>@EnableAutoConfiguration 其实也没啥“创意”，各位是否还记得 Spring 框架提供的各种名字为 @Enable 开头的 Annotation 定义？<p>比如 @EnableScheduling、@EnableCaching、@EnableMBeanExport 等，@EnableAutoConfiguration 的理念和“做事方式”其实一脉相承，简单概括一下就是，借助 @Import 的支持，收集和注册特定场景相关的 bean 定义：<ul><li>@EnableScheduling 是通过 @Import 将 Spring 调度框架相关的 bean 定义都加载到 IoC 容器。<li>@EnableMBeanExport 是通过 @Import 将 JMX 相关的 bean 定义加载到 IoC 容器。<li>而 @EnableAutoConfiguration 也是借助 @Import 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器，仅此而已！</ul><p>@EnableAutoConfiguration 作为一个复合 Annotation，其自身定义关键信息如下：<pre class=language-java data-lang=java style=background-color:#2b303b;color:#c0c5ce;><code class=language-java data-lang=java><span>@</span><span style=color:#bf616a;>Target</span><span>(</span><span style=color:#ebcb8b;>ElementType</span><span>.</span><span style=color:#d08770;>TYPE</span><span>)</span><span>
</span><span>@</span><span style=color:#bf616a;>Retention</span><span>(</span><span style=color:#ebcb8b;>RetentionPolicy</span><span>.</span><span style=color:#d08770;>RUNTIME</span><span>)</span><span>
</span><span>@</span><span style=color:#bf616a;>Documented</span><span>
</span><span>@</span><span style=color:#bf616a;>Inherited</span><span>
</span><span>@</span><span style=color:#bf616a;>AutoConfigurationPackage</span><span>
</span><span>@</span><span style=color:#bf616a;>Import</span><span>(</span><span style=color:#ebcb8b;>EnableAutoConfigurationImportSelector</span><span>.</span><span style=color:#bf616a;>class</span><span>)</span><span>
</span><span style=color:#b48ead;>public @interface </span><span style=color:#ebcb8b;>EnableAutoConfiguration </span><span style=color:#eff1f5;>{...}</span><span>
</span></code></pre><p>其中，最关键的要属 @Import（EnableAutoConfigurationImportSelector.class），借助 EnableAutoConfigurationImportSelector，@EnableAutoConfiguration 可以帮助 SpringBoot 应用将所有符合条件的 @Configuration 配置都加载到当前 SpringBoot 创建并使用的 IoC 容器，就跟一只“八爪鱼”一样<p><img alt=EnableAutoConfiguration得以生效的关键组件关系图 src=SpringBoot%E4%B8%AD@SpringBootApplication%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E4%BD%93%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/5-1ZI1093132I5.png><p>借助于 Spring 框架原有的一个工具类：SpringFactoriesLoader 的支持，@EnableAutoConfiguration 可以“智能”地自动配置功效才得以大功告成！<h2 id=springfactoriesloaderxiang-jie>SpringFactoriesLoader详解</h2><p>SpringFactoriesLoader 属于 Spring 框架私有的一种扩展方案（类似于 Java 的 SPI 方案 java.util.ServiceLoader），其主要功能就是从指定的配置文件 META-INF/spring.factories 加载配置，spring.factories 是一个典型的 java properties 文件，配置的格式为 Key=Value 形式，只不过 Key 和 Value 都是 Java 类型的完整类名（Fully qualified name），比如：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>example.MyService=example.MyServiceImpl1,example.MyServiceImpl2 </span><span>
</span></code></pre><p>然后框架就可以根据某个类型作为 Key 来查找对应的类型名称列表了：<pre class=language-java data-lang=java style=background-color:#2b303b;color:#c0c5ce;><code class=language-java data-lang=java><span style=color:#b48ead;>public abstract class </span><span style=color:#ebcb8b;>SpringFactoriesLoader </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#65737e;>// ...</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>public static </span><span style=color:#eff1f5;><</span><span style=color:#bf616a;>T</span><span style=color:#eff1f5;>> </span><span style=color:#ebcb8b;>List</span><span style=color:#eff1f5;><</span><span style=color:#ebcb8b;>T</span><span style=color:#eff1f5;>> </span><span style=color:#8fa1b3;>loadFactories</span><span style=color:#eff1f5;>(</span><span style=color:#ebcb8b;>Class</span><span style=color:#eff1f5;><</span><span style=color:#ebcb8b;>T</span><span style=color:#eff1f5;>> </span><span style=color:#bf616a;>factoryClass</span><span style=color:#eff1f5;>, </span><span style=color:#ebcb8b;>ClassLoader </span><span style=color:#bf616a;>classLoader</span><span style=color:#eff1f5;>) {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>        ...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    }</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>public static </span><span style=color:#ebcb8b;>List</span><span style=color:#eff1f5;><</span><span style=color:#ebcb8b;>String</span><span style=color:#eff1f5;>> </span><span style=color:#8fa1b3;>loadFactoryNames</span><span style=color:#eff1f5;>(</span><span style=color:#ebcb8b;>Class</span><span style=color:#eff1f5;><</span><span>?</span><span style=color:#eff1f5;>> </span><span style=color:#bf616a;>factoryClass</span><span style=color:#eff1f5;>, </span><span style=color:#ebcb8b;>ClassLoader </span><span style=color:#bf616a;>classLoader</span><span style=color:#eff1f5;>) {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>        ...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    }</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#65737e;>// ...</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>}</span><span>
</span></code></pre><p>对于 @EnableAutoConfiguration 来说，SpringFactoriesLoader 的用途稍微不同一些，其本意是为了提供 SPI 扩展的场景，而在 @EnableAutoConfiguration 的场景中，它更多是提供了一种配置查找的功能支持，即根据 @EnableAutoConfiguration 的完整类名 org.springframework.boot.autoconfigure.EnableAutoConfiguration 作为查找的 Key，获取对应的一组 @Configuration 类：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>org.springframework.boot.autoconfigure.EnableAutoConfiguration=</span><span>
</span><span>\org.springframework.boot.autoconfigure.admin.SpringApplicationAdmin- JmxAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.PropertyPlaceholderAuto- Configuration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.cassandra.CassandraAuto-Configuration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.context.ConfigurationProperties-AutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.dao.PersistenceException-TranslationAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.data.cassandra.Cassandra-DataAutoConfiguration,</span><span>
</span><span>\org.springframework.boot.autoconfigure.data.cassandra.Cassandra-RepositoriesAutoConfiguration,</span><span>
</span><span>\...</span><span>
</span></code></pre><p>以上是从 SpringBoot 的 autoconfigure 依赖包中的 META-INF/spring.factories 配置文件中摘录的一段内容，可以很好地说明问题。<p>所以，@EnableAutoConfiguration 自动配置的魔法其实就变成了：从 classpath 中搜寻所有 META-INF/spring.factories 配置文件，并将其中 org.spring-framework.boot.autoconfigure.EnableAutoConfiguration 对应的配置项通过反射（Java Reflection）实例化为对应的标注了 @Configuration 的 JavaConfig 形式的 IoC 容器配置类，然后汇总为一个并加载到 IoC 容器。<h2 id=ke-you-ke-wu-de-componentscan>可有可无的@ComponentScan</h2><p>为啥说 @ComponentScan 是可有可无的？<p>因为原则上来说，作为 Spring 框架里的“老一辈革命家”，@ComponentScan 的功能其实就是自动扫描并加载符合条件的组件或 bean 定义，最终将这些 bean 定义加载到容器中。加载 bean 定义到 Spring 的 IoC 容器，我们可以手工单个注册，不一定非要通过批量的自动扫描完成，所以说 @ComponentScan 是可有可无的。<p>对于 SpringBoot 应用来说，同样如此，比如我们本章的启动类：<pre class=language-java data-lang=java style=background-color:#2b303b;color:#c0c5ce;><code class=language-java data-lang=java><span>@</span><span style=color:#bf616a;>Configuration</span><span>
</span><span>@</span><span style=color:#bf616a;>EnableAutoConfiguration</span><span>
</span><span>@</span><span style=color:#bf616a;>ComponentScanpublic</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>DemoApplication </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>public static void </span><span style=color:#8fa1b3;>main</span><span style=color:#eff1f5;>(</span><span style=color:#ebcb8b;>String</span><span style=color:#b48ead;>[] </span><span style=color:#bf616a;>args</span><span style=color:#eff1f5;>) {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>        </span><span style=color:#ebcb8b;>SpringApplication</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>run</span><span style=color:#eff1f5;>(</span><span style=color:#ebcb8b;>DemoApplication</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>class</span><span style=color:#eff1f5;>, args);</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    }</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>
</span></code></pre><p>如果我们当前应用没有任何 bean 定义需要通过 @ComponentScan 加载到当前 SpringBoot 应用对应使用的 IoC 容器，那么，除去 @ComponentScan 的声明，当前 SpringBoot 应用依然可以照常运行，功能对等。</div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>