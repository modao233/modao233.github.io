<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/CppPrimer/cppprimer-di-4zhang/">C++ Primer 第4章 表达式</a></h1><div class=post-meta-inline><span class=post-date> 2018-06-13 </span></div><div class=post-content><p>C++ Primer 第4章 表达式<h2 id=4-1-ji-chu>4.1 基础</h2><h3 id=4-1-1-ji-ben-gai-nian>4.1.1 基本概念</h3><p>C++定义了运算符：<ul><li>一元运算符：作用于一个运算对象的运算符，如取地址符（&）和解引用符（*）<li>二元运算符：作用于两个运算对象的运算符，如相等运算符（==）和乘法运算符（*）<li>三元运算符：三目运算符<li>函数调用也是一种特殊的运算符，对运算对象没有限制</ul><p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用域类类型的运算对象时，可以重载运算符。我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由运算符定义的，但是，运算对象的个数、运算符的优先级和结合律都是无法改变的。<p><strong>C++的表达式要不然是右值，要不然就是左值</strong>：<ul><li>在C语言里：左值可以位于赋值语句的左侧，右值则不能<li>在C++语言里： <ul><li>当一个对象被用作右值的时候，用的是对象的值（内存）<li>当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</ul></ul><p>不同运算符对运算对象的要求各不相同，有的需要左值运算对象，有的需要右值运算对象。返回值也有差异，有的得到左值结果，有的得到右值结果。<p>左值可以当右值使用，这时候使用的是它的内容（值）；但是不能把右值当成左值（也就是位置）使用。<p>需要用的左值的常见的运算符：<ul><li>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值<li>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值<li>内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符，它们的求值结果都是左值<li>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值</ul><p>使用关键字decltype的时候，左值和右值有所不同：如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型：<ul><li>如果p是int *，则decltype(p)的结果是int&<li>取地址运算符生成右值，则decltype(&p)的结果是int **，也就是说，结果是一个指向整型指针的指针</ul><h3 id=4-1-2-you-xian-ji-yu-jie-he-lu>4.1.2 优先级与结合律</h3><p><strong>复合表达式</strong>是指含有两个或多个运算符的表达式。一般来说，表达式的值依赖于表达式的组合方式：<ul><li>高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密地组合在一起<li>优先级相同，则其组合规则由结合律确定 <ul><li>算术运算符满足左结合律，即从左向右的顺序组合运算对象</ul><li>括号无视优先级和结合律</ul><p>优先级与结合律的影响：<ul><li>优先级会影响程序的正确性<li>结合律对表达式产生影响的一个典型示例是输入输出运算</ul><h3 id=4-1-3-qiu-zhi-shun-xu>4.1.3 求值顺序</h3><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，在大多数情况不会指定求值的顺序。<p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>int i = 0;
</span><span>cout << i << " " << ++i << endl;	//未定义的，表达式行为不可预知
</span></code></pre><p>有四种运算符明确规定了运算对象的求值顺序：<ol><li>逻辑与（&&）运算符：先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值<li>逻辑或（||）运算符<li>条件（? : ）运算符<li>逗号运（, ）算符</ol><p>运算对象的求值顺序与优先级和结合律无关。<p><strong>建议：处理复合表达式：</strong>：<ol><li>拿不准的时候最好用括号来强制让表达式的组合关系符合程序的逻辑要求<li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。当改变运算对象的子表达式本身就是另一个子表达式的运算对象时该规则无效：*++iter。</ol><h2 id=4-2-suan-zhu-yun-suan-fu>4.2 算术运算符</h2><table><thead><tr><th>算术运算符（左结合律）<th>功能<th>用法<tbody><tr><td>+<td>一元正号<td>+ expr<tr><td>-<td>一元负号<td>- expr<tr><td><td><td><tr><td>*<td>乘法<td>expr * expr<tr><td>/<td>除法<td>expr / expr<tr><td>%<td>求余<td>expr % expr<tr><td><td><td><tr><td>+<td>加法<td>expr + expr<tr><td>-<td>减法<td>expr - expr</table><p>除非另作特殊说明，算术运算符都能用作与任意算术类型以及任意能转换为算术类型的类型。<p>算术运算符的运算对象和求值结果都是右值。<p>一元正号运算符、加法运算符和减法运算符都能作用于指针。当一元正号运算符作用于一个指针或算术值时，返回<strong>运算对象值</strong>的一个（提升后的）副本。一元负号运算符对运算对象值取负后，返回其（提升后的）副本：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>1024</span><span>;
</span><span style=color:#b48ead;>int</span><span> k = -i;		</span><span style=color:#65737e;>//k是-1024
</span><span style=color:#b48ead;>bool</span><span> b = </span><span style=color:#d08770;>true</span><span>;
</span><span style=color:#b48ead;>bool</span><span> b2 = -b;	</span><span style=color:#65737e;>//b2是true
</span><span style=color:#65737e;>//布尔值不应该参与运算，-b就是一个很好的例子。
</span></code></pre><p>算术表达式可能产生未定义的结果：<ul><li>一部分原因是数学性质本身：例如除数是0的情况<li>另一部分则源于计算机的特点：例如溢出，当计算的结果超过该类型所能表示的范围就会产生溢出</ul><p>C++语言早期版本允许结果为负值的商向上或向下取整，C++11新标准规定商一律向0取整（即直接切除小数部分）<p>根据取余运算的定义：如果m和n是整数且n非0，则表达式(m/n)*n + m%n 的求值结果与m相等。隐含的意义是，如果m%n不等于0，则它的符号和m相同。<p>C++新标准已经禁止m%n的符合匹配n的符号，除了-m导致溢出的特殊情况，其他时候：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>(-m)/n == m/(-n) == -(m/n);
</span><span>m%(-n) == m%n;
</span><span>(-m)%n == -(m%n);
</span></code></pre><h2 id=4-3-luo-ji-he-guan-xi-yun-suan-fu>4.3 逻辑和关系运算符</h2><p>关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型，它们的运算对象和求值结果都是右值。<p>逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象（算术类型或指针类型）表示假，否则表示真。<table><thead><tr><th>结合律<th>运算符<th>功能<th>用法<tbody><tr><td>右<td>!<td>逻辑非<td>!expr<tr><td><td><td><td><tr><td>左<td><<td>小于<td>expr < expr<tr><td>左<td><=<td>小于等于<td>expr <= expr<tr><td>左<td>><td>大于<td>expr > expr<tr><td>左<td>>=<td>大于等于<td>expr >= expr<tr><td><td><td><td><tr><td>左<td>==<td>相等<td>expr == expr<tr><td>左<td>!=<td>不相等<td>expr != expr<tr><td><td><td><td><tr><td>左<td>&&<td>逻辑与<td>expr && expr<tr><td><td><td><td><tr><td>左<td>||<td>逻辑或<td>expr || expr</table><p>逻辑与和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时，才会计算右侧运算对象的值。这种策略称为<strong>短路求值</strong>。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>if </span><span>(val) {</span><span style=color:#65737e;>/*...*/</span><span>}	</span><span style=color:#65737e;>//如果val是任意非0值，条件为真
</span><span style=color:#b48ead;>if </span><span>(!val) {</span><span style=color:#65737e;>/*...*/</span><span>}	</span><span style=color:#65737e;>//如果val为0，条件为真
</span><span style=color:#65737e;>//试图将以上写法写出下面形式：
</span><span style=color:#b48ead;>if </span><span>(val == </span><span style=color:#d08770;>true</span><span>) {</span><span style=color:#65737e;>/*...*/</span><span>}	</span><span style=color:#65737e;>//只有当val等于1时条件才为真
</span></code></pre><p>这种改写与之前代码相比：<ul><li>写法较长而且不太直接<li>如果val不是布尔值，这样的比较就失去了原来的意义，true会被转换成val的类型</ul><p><strong>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象</strong><h2 id=4-4-fu-zhi-yun-suan-fu>4.4 赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值，赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型是左侧运算符对象的类型。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。<p>C++11新标准允许使用花括号括起来的初始化列表作为赋值语句的右侧运算对象。<p>如果左侧运算对象是内置类型，那么初始化列表最多只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> k;
</span><span>k = {</span><span style=color:#d08770;>3.14</span><span>};	</span><span style=color:#65737e;>//错误：窄化转换
</span><span>vector<</span><span style=color:#b48ead;>int</span><span>> vi;
</span><span>vi = {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>3</span><span>,</span><span style=color:#d08770;>4</span><span>,</span><span style=color:#d08770;>5</span><span>,</span><span style=color:#d08770;>6</span><span>,</span><span style=color:#d08770;>7</span><span>,</span><span style=color:#d08770;>8</span><span>,</span><span style=color:#d08770;>9</span><span>};
</span></code></pre><p>无论左侧运算对象的类型是什么，初始值列表都可以为空，此时编译器创建一个值初始化的临时变量并将其赋给左侧运算对象。<p>赋值运算符满足<strong>右结合律</strong>，靠右的赋值运算作为靠左的赋值运算符的右侧运算对象。<p>因为赋值运算符的优先级低于关系运算符，所以在条件语句中，赋值部分通常应该加上括号。<h2 id=4-5-di-zeng-he-di-jian-yun-suan-fu>4.5 递增和递减运算符</h2><p>递增和递减有两种形式：（<strong>作用于左值运算对象</strong>）<ul><li>前置版本：将运算对象加1（或减1），然后将改变后的对象作为求值结果，将对象本身作为左值返回<li>后置版本：将运算对象加1（或减1），但是求值结果是运算对象改变之前那个值的副本，将对象原始值的副本作为右值返回</ul><p>除非必须，否则不用后置版本的递增递减运算符。<h2 id=4-6-cheng-yuan-fang-wen-yun-suan-fu>4.6 成员访问运算符</h2><p>点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类对象的一个成员，而箭头运算符与点运算符有关，表达式ptr->mem等价于(*ptr).mem。解引用运算符优先级低于点运算符。<p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。<p>点运算符：<ul><li>如果成员所属的对象是左值，那么结果是左值<li>如果成员所属的对象是右值，那么结果是右值</ul><h2 id=4-7-tiao-jian-yun-suan-fu>4.7 条件运算符</h2><p>条件运算符（ ? : ）允许我们把简单的if-else逻辑嵌入到单个表达式中，条件运算符使用形式：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>cond ? expr1 : expr2;
</span><span>//等价于
</span><span>if(cond)
</span><span>	return expr1;
</span><span>else
</span><span>	return expr2;
</span></code></pre><p>当条件运算符的两个表达式都是左值或者能够转换成同一种左值类型时，运算结果是左值；否则运算结果是右值。<p>条件运算符满足右结合律。条件运算符可以嵌套使用，也就是条件表达式可以作为另一个运算符的cond或expr。随着嵌套层数增加，代码的可读性急剧下降，因此最好不要超过两到三层。<p>条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算符子表达式时，通常需要在它两端加上括号：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>cout << ((grade < 60) ? "fail" : "pass");	//输出pass或者fail
</span><span>
</span><span>cout << (grade < 60) ? "fail" : "pass";		//输出1或者0
</span><span>//等价于：
</span><span>cout << (grade < 60);
</span><span>cout ? "fail" : "pass";
</span><span>
</span><span>cout << grade < 60 ? "fail" : "pass";		//错误：试图比较cout和60
</span><span>//等价于：
</span><span>cout << grade;
</span><span>cout < 60 ? "fail" : "pass";
</span></code></pre><h2 id=4-8-wei-yun-suan-fu-zuo-jie-he-lu>4.8 位运算符（左结合律）</h2><p>位运算符作用于整数类型的运算对象，并把运算对象看出是二进制位的集合。位运算符提供检查和设置二进制位的功能。<p>标准库类型bitset可以表示任意大小的二进制位集合，位运算符同样适用于bitset类型。<table><thead><tr><th>运算符<th>功能<th>用法<tbody><tr><td>~<td>位求反<td>~ expr<tr><td><<<td>左移<td>expr1 << expr2<tr><td>>><td>右移<td>expr1 >> expr2<tr><td>&<td>位与<td>expr & expr<tr><td>^<td>位异或<td>expr ^ expr<tr><td>|<td>位或<td>expr | expr</table><p>如果运算对象是“小整型”，则它的值会被自动提升成较大的整型。运算对象可以是带符号的，也可以是无符号的，如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且，此时的左移操作可能会改变符号位，因此是未定义的行为。<p>二进制位左移或者右移，移出边界之外的位数就被舍弃了。左移运算符（<<）在右侧插入值为0的二进制位；右移运算符的行为依赖于左侧运算对象的类型：<ul><li>如果运算对象是无符号类型，在左侧插入值为0的二进制位<li>如果运算对象是带符号类型，在左侧插入符号位的副本或者值为0的二进制位，如何选择要视具体环境而定</ul><p>移位运算符（又叫IO运算符）满足左结合律，尽管很多人没直接用过移位运算符，但是几乎都用过它们的重载版本来进行IO操作。<strong>重载运算符的优先级和结合律都与它的内置版本一样</strong>。<p>移位运算符的优先级不高不低，介于中间：<ul><li>比算术运算符的优先级低<li>比关系运算符、赋值运算符和条件运算符优先级高</ul><h2 id=4-9-sizeofyun-suan-fu>4.9 sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式。<p>运算符的运算对象有两种形式：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>sizeof (type)
</span><span>sizeof expr		</span><span style=color:#65737e;>//返回表达式结果类型的大小
</span></code></pre><p>sizeof并不实际计算运算对象的值，所以在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际上并没有被使用，sizeof不需要真正的解引用指针也能知道它所指对象的类型。<p>C++11新标准允许我们使用作用域运算符来获取类成员的大小，通常情况只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。<p>sizeof运算符的结果部分地依赖于其作用的类型：<ul><li>对char或者类型为char的表达式执行sizeof运算，结果得1<li>对引用类型执行sizeof运算得到被引用对象所占的空间大小<li>对指针指向sizeof运算得到指针本身所占空间的大小<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间大小，指针不需要有效<li>对数组执行sizeof运算得到整个数组所占空间的大小，<strong>sizeof运算不会把数组转换成指针来处理</strong>，数组大小除以单个元素的大小可以得到数组元素的个数<li>对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素占用了多少空间</ul><p>因为sizeof的返回值是一个常量表达式，所以可以用其结果声明数组维度。<h2 id=4-10-dou-hao-yun-suan-fu>4.10 逗号运算符</h2><p>逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。逗号运算符先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值，如果右侧运算对象是左值，那么求值结果也是左值。<h2 id=4-11-lei-xing-zhuan-huan>4.11 类型转换</h2><p>在C++语言中，某些类型之间有关联。如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代。<strong>如果两种类型能够相互转换，它们就是关联的</strong>。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> ival = </span><span style=color:#d08770;>3.541 </span><span>+ </span><span style=color:#d08770;>3</span><span>;	</span><span style=color:#65737e;>//存在隐式转换
</span></code></pre><p><strong>算术类型之间的隐式转换被设计成尽可能避免损失精度</strong>：<p>3被隐式转换成double型，然后执行加法运算，计算结果是double型，初始化过程中，初始化对象类型无法改变，则计算结果由double型转换成int型，忽略了小数部分。<p>何时发生隐式类型转换：<ul><li>在大多数表达式中，比int类型小的整数型值首先提升为较大的整数类型<li>在条件中，非布尔值转换成布尔类型<li>初始化过程中，初始值转换成变量的类型：在赋值语句中，右侧运算对象转换成左侧运算对学校的类型<li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型<li>函数调用也会发生类型转换</ul><h3 id=4-11-1-suan-zhu-zhuan-huan>4.11.1 算术转换</h3><p><strong>整型提升</strong>负责把小整数类型转换成较大的整数类型。转换后的类型要能容纳原类型所有可能的值。<p>如果一个运算对象是无符号类型，另一个运算对象是带符号类型：<ul><li>无符号类型不小于带符号类型（存储空间大小），那么带符号类型的运算对象转换成无符号的，例如：unsigned int和int，则int类型的运算对象转换成unsigned int<li>带符号类型大于无符号类型，转换依赖于机器： <ul><li>如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型，例如long和unsigned int，并且int和long大小相同，则long类型运算对象转换成unsigned int<li>如果不能，则带符号类型的运算对象转换成无符号类型，即long类型占用的空间比int更多，则unsigned int类型的运算对象转换成long类型</ul></ul><h3 id=4-11-2-qi-ta-yin-shi-lei-xing-zhuan-huan>4.11.2 其他隐式类型转换</h3><p><strong>数组转换成指针</strong>：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。当数组被用作decltype关键字的参数、作为取地址符（&）、sizeof以及typeid等运算符的运算对象时，转换不发生。<p><strong>指针的转换</strong>：常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void*。<p><strong>转换成布尔类型</strong>：存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值是0，转换结果是false，否则转换结果是true。<p><strong>转换成常量</strong>：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在。<p><strong>类类型定义的转换</strong>：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类型的转换。<h3 id=4-11-3-xian-shi-zhuan-huan>4.11.3 显示转换</h3><p><strong>强制类型转换(cast)</strong>：显示的将对象强制转换成另外一种类型。<p><strong>命名的强制类型转换</strong>的形式为：<em>cast-name<type>(expression)<em>，其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name有四种：<p><ol><li><p><strong>static_cast</strong>：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。可以用static_cast把一个较大的算术类型赋值给较小的类型，还可以将void*指针强制转换回原来的类型。</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> j = </span><span style=color:#d08770;>1</span><span>;
</span><span style=color:#b48ead;>double</span><span> slope = static_cast<</span><span style=color:#b48ead;>double</span><span>>(j);
</span><span>
</span><span style=color:#b48ead;>void </span><span>*p = &d;
</span><span style=color:#b48ead;>double </span><span>*dp = static_cast<</span><span style=color:#b48ead;>double</span><span>*>(p);
</span></code></pre><li><p><strong>const_cast</strong>：只能改变运算对象的底层const。如果对象本身不是一个常量，使用强制转换获得写权限是合法的行为。</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const char </span><span>*pc;
</span><span style=color:#b48ead;>char </span><span>*p = const_cast<</span><span style=color:#b48ead;>char</span><span>*>(pc);
</span></code></pre> <p>只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样，也不能使用const_cast改变表达式的类型：</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const char </span><span>*cp;
</span><span style=color:#b48ead;>char </span><span>*q = static_cast<</span><span style=color:#b48ead;>char</span><span>*>(cp);	</span><span style=color:#65737e;>//错误，不能用static_cast转换掉const性质
</span><span>static_cast&LTstring>(cp);		</span><span style=color:#65737e;>//正确：字符串字面值转换成string类型
</span><span>const_cast&LTstring>(cp);			</span><span style=color:#65737e;>//错误：const_cast只改变常量属性
</span></code></pre> <p>const_cast常常用于函数重载的上下文。</p><li><p><strong>reinterpret_cast</strong>：通常为运算对象的位模式提供较低层次上的重新解释。</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int </span><span>*ip;
</span><span style=color:#b48ead;>char </span><span>*pc = reinterpret_cast<</span><span style=color:#b48ead;>char</span><span>*>(ip);
</span><span>string </span><span style=color:#8fa1b3;>str</span><span>(</span><span style=color:#bf616a;>pc</span><span>);	</span><span style=color:#65737e;>//可能导致异常的运行时行为
</span></code></pre> <p>pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在<strong>运行时</strong>发生错误。使用reinterpret_cast是非常危险的，其本质上依赖于机器，必须对涉及的类型和编译器实习转换的过程都非常了解，才能安全地使用reinterpret_cast。</p><li><p><strong>dynamic_cast</strong></p></ol> <p>应该尽量避免强制类型转换！</p> <p><strong>旧式的强制类型转换</strong>：在早期版本的C++语言中，显示地进行强制类型转换包含两种形式</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#bf616a;>type</span><span>(expr);			</span><span style=color:#65737e;>//函数形式的强制类型转换
</span><span>(type)expr;			</span><span style=color:#65737e;>//C语言风格的强制类型转换
</span></code></pre> <p>根据所涉及的类型不同，旧式的强制类型转换分节具有与const_cast、static_cast或reinterpret_cast相似的行为。</p> <p>与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。</p> <h2 id=4-12-yun-suan-fu-you-xian-ji-biao>4.12 运算符优先级表</h2> <p><img alt=image-20200613141520895 src=image-20200613141520895.png></p> <p><img alt=image-20200613141550448 src=image-20200613141550448.png></p> <div></div> <div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div> 