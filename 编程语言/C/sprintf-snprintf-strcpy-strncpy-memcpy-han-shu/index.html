<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/编程语言/C/sprintf-snprintf-strcpy-strncpy-memcpy-han-shu/>sprintf、snprintf、strcpy、strncpy、memcpy 函数</a></h1><div class=post-meta-inline><span class=post-date> 2021-12-04 </span></div><div class=post-content><p>sprintf、snprintf、strcpy、strncpy、memcpy 函数</p><span id=continue-reading></span><p>安全版本：指定了操作字符的个数<h2 id=sprintfhan-shu>sprintf函数</h2><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sprintf</span><span>(</span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#bf616a;>buffer</span><span>, </span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>format</span><span>, [argument] ... );
</span></code></pre><ul><li>功能：将格式化的数据写入某个字符串缓冲区<li>入参：format，输出字符串的格式化列表，比如%d、%s、%c等<li>入参：[argument]对应的不定参数列表，与printf类似<li>出参：buffer，指向一段存储空间，用于存储格式化之后的字符串<li>返回值：返回写入buffer的字符数，出错则返回-1</ul><h2 id=snprintfhan-shu>snprintf函数</h2><p>snprintf是sprintf的安全版本<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>snprintf</span><span>(</span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#bf616a;>buffer</span><span>, size_t </span><span style=color:#bf616a;>size</span><span>, </span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>format</span><span>, [argument] ... );
</span></code></pre><ul><li>功能：有长度限制地，把格式化的数据写入某个字符串缓冲区<li>入参：format，输出字符串的格式化列表，比如"%s %d %c"等<li>入参：[argument]，format对应的不定参数列表，与printf的不定入参类似<li>入参：size，表示buffer指向存储空间的大小<li>出参：buffer，指向一段存储空间，用于存储格式化之后的字符串<li>返回值：返回写入buffer 的字符数，出错则返回-1 <ul><li>如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1，并且 errno 会被设置为 EINVAL</ul></ul><h2 id=strcpyhan-shu>strcpy函数</h2><pre class=language-cpp+ data-lang=cpp+ style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp+ data-lang=cpp+><span>char *strcpy(char *dest, const char *src);
</span></code></pre><ul><li>功能：将参数src字符串拷贝至参数dest所指的地址，会自动给dest字符串补结束符’\0’；<li>返回值：返回dest的字符串的起始地址；<li>说明：如果参数dest所指向的内存空间不够大，可能会造成缓冲溢出的错误情况（同sprintf）。</ul><h2 id=strncpyhan-shu>strncpy函数</h2><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>char </span><span>*</span><span style=color:#8fa1b3;>strncpy</span><span>(</span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#bf616a;>dest</span><span>, </span><span style=color:#b48ead;>const char </span><span>* </span><span style=color:#bf616a;>src</span><span>, size_t </span><span style=color:#bf616a;>n</span><span>);
</span></code></pre><ul><li>函数说明：strncpy()会将字符串src的前n个字符拷贝到字符串dest;<li>返回值：返回字符串dest<li>注意：strncpy()不会像strcpy那样向dest追加结束符，但是它可以拷贝结束符，结束符之后的字符不能够拷贝，src和dest所指向的内存区域不能重叠，且dest必须由足够大的空间放置n个字符</ul><h2 id=memcpyhan-shu>memcpy函数</h2><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>memcpy</span><span>(</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>dest</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>src</span><span>, size_t </span><span style=color:#bf616a;>n</span><span>);
</span></code></pre><ul><li>功能：将src指向地址为起始地址的连续n个字节的数据复制到以dest指向地址为起始地址的空间内<li>返回值：返回一个指向dest的指针<li>注意：src和dest所指向的内存区域不能重叠；与strcpy相比，memcpy并不是遇到结束符就停止拷贝，而是一定会拷贝完n个字节</ul><h2 id=qu-bie-jie-xi>区别解析</h2><table><thead><tr><th>函数名称<th>操作对象<th>简单分析<tbody><tr><td>strcpy<td>对字符串进行操作<td>调用简单，效率较高<tr><td>sprintf<td>操作对象可以是字符串，但不限于字符串，可以是任意基本类型<td>需要对指定格式符并且进行格式转换，调用较为烦琐且效率不高<tr><td>memcpy<td>对内存的拷贝，不考虑类型<td>高效，但需指定拷贝内存的长度</table></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>