<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/编程语言/Linux shell/shelljiao-ben-hou-tai-wen-ti/">shell脚本后台问题</a></h1><div class=post-meta-inline><span class=post-date> 2020-11-19 </span></div><div class=post-content><p>原文：<a href=https://www.zhihu.com/question/297339591/answer/504639445>shell 脚本多后台问题？ - 林果皞的回答 - 知乎</a><h2 id=basic>basic</h2><p>shell 脚本中用{}& 实现多个后台并行执行来提高速度，用wait等待后台执行完再执行后面的命令。<p>后台无论执行成功与否，只要允许完wait后面就会执行，那么如果后台执行报错如何终止脚本呢？<p>set -e 和 wait -n<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>modao@modao-hp:~$</span><span> cat wait.sh
</span><span>{ </span><span style=color:#96b5b4;>echo</span><span> 1; </span><span style=color:#bf616a;>sleep</span><span> 2; </span><span style=color:#96b5b4;>echo</span><span> 2; </span><span style=color:#bf616a;>zhihu</span><span>; </span><span style=color:#96b5b4;>echo</span><span> 3 &} & </span><span style=color:#96b5b4;>echo </span><span>'</span><span style=color:#a3be8c;>a</span><span>'; </span><span style=color:#96b5b4;>wait</span><span>; </span><span style=color:#96b5b4;>echo </span><span>'</span><span style=color:#a3be8c;>b</span><span>'
</span><span style=color:#bf616a;>modao@modao-hp:~$</span><span> bash wait.sh
</span><span style=color:#bf616a;>a
</span><span style=color:#bf616a;>1
</span><span style=color:#bf616a;>2
</span><span style=color:#bf616a;>wait.sh:</span><span> line 1: zhihu: command not found
</span><span style=color:#bf616a;>3
</span><span style=color:#bf616a;>b
</span></code></pre><p>在脚本头添加 set -e ( 或执行 bash -e wait.sh 也行)， 遭遇错误即提前退出， 不过仍然会继续执行 wait 之后的 echo 'b'：<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>modao@modao-hp:~$</span><span> cat wait.sh
</span><span style=color:#96b5b4;>set </span><span style=color:#bf616a;>-e
</span><span>{ </span><span style=color:#96b5b4;>echo</span><span> 1; </span><span style=color:#bf616a;>sleep</span><span> 2; </span><span style=color:#96b5b4;>echo</span><span> 2; </span><span style=color:#bf616a;>zhihu</span><span>; </span><span style=color:#96b5b4;>echo</span><span> 3 &} & </span><span style=color:#96b5b4;>echo </span><span>'</span><span style=color:#a3be8c;>a</span><span>'; </span><span style=color:#96b5b4;>wait</span><span>; </span><span style=color:#96b5b4;>echo </span><span>'</span><span style=color:#a3be8c;>b</span><span>'
</span><span style=color:#bf616a;>modao@modao-hp:~$</span><span> bash wait.sh
</span><span style=color:#bf616a;>a
</span><span style=color:#bf616a;>1
</span><span style=color:#bf616a;>2
</span><span style=color:#bf616a;>wait.sh:</span><span> line 2: zhihu: command not found
</span><span style=color:#bf616a;>b
</span></code></pre><p>wait 加上 -n 参数即可提前退出整个脚本:(-n 是 bash 4.3 新增的参数)<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>modao@modao-hp:~$</span><span> cat wait.sh
</span><span style=color:#96b5b4;>set </span><span style=color:#bf616a;>-e
</span><span>{ </span><span style=color:#96b5b4;>echo</span><span> 1; </span><span style=color:#bf616a;>sleep</span><span> 2; </span><span style=color:#96b5b4;>echo</span><span> 2; </span><span style=color:#bf616a;>zhihu</span><span>; </span><span style=color:#96b5b4;>echo</span><span> 3 &} & </span><span style=color:#96b5b4;>echo </span><span>'</span><span style=color:#a3be8c;>a</span><span>'; </span><span style=color:#96b5b4;>wait </span><span style=color:#bf616a;>-n</span><span>; </span><span style=color:#96b5b4;>echo </span><span>'</span><span style=color:#a3be8c;>b</span><span>'
</span><span style=color:#bf616a;>modao@modao-hp:~$</span><span> bash wait.sh
</span><span style=color:#bf616a;>a
</span><span style=color:#bf616a;>1
</span><span style=color:#bf616a;>2
</span><span style=color:#bf616a;>wait.sh:</span><span> line 2: zhihu: command not found
</span></code></pre><h2 id=more>more</h2><p>管道、括号才会开子 shell<p>|| && 会封闭 set -e，使其无效<p>见条件语句就封闭 -e<h2 id=from-bash-reference>from Bash Reference</h2><p>Exit immediately if a pipeline (see Section 3.2.2 [Pipelines],page 8), which may consist of a single simple command (seeSection 3.2.1 [Simple Commands], page 8), a list (see Section 3.2.3[Lists], page ), or a compound command (see Section 3.2.4[Compound Commands], page 9) returns a non-zero status.<p>如果任何管道以非零(”错误“)退出状态结束，立即终止脚本<p>The shell does not exit if the command that fails is part of the command list immediately following a <strong>while</strong> or <strong>until</strong> keyword, part of the test in an <strong>if statement</strong>, part of any command executed in a <strong>&&</strong> or <strong>||</strong> list <strong>except</strong> the command following the <strong>final && or ||</strong>, any command <strong>in a pipeline but the last</strong>, or if the command’s return status is being inverted with !.<p>shell不会退出，如果失败的命令是：<ul><li>紧随在<strong>while</strong> 或 <strong>until</strong> 关键字之后的命令列表的一部分<li>if语句中的测试的一部分<li>在**&&<strong>或</strong>||<strong>列表中的命令，除了最终的</strong>&&<strong>或</strong>||**之后的命令，管道中的任何命令都不会使shell退出<li>失败的命令的返回状态用**!**反转</ul><p>If a compound command other than a subshell returns a non-zero status because a command failed while -e was being ignored, the shell does not exit.<p>如果除子Shell之外的复合命令由于在-e被忽略时命令失败而返回非零状态，则该Shell不会退出。<p>A trap on ERR, if set, is executed before the shell exits.<p>如果设置了ERR陷阱，则会在shell程序退出之前执行陷阱。<p>This option applies to the shell environment and each subshell environment separately (see Section 3.7.3 [Command Execution nvironment], page 39), and may cause subshells to exit before executing all the commands in the subshell.<p>If a compound command or shell function executes in a context where -e is being ignored, none of the commands executed within the compound command or function body will be affected by the -e setting, even if -e is set and a command returns a failure status.<p>If a compound command or shell function sets -e while executing in a context where -e is ignored, that setting will not have any effect until the compound command or the command containing the function call completes.<p>该选项分别适用于Shell环境和每个子Shell环境（请参见第3.7.3节[命令执行环境]，第39页），并且可能导致子Shell在执行子Shell中的所有命令之前退出。<p>如果复合命令或shell函数在忽略-e的上下文中执行，则即使设置了-e且命令返回了故障状态，复合命令或函数体内执行的所有命令都不会受到-e设置的影响。<p>如果在忽略-e的上下文中执行时，复合命令或shell函数设置了-e，则该设置在复合命令或包含该函数调用的命令完成之前不会生效。<h2 id=porblem>porblem</h2><p><a href=https://www.jb51.cc/bash/390968.html>原文</a><p>-e选项意味着“如果任何管道以非零(”错误“)退出状态结束，立即终止脚本”。由于grep在没有找到任何匹配时返回退出状态1，即使没有真正的“错误”，也可能导致-e终止脚本。<p>如果你想保留-e选项，但也有一个grep命令可能有效地找不到匹配，你可以追加||。 ：to the grep命令。这意味着“或者，如果grep命令返回非零退出状态，运行：(它什么也不做)”;所以净效果是禁用grep命令的-e。所以：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>grep PATTERN FILE... || :
</span></code></pre><p>编辑添加：上面的方法丢弃每个错误：如果grep返回1，因为它发现没有匹配，这被忽略，但如果grep返回2，因为有一个错误，被忽略，如果grep不在路径中Bash返回127)，被忽略 – 等等。所以，而不是：，最好使用一个命令来检查结果代码，如果它不是1，重新发出错误。例如：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>grep PATTERN FILE || (( $? == 1 ))
</span></code></pre><p>但这破坏了退出状态;通常，当失败的命令使用-e终止Bash脚本时，脚本将返回命令的退出状态，但在上面的示例中，脚本将只返回1.如果(并且只有)我们关心它，我们可以修复它通过写这样：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>grep PATTERN FILE || exit_code=$?
</span><span>if (( exit_code > 1 )) ; then
</span><span>	exit $exit_code
</span><span>fi
</span></code></pre><p>(第一行c / o <a href=javascript:void()>dsummersl</a>的评论)。<p>在这一点上，最好创建一个shell函数来处理这个：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>function grep_no_match_ok () {    
</span><span>	local exit_code    
</span><span>	grep "$@" || exit_code=$?    
</span><span>	return $(( exit_code == 1 ? 0 : exit_code ))
</span><span>}
</span></code></pre><p>(注意使用返回而不是退出;我们将让-e在适当时处理退出);这样，我们可以只写：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>grep_no_match_ok PATTERN FILE     
</span><span># won't kill script if no matches are found
</span></code></pre><p>事实上，由于我们最有可能想在这个脚本中使用这个函数来处理grep的所有事件，我们实际上可以命名函数grep：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>function grep () {
</span><span>	local exit_code
</span><span>    command grep "$@" || exit_code=$?
</span><span>	return $(( exit_code == 1 ? 0 : exit_code ))
</span><span>}
</span><span>grep PATTERN FILE    
</span><span># won't kill script if no matches are found
</span></code></pre><p>(注意使用命令来绕过其自身体中的shell函数：我们希望该函数调用常规程序grep，而不是无限递归)。</div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>