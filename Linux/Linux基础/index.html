<!DOCTYPE html>
<html>
  <head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>modao</title>
	
	<script type="text/javascript" charset="utf-8">
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?36479f1e15841da95f9e92a25b010d23";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<meta name="generator" content="Hexo 5.4.0"></head>
  <body>
	
      
<link rel="stylesheet" href="/css/navigatebar.css">


<div class="navigatebar">
	<div class="navigatebar-button navigatebar-mine">
    <a href="/">modao</a>
	</div>
	
	
        <div class="navigatebar-button">
          <a href="/">Home</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/categories">Categories</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/links">Friends</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/sites">Sites</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/stars">Stars</a>
        </div>
	
</div>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">


<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%B8%AE%E5%8A%A9"><span class="toc-text">文档帮助</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%9F%A5%E6%89%BE"><span class="toc-text">搜索查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%EF%BC%9Afind"><span class="toc-text">根据指定的条件查询：find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6%E5%90%8D%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Alocate"><span class="toc-text">搜索文件名数据库：locate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E6%90%9C%E7%B4%A2%EF%BC%9Agrep"><span class="toc-text">在文本文件中搜索：grep</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4"><span class="toc-text">组合命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">标准输入输出流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-text">文本处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-text">磁盘管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ps"><span class="toc-text">ps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kill"><span class="toc-text">kill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top"><span class="toc-text">top</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsof"><span class="toc-text">lsof</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7"><span class="toc-text">性能监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7"><span class="toc-text">网络工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ss"><span class="toc-text">ss</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-text">用户管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">系统管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8F%82%E8%80%83"><span class="toc-text">主要参考</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		Linux基础-汇总记录
	</div>
	
	<div class="page-date">
		2021-01-03
	</div>
	
	<div class="category-area">
		
			 
				「
				<div class="category">
					<a href="/categories/Linux">Linux</a>
				
				</div>
				」
			
		
	</div>
	
	<div class="content">
		<p>介绍Linux常用命令工具。</p>
<span id="more"></span>

<h2 id="文档帮助"><a href="#文档帮助" class="headerlink" title="文档帮助"></a>文档帮助</h2><p>查看命令简要说明：<code>whatis</code></p>
<ul>
<li>  参数-w开启正则匹配</li>
</ul>
<p>查看命令详细说明：<code>info</code></p>
<p>查看命令说明文档：<code>man</code></p>
<ul>
<li><p>  基于命令的功能来搜索命令：man -k</p>
</li>
<li><p>  根据命令的名称快速查找命令的功 能：man -f</p>
</li>
<li><p>  重建man数据库：man -u</p>
</li>
<li><p>读取命令的特定man page：man [1-8]</p>
<ol>
<li><p> 普通命令，如cd、chmod、lp、mkdir和passwd。 </p>
</li>
<li><p> 由内核提供的底层系统调用，如intro和chmod。 </p>
</li>
<li><p> C库函数，如beep、HTML::Parser和Mail::Internet。</p>
</li>
<li><p> 特殊文件，如/dev中找到的设备，包括控制台（console）、打 印机（lp）和鼠标（mouse）。 </p>
</li>
<li><p> 文件格式和约定，如apt.conf、dpkg.cfg、hosts和 passwd。 </p>
</li>
<li><p> 游戏，如atlantik、bouncingcow、kmahjongg和rubik。 </p>
</li>
<li><p> 杂项，包括宏包（macro package）。如ascii、samba和utf8。 </p>
</li>
<li><p> root用户使用的系统管理命令，如mount和shutdown。</p>
</li>
</ol>
</li>
</ul>
<p>读取命令的描述：<code>whatis</code>，相当于<code>man -f</code></p>
<ul>
<li>  参数-w：开启通配符匹配</li>
<li>  参数-r：开启正则匹配</li>
</ul>
<p>基于功能查找命令：<code>opropos</code>，相当于<code>man -k</code></p>
<ul>
<li><p>  参数-w：开启通配符匹配</p>
</li>
<li><p>  参数-r：开启正则匹配</p>
</li>
<li><p>  参数-e：开启精确匹配</p>
</li>
</ul>
<p><code>whereis</code>：查找命令的可执行文件、源文件和 man page的路径</p>
<ul>
<li>  参数-b：如果只想搜索二进制文件</li>
<li>  参数-m：如果只想搜索man page</li>
<li>  参数-s：如果只想搜索源文件</li>
</ul>
<p><code>which</code>：命名存在多个版本时，找出将要运行的命令的版本</p>
<ul>
<li>  参数-a：查找命令的所有位置</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>创建文件，修改时间：<code>touch</code>，touch存在的主要目的是更新文件访问和修改时间</p>
<ul>
<li>  参数-a：只更新访问时间</li>
<li>  参数-m：只更新修改时间</li>
<li>  参数<code>-t YYYYMMDDhhmm.ss</code>：指定修改时间</li>
</ul>
<p>创建目录：<code>mkdir</code></p>
<ul>
<li>  参数-p：逐层建立子目录</li>
<li>  参数-v：执行时显示执行过程</li>
</ul>
<p>删除：<code>rm</code></p>
<ul>
<li>  参数-r、-R表递归子目录</li>
<li>  参数-v：执行时显示执行过程</li>
<li>  参数-f表示不询问</li>
<li>  参数-i表示删除之前询问</li>
<li>  删除空目录：<code>rmdir</code></li>
<li>  删除文件和非空的目录：<code>rm -rf</code></li>
<li>  参数<code>--</code>：跟在后面的任何东西都不能作为选项，而是文件或文件夹 的名称</li>
</ul>
<p>移动：<code>mv</code></p>
<ul>
<li>  mv命令实际上执行了一个cp -a操作，在成功复制文件后再移除原有的文件</li>
<li>  参数-i表示覆盖之前询问</li>
<li>  参数-v：执行时显示执行过程</li>
<li>  移动软连接时，在软连接末端加斜杆<code>/</code>移动的是软连接指定的目录，没有斜杆时移动软连接本身</li>
</ul>
<p>复制：<code>cp</code></p>
<ul>
<li><p>  参数-r、-R表示递归复制</p>
</li>
<li><p>  参数-a表示保留链接和文件属性，并递归子目录，用于制作完整备份，相当于<code>-dpR</code></p>
</li>
<li><p>  参数-i表示覆盖之前询问</p>
</li>
<li><p>  参数-p表示复制修改时间和访问权限</p>
</li>
<li><p>  参数-v：执行时显示执行过程</p>
</li>
</ul>
<p>显示当前目录：<code>pwd</code></p>
<p>切换目录：<code>cd</code></p>
<p>列出目录项：<code>ls</code></p>
<ul>
<li>  参数-l表示显示详细信息</li>
<li>  参数-a表示显示隐藏文件</li>
<li>  参数-R表示递归</li>
<li>  参数-h以易读方式显示</li>
</ul>
<p>查看文件内容：</p>
<ul>
<li><p><code>cat</code>：从头到尾显示内容，常用来拼接文件</p>
<ul>
<li>  参数-n表示显示行号</li>
</ul>
</li>
<li><p>  <code>tac</code>：从尾到头显示内容</p>
</li>
<li><p><code>head</code> ：默认显示文件前10行</p>
<ul>
<li>  参数-n 4表示显示前4行的内容</li>
<li>  参数-n -4表示显示除文件最后4行外的内容</li>
<li>  参数-c 2表示显示前2个字节的内容</li>
<li>  参数-c -2表示显示除文件最后2个字节外的内容</li>
</ul>
</li>
<li><p><code>tail</code>：默认显示文件后10行</p>
<ul>
<li>  参数-n 4表示显示后4行的内容</li>
<li>  参数-n -4表示显示除文件前面4行外的内容</li>
<li>  参数-c 2表示显示后2个字节的内容</li>
<li>  参数-c +2表示显示除文件前2个字节外的内容</li>
</ul>
<blockquote>
<p>  <code>more</code> &amp; <code>less</code>的区别：</p>
<ol>
<li> less可以按键盘上下方向键显示上下内容,more不能通过上下方向键控制显示</li>
<li> less不必读整个文件，加载速度会比more更快</li>
<li> less退出后shell不会留下刚显示的内容,而more退出后会在shell上留下刚显示的内容</li>
</ol>
</blockquote>
</li>
</ul>
<p>创建链接：</p>
<ul>
<li>  <code>ln</code>：硬链接，相对独立</li>
<li>  <code>ln -s</code>：软连接（符号链接），相当于快捷方式</li>
</ul>
<h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><h3 id="根据指定的条件查询：find"><a href="#根据指定的条件查询：find" class="headerlink" title="根据指定的条件查询：find"></a>根据指定的条件查询：<code>find</code></h3><ul>
<li><code>find . -name modao</code>：根据文件名modao查找当前目录<ul>
<li>  搜索使用的是相对路径，结果使用的也是相对路径</li>
<li>  搜索使用的是绝对路径，结果使用的也是绝对路径</li>
</ul>
</li>
<li><code>find . -user modao</code>：根据拥有者搜索文件<ul>
<li>  搜索结果取反：<code>find . ! -user modao</code></li>
</ul>
</li>
<li><code>find . -group modao</code>：根据用户组搜索文件<ul>
<li>  搜索结果取反：<code>find . ！ -group modao</code></li>
</ul>
</li>
<li><code>find . -size 10M</code>：根据文件大小搜索文件<ul>
<li>文件大小后缀:<ul>
<li>  b：512字节块，默认值</li>
<li>  c：字节</li>
<li>  k：千字节</li>
<li>  M：兆字节</li>
<li>  G：吉字节</li>
</ul>
</li>
<li>  如果要搜索的文件大小大于10 MB，需要在指定的大小 前面加一个加号（+）</li>
<li>  如果要搜索的文件大小小于10 MB，则需要在 大小前面加一个减号（-）</li>
</ul>
</li>
<li><code>find . -type d</code>：根据文件类型搜索文件<ul>
<li>  f：普通文件</li>
<li>  d：目录 </li>
<li>  l: 符号（软）链接</li>
<li>  b：块文件</li>
<li>  c：字符文件</li>
<li>  p：管道文件</li>
<li>  s：套接字</li>
</ul>
</li>
<li>  参数-a：与，把搜索选项组合起来，当表达式均为true时显示结果</li>
<li>  参数-o：或，把搜索选项并列起来，当表达式中只有一个为true时就显示结果</li>
<li>  参数-n：取反，把搜索结果取反，当表达式为not true时显示结果</li>
<li>  参数-exec：后接一个命令，对搜索到的每个文件执行命令</li>
<li>  参数-fprint：将搜索结果打印到文件，后面指定文件名</li>
</ul>
<h3 id="搜索文件名数据库：locate"><a href="#搜索文件名数据库：locate" class="headerlink" title="搜索文件名数据库：locate"></a>搜索文件名数据库：<code>locate</code></h3><p>知道文件的名称，或者名称的一部分，但不记得放在系统的哪个位置。这就是locate命令要解决的问题。locate命令能够在文件、程序和目录中查找与提供的搜索项匹配的内容，并把任何匹配的结果依次显示到终端界面上。</p>
<p>搜索结果出来得非常快，因为locate命令并没有对系统进行实时搜 索。实际上，它搜索的是每天自动更新的文件名数据库。因为locate搜索的是早已创建好的数据库，所以搜 索结果几乎能够瞬间显示出来。</p>
<p><code>locate</code>：从数据库 <code>(/var/lib/mlocate/mlocate.db) </code>查找命令，使用<code>updatedb</code>更新库。索引查找速度快，需要更新，查找结果是整个路径</p>
<ul>
<li><p>  <code>locate modao</code>：查找路径，路径内容包含modao</p>
</li>
<li><p>  参数-i：不区分大小写的搜索</p>
</li>
<li><p>  参数-n：管理搜索文件名数据库时返回的结果，通过指定的数字指定结果个数</p>
</li>
<li><p>  <code>updatedb</code>：更新locate使用的数据库</p>
</li>
<li><p>  <code>time updatedb</code>：更新数据库时顺便计时，处理完后显示更新花费的时间。</p>
</li>
<li><p>  <code>locate -b modao</code>：查找路径，路径基名内容包含modao</p>
</li>
<li><p>  <code>locate modao modao_test</code>：查找路径，路径内容包含modao<strong>或</strong>modao_test</p>
</li>
<li><p>  <code>locate -A modao modao_test</code>：查找路径，路径内容包含modao<strong>和</strong>modao_test</p>
</li>
<li><p>  <code>locate -c modao</code>：查找路径，路径内容包含modao，结果是显示匹配的条目数</p>
</li>
</ul>
<h3 id="在文本文件中搜索：grep"><a href="#在文本文件中搜索：grep" class="headerlink" title="在文本文件中搜索：grep"></a>在文本文件中搜索：<code>grep</code></h3><p>一般用法：<code>grep modao ./dir/*</code></p>
<p><img src="/Linux%E5%9F%BA%E7%A1%80/image-20210103203410531.png" alt="image-20210103203410531"></p>
<p>正则表达式中的单引号和双引号的用法也有很大区别。单引号是在告诉shell正在搜索一个字符串，而双引号则是让shell知道想要使用shell变量。</p>
<ul>
<li>  如果要搜索精确的匹配结果，就使用单引号；</li>
<li>  如果要把shell变量结 合到搜索内容中（很少有这样的需要），就使用双引号；</li>
<li>  但如果搜索 关键字只包含数字和字母，完全不使用任何引号也没有问题。</li>
</ul>
<p>参数-R：递归式地搜索文件中的文本</p>
<p>参数-i：搜索文件中的文本，忽略大小写</p>
<p>参数-w：在文件中只搜索整个词</p>
<p>参数-n：显示搜索结果在文件中的行号</p>
<p>参数-v：显示没有包含搜索内容的行</p>
<p>参数-l：列出包含搜索内容的文件名</p>
<p>在其他命令的输出中搜索特定内容：<code>ls -1 | grep 1960</code></p>
<p>在搜索结果中进行搜索：<code>ls -1 | grep 196[6-7] | grep -v Live</code></p>
<p>查看文件中搜索内容的上下文信息：</p>
<ul>
<li>  -A：搜索结果包括后面n行</li>
<li>  -B：搜索结果包括前面n行</li>
<li>-C：搜索结果包括前面n行和后面n行<ul>
<li>配合-n参数使用，通过行号数字后面的字符<ul>
<li>  为冒号（:）表示匹配行</li>
<li>  为连字符（-）表示匹配行之前或之后的行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h2><p>分号<code>;</code>创建命令栈：命令栈是将所有需要运行的命令放到shell的一行上，再用分号（;） 隔开每个具体的命令。接着依次<strong>顺序执行</strong>每个命令，只有一个命令结束运行（无论成功或失败），才会运行下一个命令。</p>
<p>使用<code>&amp;&amp;</code>代替<code>;</code>来顺序执行命令：只有前面的命令运行<strong>成功</strong>，才运行下一个命令</p>
<p>使用<code>||</code>代替<code>;</code>来顺序执行命令：只有前面的命令运行<strong>失败</strong>，才运行下一个命令</p>
<p><code>$()</code>：命令替换，将一个命令的输出插入到另一个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir $(date &quot;+%Y-%m-%d&quot;)<br></code></pre></td></tr></table></figure>

<h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><p><code>|</code>：当把它放在两个命令之间时，它可以将第一个命令的输出作为第二个命令的输入。换句话说，|重定向stdout，将它发送到第二个命令的stdin。</p>
<p><code>&gt;</code>：将命令的输出重定向到文件，覆盖型。为了防止重定向时覆盖文件：<code>set -o noclobber</code>，从现在起，如果要使用重定向并覆盖文件，应该用<code>&gt;|</code>代替<code>&gt;</code>。关闭noclobber：<code>set +o noclobber</code>。要一直开着<code>noclobber</code>选项，需要在<code>.bashrc</code>文件中增加一行<code>set -o noclobber</code>。</p>
<p><code>&gt;&gt;</code>：将命令的输出追加到文件的底部，追加型（如果文件不存在，就会创建它）</p>
<p><code>&lt;</code>：将文件作为命令的输入</p>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><p>sort命令：对文本内容排序</p>
<ul>
<li>  -d：按字典序升序排列，空行在前（默认）；</li>
<li>  -r：降序</li>
<li>  -b：忽略每行前面开始的空格字符，空格数量不固定时，该选项几乎是必须要使用的；</li>
<li>  -f：忽略大小写进行排列</li>
<li>  -h：使用易读性数字（例如：2K、1G）</li>
<li>按行中的某个字段排序：<ul>
<li>  -k [n]：n从1开始计数，字段间默认使用空格隔开，默认-k 1</li>
<li>  +[n]：n从0开始计算，默认+0</li>
</ul>
</li>
<li>  -n：按照<strong>数值</strong>的大小排序（升序）</li>
<li>  -o &lt;输出文件&gt;：将排序后的结果存入指定的文件</li>
<li>  -u：忽略相同行</li>
<li>  -c：选项检查文件是否已经排好序</li>
<li>  -t &lt;分割字符&gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符</li>
<li>  –help：显示帮助</li>
<li>  –version：显示版本信息</li>
</ul>
<p>uniq命令：比较相邻的行并去掉重复的行，对不相邻的行无效</p>
<ul>
<li>  -c：去掉相邻重复的行，并在每列旁边重复该行出现的次数</li>
<li>  -u：仅显示出现一次的行</li>
<li>  -d：只显示重复的行</li>
<li>  [输入文件]：指定已经排好序的文本文件，如果不指定此项，则从标准读取数据</li>
<li>  [输出文件]：指定输出的文件，如果不指定此选项，则将内容显示到标准输出设备（显示终端）</li>
</ul>
<p>【留空】</p>
<p>sed和echo已经另外记录</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666545074&idx=1&sn=7a6f86ae45c5e7254b71da7fcbbdef8d&chksm=80dcfb19b7ab720ff5ffc78d77092b805c54b22839e02fbf4741f06be90845552172258ac978&scene=21#wechat_redirect">Linux 三剑客之 awk 详解</a></p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>查看磁盘空间：<code>df</code>，默认以B为单位且不显示单位</p>
<ul>
<li>  参数-h，易读方式显示（人类可读的（human-readable）），显示单位（M/G）</li>
</ul>
<p>查看<strong>当前</strong>目录所占空间：<code>du</code></p>
<ul>
<li><p>  参数-h，易读方式显示</p>
</li>
<li><p>  参数-s，只报告目录使用的总空间</p>
</li>
<li><p>查看当前目录下所有子文件夹排序后的大小：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `ls`; <span class="hljs-keyword">do</span> du -sh <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span> | sort<br><span class="hljs-comment">## 或者：</span><br>du -sh `ls` | sort<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>在linux中归档和压缩和分两步来实现的</strong></p>
<p>归档文件：<code>tar</code></p>
<ul>
<li>  <strong>参数-c：打包选项</strong></li>
<li>  参数-v：显示进度</li>
<li>  参数-z：调用gzip程序进行压缩，生成tar.gz</li>
<li>  参数-j：调用bzip2程序进行压缩，生成tar.bz2</li>
<li>  <strong>参数-f：使用档案文件，后跟文件名</strong></li>
</ul>
<p>解包文件：<code>tar</code></p>
<ul>
<li>  <strong>参数-x：解包选项</strong></li>
<li>  参数-v：显示进度</li>
<li>  参数-z：调用gzip程序进行解压</li>
<li>  参数-j：调用bzip2程序进行解压</li>
<li>  <strong>参数-f：使用档案文件，后跟文件名</strong></li>
</ul>
<p>测试tarball：参数-t</p>
<p>压缩文件 &amp; 解压文件：</p>
<ul>
<li><p><code>gzip</code>，压缩文件后缀为gz结尾，不需要命名压缩文件，压缩后删除原文件</p>
<ul>
<li><p>参数-c：保留原始文件，需要重定向输出</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gzip -c paradise_lost.txt &gt; paradise_lost.txt.gz<br></code></pre></td></tr></table></figure></li>
<li><p>  参数-r：递归遍历子目录，默认不递归</p>
</li>
<li><p>  <code>zcat</code>：不解压查看gz压缩文件</p>
</li>
<li><p>  参数-d：解压文件</p>
</li>
<li><p>  参数<code>-[0-9]</code>：压缩效果，默认为6</p>
</li>
</ul>
</li>
<li><p><code>gunzip</code>：解压gz压缩文件，解压完后删除压缩文件</p>
<ul>
<li><p>参数-c：保留压缩文件，需要重定向输出</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gunzip -c paradise_lost.txt.gz &gt; paradise_lost.txt<br></code></pre></td></tr></table></figure></li>
<li><p>  参数-t：测试压缩文件</p>
</li>
</ul>
</li>
<li><p><code>bzip2</code>：压缩文件后缀为bz2结尾<em>（比gzip有着更大压缩比）</em></p>
<ul>
<li>  参数-c：保留原始文件，需要重定向输出</li>
<li>  参数-k，压缩或解压后保留原文件</li>
<li>  参数-d，解压bz2压缩文件</li>
<li>  参数<code>-[0-9]</code>：压缩效果，默认为6</li>
<li><code>bzcat</code>：不解压查看bz2压缩文件</li>
</ul>
</li>
<li><p><code>bgunzip2</code>：解压bz2压缩文件，解压完后删除压缩文件</p>
<ul>
<li>  参数-c：保留压缩文件，需要重定向输出</li>
<li>  参数-t：测试压缩文件</li>
</ul>
</li>
<li><p><code>xz</code>：压缩文件后缀为xz结尾</p>
<ul>
<li>  参数-d：解压</li>
<li>  参数-k：压缩或解压后保留原文件</li>
<li>  参数-#：压缩比</li>
<li>  <code>unxz</code>：解压</li>
<li><code>xzcat</code>：不解压查看</li>
</ul>
</li>
<li><p><code>zip</code>：打包压缩工具，<strong>可以压缩目录</strong>，默认不删除原文件：<code>zip [目标zip文件名称] [要加到zip文件的内容]</code></p>
<ul>
<li>  参数-r：递归目录</li>
<li>  参数-d：删除压缩文件中的某个文件</li>
<li>  参数-m：添加某个文件到压缩文件中</li>
<li>  压缩效果-[0-9]：数字越大，压缩效果越好</li>
<li>  参数<code>-P [passwd]</code>：设置压缩密码</li>
<li>参数-e：设置压缩密码，交互输入更安全</li>
</ul>
</li>
<li><p><code>unzip</code>：解压工具</p>
<ul>
<li>  参数-v：显示更多运行时信息</li>
<li>  参数-l：不解压查看文件内容</li>
<li>  参数-t：测试待解压文件</li>
<li>  参数-d：指定解压目录</li>
<li>  参数-o：不提示，直接覆盖</li>
</ul>
</li>
</ul>
<p><img src="/Linux%E5%9F%BA%E7%A1%80/image-20200718152352629.png" alt="image-20200718152352629"></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h3><p>查询所有进程信息：<code>ps aux</code></p>
<ul>
<li>  a：所有用户</li>
<li>  u：显示拥有每个进程的用户</li>
<li>  x：没有控制tty或终端屏幕的进程</li>
</ul>
<p>ps命令显示当前状态（STAT）的种类</p>
<ul>
<li>  R：运行</li>
<li>  S：休眠</li>
<li>  T：停止</li>
<li>  Z：僵尸：表示进程已经终止，但父进程无法正常终止它</li>
</ul>
<blockquote>
<p>  Z是个坏消息，因为它意味着进程基本上一直处于挂起状态，不能停止 （幸运的是，这并不意味着没有解决问题的办法）。如果某个程序有 问题，ps标明其状态为Z，这时或许只有重启计算机才能完全关闭这个 程序。</p>
<p>  kill -9选项对“僵尸”进程也没有效果，这样的进程早已经死掉了，因此kill命令对它也无能为力。重启是唯一能够解决这种问题的办法，不过这样的问题通常是无关紧 要的。</p>
</blockquote>
<p>查看进程树：<code>ps axjf</code></p>
<p>查看特定用户拥有的进程：<code>ps U [username]</code></p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a><code>kill</code></h3><p>发送指定信号到相应进程：<code>kill</code>，默认信息是15，指正常停止，一般操作对象是PID，也可使用%jobs指定作业号</p>
<ul>
<li><p>  参数-l，列出全部信号名称</p>
</li>
<li><p>  参数-u，为指定用户的所有进程发送信号</p>
</li>
<li><p>参数-s #，指定信号，常缩写为**<code>-#</code>**</p>
<p>  常用信号：</p>
<ul>
<li>  HUP，1，终端短线</li>
<li>  INT，2，中断（同C-c）</li>
<li>  QUIT，3，退出（同C-\）</li>
<li>  TERM，15，默认信号</li>
<li>  <strong>KILL，9，强制终止</strong></li>
<li>  CONT，18，继续（与STOP相反，<code>fg/bg</code>命令）</li>
<li>  STOP，19，暂停（同C-z）</li>
</ul>
<blockquote>
<ol>
<li><p> 当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息。有时这个信息不会马上显示，只有当按下Enter键使shell的命令提示符再次出现时，才会显示出来。</p>
</li>
<li><p> 应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。</p>
</li>
<li><p> 要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h3><p>top命令提供的则是进程的动态更新的视图，展示系统中正在运行着什么进程，以及每个进程正在使用多少系统资源</p>
<ul>
<li><code>top</code>：查看系统中使用CPU、使用内存最多的进程，<strong>交互界面</strong><ul>
<li>  P：根据CPU使用百分比大小进行排序</li>
<li>  M：根据驻留内存大小进行排序</li>
<li>  i：使top不显示任何闲置或者僵死进程</li>
<li>  k：在top命令中关闭程序</li>
</ul>
</li>
<li><code>htop</code>：<ul>
<li>  上左区：显示了CPU、物理内存和交换分区的信息；</li>
<li>  上右区：显示了任务数量、平均负载和连接运行时间等信息</li>
<li>  进程区域：显示出当前系统中的所有进程</li>
<li>  操作提示区：显示了当前界面中F1-F10功能键中定义的快捷功能</li>
</ul>
</li>
<li>  <code>bpytop</code>：可视化程度更高</li>
</ul>
<p>分析线程堆栈：<code>pmap</code>，输出内存的状况</p>
<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a><code>lsof</code></h3><p>Linux系统中的所有东西都是文件，包括目录、网络连接和设备</p>
<p>列出当前系统打开的所有文件的工具：<code>lsof</code>（list open files的缩写）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有打开的文件:</span><br>lsof<br><span class="hljs-comment"># 备注: 如果不加任何参数，就会打开所有被打开的文件，内容非常多，可以通过管道传给less</span><br><br><span class="hljs-comment"># 列出某个用户打开的文件</span><br>lsof -u username<br><br><span class="hljs-comment"># 列出除了某个用户外的被打开的文件</span><br>lsof -u ^username<br><br><span class="hljs-comment"># 列出正在使用特定文件的用户</span><br>lsof /filepath/file<br><br><span class="hljs-comment">#递归查看某个目录的文件信息</span><br>lsof +D /filepath/filepath2/<br>lsof | grep ‘/filepath/filepath2/’<br><br><span class="hljs-comment"># 列出特定程序的进程</span><br>lsof -c [program]<br><br><span class="hljs-comment"># 列出多个程序的进程</span><br>lsof -c [program] -c [program]<br><br><span class="hljs-comment"># 列出某个用户以及某个程序所打开的文件</span><br>lsof -u username -c [program]<br><br><span class="hljs-comment"># 通过某个进程号显示该进行打开的文件</span><br>lsof -p 1<br><br><span class="hljs-comment"># 列出多个进程号对应的文件信息</span><br>lsof -p 123,456,789<br><br><span class="hljs-comment"># 列出除了某个进程号，其他进程号所打开的文件信息</span><br>lsof -p ^1<br><br><span class="hljs-comment"># 列出所有的网络连接</span><br>lsof -i<br><br><span class="hljs-comment"># 列出所有tcp 网络连接信息</span><br>lsof -i tcp<br><br><span class="hljs-comment"># 列出所有udp网络连接信息</span><br>lsof -i udp<br><br><span class="hljs-comment"># 列出谁在使用某个端口</span><br>lsof -i :3306<br><br><span class="hljs-comment"># 列出谁在使用某个特定的udp端口</span><br>lsof -i udp:55<br><br><span class="hljs-comment"># 特定的tcp端口</span><br>lsof -i tcp:80<br><br><span class="hljs-comment"># 列出某个用户的所有活跃的网络端口</span><br>lsof -a -u <span class="hljs-built_in">test</span> -i<br><br><span class="hljs-comment"># 列出所有网络文件系统</span><br>lsof -N<br><br><span class="hljs-comment">#域名socket文件</span><br>lsof -u<br><br><span class="hljs-comment">#某个用户组所打开的文件信息</span><br>lsof -g 5555<br><br><span class="hljs-comment"># 根据文件描述列出对应的文件信息</span><br>lsof -d description(like 2)<br><br><span class="hljs-comment"># 根据文件描述范围列出文件信息</span><br>lsof -d 2-3<br></code></pre></td></tr></table></figure>

<blockquote>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27870421/article/details/92803453">Linux lsof命令</a></p>
<p>  <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a3aa6b01b2e1">Linux 命令神器：lsof</a></p>
</blockquote>
<p>使用文件或文件结构识别进程：<code>fuser</code></p>
<ul>
<li><p>  <strong>fuser命令</strong> 用于报告进程使用的文件和网络套接字。fuser命令列出了本地进程的进程号，那些本地进程使用file，参数指定的本地或远程文件。对于阻塞特别设备，此命令列出了使用该设备上任何文件的进程。</p>
</li>
<li><p>每个进程号后面都跟随一个字母，该字母指示进程如何使用文件。</p>
<ul>
<li>  c：指示进程的工作目录。</li>
<li>  e：指示该文件为进程的可执行文件(即进程由该文件拉起)。</li>
<li>  f：指示该文件被进程打开，默认情况下f字符不显示。</li>
<li>  F：指示该文件被进程打开进行写入，默认情况下F字符不显示。</li>
<li>  r：指示该目录为进程的根目录。</li>
<li>  m：指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">语法：fuser(选项)(参数)<br><br>选项：<br>-a：显示命令行中指定的所有文件；<br>-c：和-m一样，用于POSIX兼容；<br>-s：静默模式，这时候-u,-v会被忽略。-a不能和-s一起使用；<br>-k：杀死访问指定文件的所有进程，如果没有指定-signal就会发送SIGKILL信号；<br>-signal：使用指定的信号，而不是用SIGKILL来杀掉进程。可以通过名称或者号码来表示信号(例如-HUP,-1),这个选项要和-k一起使用，否则会被忽略；<br>-i：杀死进程前需要用户进行确认；<br>-l：列出所有已知信号名；<br>-m name：指定一个被加载的文件系统或一个被加载的块设备,这样所有访问这个文件或者文件系统的进程都会被列出来。如果指定的是一个目录会自动转换成&quot;name/&quot;,并使用所有挂载在那个目录下面的文件系统；<br>-n space：选择不同的名称空间，这里支持不同的空间文件(文件名，此处默认)、tcp(本地tcp端口)、udp(本地udp端口)。对于端口， 可以指定端口号或者名称，如果不会引起歧义那么可以使用简单表示的形式，例如：name/space (即形如:80/tcp之类的表示)；<br>-u：在每个进程后显示所属的用户名；<br>-v：详细模式。输出似ps命令的输出，包含PID,USER,COMMAND等许多域,如果是内核访问的那么PID为kernel.  -V 输出版本号。 <br>-4：使用IPV4套接字,不能和-6一起应用，只在-n的tcp和udp的命名存在时不被忽略。  <br>-6：使用IPV6套接字,不能和-4一起应用，只在-n的tcp和udp的命名存在时不被忽略。  <br>-：重置所有的选项，把信号设置为SIGKILL.  <br><br>参数：文件，可以是文件名或者TCP、UDP端口号。<br><br>#列出使用/etc/passwd文件的本地进程的进程号<br>fuser /etc/passwd<br><br>#列出使用/etc/filesystems文件的进程信息<br>fuser -um /etc/filesystems<br><br>#杀掉打开readme文件的程序<br>fuser -m -k -i readme<br><br>#查看那些程序使用tcp的80端口 <br>fuser -v -n tcp 80  <br>fuser -v 80/tcp  <br><br>#用 -l参数可以列出fuser所知的信号<br>fuser -l<br><br>#终止使用给定文件系统的所有进程<br>fuser -k -x -u -c /dev/hd1<br>fuser -kxuc /home<br><br>命令会列出了进程号和用户名，然后终止每个正在使用/dev/hd1 (/home)文件系统的进程。仅有root用户能终止属于另一用户的进程。如果您正在试图卸下/dev/hd1文件系统，而一个正在访问/dev/hd1文件系统的进程不允许这样，您可能希望使用此命令。<br><br>#列出正在使用已从给定文件系统删除的文件的全部进程<br>fuser -d /usr文件<br><br>/dev/kmem 用于系统映像。<br>/dev/mem 也用于系统映像。<br></code></pre></td></tr></table></figure></li>
</ul>
<p>pgrep</p>
<h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><p>CPU监控：<code>top</code></p>
<p>内存监控：<code>free</code></p>
<ul>
<li>  参数-m，以MB为单位</li>
<li>  参数-k，以KB为单位</li>
<li>  参数-g，以GB为单位</li>
</ul>
<p>综合监控工具：<code>vmstat</code></p>
<ul>
<li>参数<ul>
<li>  参数1：刷新时间</li>
<li>  参数2：采集次数</li>
</ul>
</li>
<li>字段<ul>
<li>procs<ul>
<li>  r：等待执行的任务数</li>
<li>  B：等待IO的进程数量</li>
</ul>
</li>
<li>memory<ul>
<li>  swpd：正在使用虚拟的内存大小，单位k</li>
<li>  free：空闲内存大小</li>
<li>  buff：已用的buff大小，对块设备的读写进行缓冲</li>
<li>  cache：已用的cache大小，文件系统的cache</li>
</ul>
</li>
<li>swap<ul>
<li>  si：每秒从交换区写入内存的大小（单位：kb/s）</li>
<li>  so：每秒从内存写到交换区的大小</li>
</ul>
</li>
<li>IO<ul>
<li>  bi：每秒读取的块数（读磁盘）</li>
<li>  bo：每秒写入的块数（写磁盘）</li>
</ul>
</li>
<li>system<ul>
<li>  in：每秒中断数，包括时钟中断</li>
<li>  cs：每秒上下文切换数</li>
</ul>
</li>
<li>CPU<ul>
<li>  us：用户进程执行消耗cpu时间(user time)</li>
<li>  sy：系统进程消耗cpu时间(system time)</li>
<li>  id：空闲时间(包括IO等待时间)</li>
<li>  wa：等待IO时间</li>
<li>  st：Time stolen from a virtual machine. Prior to Linux 2.6.11, unknown</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>超级监控工具：<code>dstat</code></p>
<ul>
<li>  常用：<code>dstat -clmnsygdr</code></li>
</ul>
<h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><p>查看网络接口状态：<code>ifconfig</code></p>
<ul>
<li>  参数-a：显示全部的接口，包括未启用的接口</li>
</ul>
<p>配置网络接口：<code>ifconfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># eth0上的以太网卡的IP地址修改为192.168.0.125，<br>ifconfig eth0 192.168.0.125<br><br># 为了运行某种类型的网络数据包嗅探工具（如强大的Ethereal），<br># 需要首先将网卡设置为混杂（promiscuous）模式。<br>ifconfig eth0 promisc<br><br># 关闭混杂模式<br>ifconfig eth0 -promisc<br><br># 修改［或“欺骗（spoff）”］网络设备的硬件MAC地址<br># 修改MAC地址时要小心，因为万一出错，就可能与其他网络设备发生冲突，引发问题<br># 首先一定要用ifconfig获得设备的默认MAC地址，以便以后可以把默认的MAC地址再修改回来<br>ifconfig eth0 hw ether 00:14:CC:00:1A:00<br></code></pre></td></tr></table></figure>

<p>查看无线网络接口的状态：<code>iwconfig</code>，可以尽可能多地得到与无线网卡相关的数据</p>
<p>配置无线网络接口：<code>iwconfig</code></p>
<p>验证计算机能否联网：<code>ping</code>，发送ICMP消息</p>
<ul>
<li>  参数-c：指定发送次数</li>
</ul>
<p>追踪路由：<code>traceroute</code>，默认路由跳数为30</p>
<ul>
<li>  参数-m：设置路由跳数</li>
</ul>
<p>执行DNS查询：<code>host</code></p>
<ul>
<li>  <code>host [域名]</code>：查域名关联的IP地址</li>
<li>  <code>host [IP]</code>：查IP地址关联的域名</li>
</ul>
<p>使用DHCP获得新的网络地址：<code>dhclient</code></p>
<ul>
<li>  手动发起DHCP请求：<code>dhclient eth0</code></li>
<li>  释放（或放弃）DHCP服务器分配的IP地址：<code>dhclient -r eth0</code></li>
</ul>
<p>启动网络连接：<code>ifup [interface]</code></p>
<ul>
<li>  也可以使用<code>ifconfig [interface] up</code>或<code>iwconfig [interface] up</code>启动有线或无线网络连接</li>
</ul>
<p>关闭网络连接：<code>ifdown [interface]</code></p>
<ul>
<li>  也可以使用<code>ifconfig [interface] down</code>或<code>iwconfig [interface] down</code>关闭有线或无线网络连接。</li>
</ul>
<p>显示IP路由表、修改IP路由表：<code>route</code></p>
<h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><p>ss是Socket Statistics的缩写。顾名思义，ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p>
<p>当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。 </p>
<p> ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。 </p>
<p>使用方式：</p>
<ul>
<li>  <code>ss [选项]</code></li>
<li>  <code>ss [选项] [过滤条件]</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-h, --help           this message<br>-V, --version        output version information<br>-n, --numeric        don&#x27;t resolve service names<br>-r, --resolve       	resolve host names<br>-a, --all            display all sockets<br>-l, --listening      display listening socket<br>-o, --options       	show timer information<br>-e, --extended     	show detailed socket information<br>-m, --memory        	show socket memory usage<br>-p, --processes      show process using socket<br>-i, --info           show internal TCP information<br>-s, --summary        show socket usage summary<br> <br>-4, --ipv4          	display only IP version 4 sockets<br>-6, --ipv6          	display only IP version 6 sockets<br>-0, --packet display PACKET sockets<br>-t, --tcp            display only TCP sockets<br>-u, --udp            display only UDP sockets<br>-d, --dccp           display only DCCP sockets<br>-w, --raw            display only RAW sockets<br>-x, --unix           display only Unix domain sockets<br>-f, --family=FAMILY 	display sockets of type FAMILY<br> <br>-A, --query=QUERY, --socket=QUERY<br>    QUERY := &#123;all|inet|tcp|udp|raw|unix|packet|netlink&#125;[,QUERY]<br> <br>-D, --diag=FILE      Dump raw information about TCP sockets to FILE<br>-F, --filter=FILE   	read filter information from FILE<br>    FILTER := [ state TCP-STATE ] [ EXPRESSION ]<br></code></pre></td></tr></table></figure>

<p>常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示所有TCP socket</span><br>ss -t -a<br><span class="hljs-comment"># 显示所有UDP socket</span><br>ss -u -a<br><span class="hljs-comment"># 列出所有打开的网络连接端口</span><br>ss -l<br><span class="hljs-comment"># 显示每个进程打开的socket</span><br>ss -pl<br><span class="hljs-comment"># 显示所有已建立的SMTP连接</span><br>ss -o state established <span class="hljs-string">&#x27;( dport = :smtp or sport = :smtp )&#x27;</span><br><span class="hljs-comment"># 显示所有已建立的HTTP连接</span><br>ss -o state established <span class="hljs-string">&#x27;( dport = :http or sport = :http )&#x27;</span><br><span class="hljs-comment"># 找出所有连接X服务器的进程</span><br>ss -X src /tmp/.X11-unix/*<br><span class="hljs-comment"># 列出当前socket(已连接、关闭、等待)详细信息</span><br>ss -s<br></code></pre></td></tr></table></figure>

<p>ss常用的state状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">established<br>syn-sent<br>syn-recv<br>fin-wait-1<br>fin-wait-2<br>time-wait<br>closed<br>close-wait<br>last-ack<br>listen<br>closing<br>all : All of the above states<br>connected : All the states except for listen and closed<br>synchronized : All the connected states except for syn-sent<br>bucket : Show states, which are maintained as minisockets, i.e. time-wait and syn-recv.<br>big : Opposite to bucket state.<br></code></pre></td></tr></table></figure>

<p>ss使用IP地址筛选：<code>ss src ADDRESS_PATTERN</code></p>
<ul>
<li><p>  src：表示来源</p>
</li>
<li><p>  ADDRESS_PATTERN：表示地址规则</p>
</li>
<li><p>示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出来之20.33.31.1的连接</span><br>ss src 120.33.31.1<br><span class="hljs-comment"># 列出来至120.33.31.1,80端口的连接</span><br>ss src 120.33.31.1:http<br>ss src 120.33.31.1:80<br></code></pre></td></tr></table></figure></li>
</ul>
<p>ss使用端口筛选：<code>ss (dport | sport) OP PORT</code></p>
<ul>
<li><p>OP：运算符</p>
<ul>
<li>  <code>&lt;=</code> or <code>le</code>：小于等于</li>
<li>  <code>&gt;=</code> or <code>ge</code>：大于等于</li>
<li>  <code>==</code> or <code>eq</code>：等于</li>
<li>  <code>!=</code> or <code>ne</code>：不等于</li>
<li>  <code>&lt;</code>   or <code>lt</code>：小于</li>
<li>  <code>&gt;</code>   or <code>gt</code>：大于</li>
</ul>
</li>
<li><p>  PORT：端口</p>
</li>
<li><p>过滤端口</p>
<ul>
<li>  <code>dport</code>：过滤目标端口</li>
<li>  <code>sport</code>：过滤源端口</li>
</ul>
</li>
<li><p>示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ss sport = :http 也可以是 ss sport = :80<br>ss dport = :http<br>ss dport \&gt; :1024<br>ss sport \&gt; :1024<br>ss sport \&lt; :32000<br>ss sport eq :22<br>ss dport != :22<br>ss state connected sport = :http<br>ss \( sport = :http or sport = :https \)<br>ss -o state fin-wait-1 \( sport = :http or sport = :https \) dst 192.168.1/24<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>  为什么ss比netstat快?<br>  netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多</p>
</blockquote>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>添加用户：<code>useradd -m [username] -s [/bin/bash]</code></p>
<p>设置密码：<code>passwd [username]</code></p>
<p>删除用户：<code>userdel [username]</code></p>
<ul>
<li>  参数-r，删除用户并删除用户信息</li>
</ul>
<p>切换用户：<code>su [username]</code></p>
<ul>
<li>  <code>su -l [uwername]</code>变更到其他用户，包括其环境变量</li>
<li>  <code>su</code>：变更到root用户</li>
<li>  <code>su -</code>：变更到root用户，包括其环境变量</li>
</ul>
<p>查看当前用户所属组：<code>groups</code></p>
<p>将用户添加到组：<code>usermod -G [groupname] [username]</code></p>
<p>变更用户所在组：<code>usermod -g [groupname] [username]</code>，添加到新组，从旧组中删除</p>
<p>查看所有用户及权限：<code>less /etc/passwd</code></p>
<p>查看所有用户组及权限：<code>less /etc/group</code></p>
<p>修改文件或目录属于的用户组：<code>chgrp</code></p>
<ul>
<li>  修改文件：<code>chgrp [用户组名称/ID] 文件</code></li>
<li>  递归修改目录：<code>chgrp -R [用户组名称/ID] 文件</code></li>
<li>  参数-v：执行时显示执行过程</li>
<li>  参数-c：只显示修改过的内容</li>
</ul>
<p>同时修改文件和目录的拥有者和用户组：<code>chown owner:group</code>，甚至可以省略owner实现修改用户组，被修改的文件或目录有<code>:</code>则使用反斜杠转义。</p>
<ul>
<li>  参数-R：递归修改</li>
</ul>
<p>更改文件和目录的权限：<code>chmod [userMark](+|-|=)[PermissionsMark]</code></p>
<ul>
<li><code>userMark</code>取值：<ul>
<li>  u：拥有者</li>
<li>  g：拥有者所在组<strong>之内</strong>的其它用户</li>
<li>  o：拥有者所在组<strong>之外</strong>的其它用户</li>
<li>  a：所有用户</li>
</ul>
</li>
<li><code>PermissionsMark</code>取值：<ul>
<li>  r：读，4</li>
<li>  w：写，2</li>
<li>  x：执行，1</li>
</ul>
</li>
<li>  参数-R：递归修改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">chmod a+x main         对所有用户给文件main增加可执行权限<br>chmod g+w blogs        对组用户给文件blogs增加可写权限<br>chmod o= <span class="hljs-built_in">test</span>		   删除系统中所有其他用户的所有权限<br><span class="hljs-comment"># 数字方式</span><br>chmod 740 main     将main的用户权限设置为rwxr-----<br><br><span class="hljs-comment"># 更改文件拥有者</span><br>chown username dirOrFile<br><span class="hljs-comment"># 更改目录拥有者（-R选项递归更改）</span><br>chown -R weber server/<br></code></pre></td></tr></table></figure>

<blockquote>
<p>   可以对文件或目录使用chmod 000，但是那样的话，唯一能 够对它进行任何操作或再使用chmod命令修改权限的用户就只有 root了。</p>
</blockquote>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Bash快捷操作:</p>
<ul>
<li>  <code>C-u</code>：删除光标到行首的所有字符，在某些设置下，删除全行</li>
<li>  <code>C-w</code>：删除当前光标到前边的最近一个空格之间的字符（保留空格后面的字符）</li>
<li>  <code>C-H</code>：删除光标前边的字符，相当于退格键</li>
</ul>
<p>用户环境信息配置文件，保存于用户主目录：</p>
<ul>
<li>  <code>.bashrc</code>：用于交互式<code>non-loginshell</code></li>
<li>  <code>.profile</code>：用于交互式<code>login shell</code></li>
</ul>
<blockquote>
<p>  <code>~/.profile</code>与<code>~/.bashrc</code>的区别:</p>
<ul>
<li>  这两者都具有个性化定制功能</li>
<li>  <code>~/.profile</code>可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次</li>
<li>  <code>~/.bashrc</code>也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次</li>
</ul>
</blockquote>
<p>系统全局环境信息配置文件，保存于<code>/etc</code>目录：</p>
<ul>
<li>  <code>/etc/profile</code></li>
<li>  <code>/etc/bashrc</code></li>
</ul>
<blockquote>
<p>  当登入系统获得一个shell进程时，其读取环境设置脚本分为三步:</p>
<ol>
<li> 首先读入的是全局环境变量设置文件<code>/etc/profile</code>，然后根据其内容读取额外的文档，如<code>/etc/profile.d</code>和<code>/etc/inputrc</code></li>
<li> 读取当前登录用户Home目录下的文件<code>~/.bash_profile</code>，其次读取<code>~/.bash_login</code>，最后读取<code>~/.profile</code>，这三个文档设定基本上是一样的，读取有优先关系</li>
<li> 读取<code>~/.bashrc</code></li>
</ol>
</blockquote>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>查看Linux系统版本：</p>
<ul>
<li>  <code>uname -a</code></li>
<li>  <code>lsb_release -a</code>，等价于<code>more /etc/lsb-release</code></li>
<li>  <code>more /etc/os-release</code></li>
</ul>
<p>查看CPU信息：<code>cat /proc/cpuinfo</code></p>
<p>查看CPU核心：<code>cat /proc/cpuinfo | grep processor | wc -l</code></p>
<p>查看内存信息：<code>cat /proc/meminfo</code></p>
<p>查看架构：<code>arch</code></p>
<p>系统时间：<code>date</code></p>
<ul>
<li>  参数-s，设置系统日期和时间（格式如：2000-12-30 13:02:00）</li>
<li>  格式化输出：<code>date +%Y%m%d.%H%M%S</code></li>
</ul>
<p>设置时区：<code>tzselect</code></p>
<p>将系统时间写入CMOS：<code>clock -w</code></p>
<h2 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h2><p><a target="_blank" rel="noopener" href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html">Linux工具快速教程</a></p>
<blockquote>
<p>  本文命令测试环境：Ubuntu 18.04 x86_64</p>
</blockquote>

	</div>
</div>
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>
<script>
    function setClipboardText(event){
        
        let clipboardData = event.clipboardData || window.clipboardData;
        
        if (!clipboardData) { return; }
        event.preventDefault();
        
        let text = window.getSelection().toString();
		    
        if (text) {
            
            event.preventDefault();
            
            var copyright = '\n\n'
            + '\n作品采用 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议 进行许可'
            + '\n著作权归作者所有，商业转载请联系作者获得授权，非商业转载请注明出处。'
            + '\n作者: modao'
            + '\n邮箱: rustacean@aliyun.com'
            + '\n原文地址: https://modao.site/Linux/Linux%E5%9F%BA%E7%A1%80/'
			
            clipboardData.setData('text/plain', text + copyright);
    
        }
    };
	
    var contents = document.getElementsByClassName("content-area");
   
    contents[0].addEventListener('copy',function(e){
        setClipboardText(e);
    });

</script>
    
  </body>
</html>