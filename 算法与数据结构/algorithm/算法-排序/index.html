<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「工作日还有多少天，休息日还剩几小时」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">基数排序</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		算法-排序
	</div>
	
	<div class="page-date">
		2020-06-14
	</div>
	
	<div class="category-area">
		
			 
				「
				<div class="category">
					<a href="/categories/Algorithm">Algorithm</a>
				
				</div>
				」
			
		
	</div>
	
	<div class="content">
		<p>学习并记录下排序算法，方便回顾。</p>
<span id="more"></span>


<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最差时间复杂度</th>
<th>空间复杂度</th>
<th>数据对象稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>数组不稳定、链表稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(log<sub>2</sub>n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n*log<sup>2</sup>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(k*n)</td>
<td>O(n<sup>2</sup>)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>均按从小到大排列</li>
<li>k：代表数值中的 “数位” 个数</li>
<li>n：代表数据规模</li>
<li>m：代表数据的最大值减最小值</li>
<li>来自：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">wikipedia . 排序算法</a></li>
</ul>
</blockquote>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>N</strong>个元素进行排序，总共需要<strong>N-1</strong>趟排序，第<strong>i</strong>趟需要排序的次数为<strong>N-i</strong>。($1 \leq i \leq N-1$）</p>
<p>思路：</p>
<ol>
<li> 第<strong>i</strong>趟，比较前<strong>N-i-1</strong>个元素，<strong>比较相邻元素</strong></li>
<li> 比较第1个和第2个元素，将值小的放前面，值大的放后面</li>
<li> 比较第2个和第3个元素，……，比较<strong>N-i</strong>次</li>
<li> 每一趟比较都会将最大值放每一趟的最后面，实现将值大的元素冒泡到最后面【第i趟将第i大值存放到倒数第i位】</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//普通冒泡排序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j)&#123;<br>            <span class="hljs-keyword">if</span> (v[j] &gt; v[j + <span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(v[j], v[j + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//优化：当有一趟比较过程中一次交换都没出现，则说明当前已经是有序状态，排序结束</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i)&#123;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j)&#123;<br>            <span class="hljs-keyword">if</span> (v[j] &gt; v[j + <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(v[j], v[j + <span class="hljs-number">1</span>]);<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)<span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//放个参数是数组的</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-keyword">sizeof</span> a / <span class="hljs-keyword">sizeof</span> *a;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j)&#123;<br>            <span class="hljs-keyword">if</span> (v[j] &gt; v[j + <span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(v[j], v[j + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>N</strong>个元素进行排序，总共需要<strong>N-1</strong>次选择，将第<strong>i</strong>次选择的结果作为第<strong>i</strong>个元素。($1 \leq i \leq N-1$）</p>
<p>思路：</p>
<ol>
<li> 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li> 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li>
<li> 以此类推，直到所有元素均排序完毕</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> min_index, len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i)&#123;<br>        min_index = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; ++j)&#123;<br>            <span class="hljs-keyword">if</span>(v[j] &lt; v[min_index])min_index = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i != min_index)<br>            <span class="hljs-built_in">swap</span>(v[i], v[min_index]);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>思路：</p>
<ol>
<li> 从第一个元素开始，该元素可以认定为已经被排序，其他元素均认为未排序</li>
<li>取下未排序的第一个元素a，在已经排序的元素序列中从后向前扫描，将扫描到的已排序元素b与a比较<ol>
<li> a &gt; b，将a元素后移一位，b存于a原来的位置</li>
<li> a &lt;= b，则b已经存放于a后面，不必移位</li>
</ol>
</li>
<li> 重复第2步骤直到全部排序完成</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i)&#123;<br>        <span class="hljs-keyword">int</span> temp = v[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)&#123;<br>            <span class="hljs-keyword">if</span>(v[j] &gt; temp)&#123;<br>                v[j + <span class="hljs-number">1</span>] = v[j];<br>                v[j] = temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>递归的思路：</p>
<ol>
<li> 选取第一个数作为基准</li>
<li> 将比基准小的数交换到前面，比基准大的数交换到后面</li>
<li> 对左右区间重复第2步，直到各个区间只有一个数</li>
</ol>
<p>迭代的思路：</p>
<ol>
<li> 将需要快排的区间压栈</li>
<li>如果栈里的区间不为空，从栈里取出最末尾的区间<ol>
<li> 区间大小为0或1，则不进行快排</li>
<li> 进行快排，产生两个子区间</li>
</ol>
</li>
<li> 将快排结果的两个子区间压栈</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt;= high)	<span class="hljs-comment">//表明数据只有一个元素了，排序完成</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> first = low;<br>    <span class="hljs-keyword">int</span> last = high;<br>    <span class="hljs-keyword">int</span> key = v[first];<br>    <br>    <span class="hljs-keyword">while</span>(first &lt; last)&#123;<br>        <span class="hljs-comment">//从后往前找，将小于基准的移到前面</span><br>        <span class="hljs-keyword">while</span>(first &lt; last &amp;&amp; v[last] &gt;= key)<br>            --last;<br>        <span class="hljs-comment">//判断前面的循环是因为v[last] &gt;= key而退出来的</span><br>        <span class="hljs-keyword">if</span>(first &lt; last)<br>            v[first++] = v[last];<br>        <br>        <span class="hljs-comment">//从前往后找，将大于基准的移到后面</span><br>        <span class="hljs-keyword">while</span>(first &lt; last &amp;&amp; v[first] &lt;= key)<br>            ++first;<br>        <span class="hljs-comment">//判断前面的循环是因为v[first] &lt;= key而退出来的</span><br>        <span class="hljs-keyword">if</span>(first &lt; last)<br>            v[last--] = v[first];<br>    &#125;<br>    <span class="hljs-comment">//将基准归位</span><br>    v[first] = key;<br>    <span class="hljs-comment">//对子区间递归</span><br>    <span class="hljs-built_in">QuickSort</span>(v, low, first - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">QuickSort</span>(v, first + <span class="hljs-number">1</span>, high);<br>&#125;<br><br><span class="hljs-comment">//迭代</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Range</span>&#123;</span><br>    <span class="hljs-keyword">int</span> first, last;<br>    <span class="hljs-built_in">Range</span>(<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>):<span class="hljs-built_in">first</span>(f), <span class="hljs-built_in">last</span>(l)&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt;= high)	<span class="hljs-comment">//表明数据只有一个元素了，排序完成</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len = high - low + <span class="hljs-number">1</span>;<br>    Range r[len];<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    r[p++] = <span class="hljs-built_in">Range</span>(low, high);<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        Range temp = r[--p];<br>        <span class="hljs-keyword">if</span>(temp.first &gt;= temp.last)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> key = v[temp.first];<br>        <span class="hljs-keyword">int</span> left = temp.first, right = temp.last;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; v[right] &gt; key)<br>                --right;<br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; v[left] &lt; key)<br>                ++left;<br>            <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>                <span class="hljs-built_in">swap</span>(v[left], v[right]);<br>                --right;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(v[temp.first] &gt;= v[left])<br>            <span class="hljs-built_in">swap</span>(v[temp.first], v[left]);<br>        <span class="hljs-keyword">else</span><br>            --left;<br>        r[p++] = <span class="hljs-built_in">Range</span>(temp.first, left - <span class="hljs-number">1</span>);<br>        r[p++] = <span class="hljs-built_in">Range</span>(left + <span class="hljs-number">1</span>, temp.last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>最大堆：</p>
<ol>
<li>构建堆<ol>
<li> 从最后一个父节点开始调整，调整为符合规则的堆</li>
<li> 从最后一个父节点递减，将所有父节点从后向前进行调整</li>
<li> 调整到父节点为根节点则调整完毕</li>
</ol>
</li>
<li> 根据堆的特性：根节点存放最大值或最小值。将根节点与堆最后一个元素交换，并将堆的大小减一进行堆适应，重新调整为一个规则的堆</li>
<li> 取出的元素按相反的顺序排列，完成排序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆适应，使堆按规则存放</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AdjustHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, <span class="hljs-keyword">int</span> hole, <span class="hljs-keyword">int</span> len)</span></span>&#123;<br>    <span class="hljs-comment">//const int parent = hole;</span><br>    <span class="hljs-keyword">int</span> value = v[hole];<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span> * hole + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(right &lt; len)&#123;<br>        <span class="hljs-keyword">if</span>(v[right] &lt; v[right<span class="hljs-number">-1</span>])<br>            --right;<br>        <span class="hljs-keyword">if</span>(v[hole] &lt; v[right])&#123;<br>            <span class="hljs-built_in">swap</span>(v[hole], v[right]);<br>            hole = right;<br>            right = <span class="hljs-number">2</span> * hole + <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(right == len)&#123;<br>        <span class="hljs-keyword">if</span>(v[hole] &lt; v[right - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-built_in">swap</span>(v[hole], v[right - <span class="hljs-number">1</span>]);<br>            hole = right - <span class="hljs-number">1</span>;<br>            v[hole] = value;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//构建堆</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MakeHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    cout &lt;&lt; len &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> parent = (len - <span class="hljs-number">2</span>)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-built_in">AdjustHeap</span>(v, parent, len);<br>        <span class="hljs-keyword">if</span>(parent == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br>        parent--;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//堆排序，逐个取出根节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-built_in">swap</span>(v[<span class="hljs-number">0</span>], v[i]);<br>        <span class="hljs-built_in">AdjustHeap</span>(v, <span class="hljs-number">0</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>递归思路：</p>
<ol>
<li> 分解：将n个元素分成2个子序列</li>
<li>解决：对两个子序列进行归并排序，回归后得到两个有序的子序列<ol>
<li> 回归点：begin &gt;= end，即子序列的元素个数为1后，经排序，返回有序的元素个数为2的子序列</li>
</ol>
</li>
<li> 合并：将两个有序的子序列合并，得到有序序列（<strong>有序子序列才可顺利合并</strong>）</li>
</ol>
<p>迭代思路：</p>
<ol>
<li> 通过设置区间，模仿递归到底层再回归的过程，区间大小从小到大，直接合并、回归</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;ans, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(begin &gt;= end)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> len = end - begin;<br>    <span class="hljs-keyword">int</span> mid = (len &gt;&gt; <span class="hljs-number">1</span>) + begin;<br>    <span class="hljs-keyword">int</span> start1 = begin, start2 = mid;<br>    <span class="hljs-built_in">MergeSort</span>(v, ans, start1, mid);<br>    <span class="hljs-built_in">MergeSort</span>(v, ans, start2, end);<br>    <span class="hljs-keyword">int</span> index = begin;<br>    <span class="hljs-keyword">while</span>(start1 &lt; mid &amp;&amp; start2 &lt; end)<br>        ans[index++] = v[start1] &lt; v[start2] ? v[start1++] : v[start2++];<br>    <span class="hljs-keyword">while</span>(start1 &lt; mid)<br>        ans[index++] = v[start1++];<br>    <span class="hljs-keyword">while</span>(start2 &lt; end)<br>        ans[index++] = v[start2++];<br>&#125;<br><span class="hljs-comment">//迭代</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;ans, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = end - begin;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> range = <span class="hljs-number">1</span>; range &lt; len - <span class="hljs-number">1</span>; range &lt;&lt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; start &lt; len - range; start += (<span class="hljs-number">2</span> * range))&#123;<br>            <span class="hljs-keyword">int</span> mid = start + range, end = start + range + range;<br>            <span class="hljs-keyword">int</span> index = start;	<span class="hljs-comment">//使用下标读写ans，必须确保ans初始化大小和v一样</span><br>            <span class="hljs-keyword">int</span> start1 = start, start2 = mid;	<span class="hljs-comment">//[start, end)</span><br>            <span class="hljs-keyword">while</span>(start1 &lt; mid &amp;&amp; start2 &lt; end)<br>                ans[index++] = v[start1] &lt; v[start2] ? v[start1++] : v[start2++];<br>            <span class="hljs-keyword">while</span>(start1 &lt; mid)<br>                ans[index++] = v[start1++];<br>            <span class="hljs-keyword">while</span>(start2 &lt; end)<br>                ans[index++] = v[start2++];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>思路：</p>
<ol>
<li> 按一定步长进行插入排序，步长逐渐减小，最终为1</li>
<li> 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作</li>
<li> 当步长为1时，算法变为插入排序，这就保证了数据一定会被排序</li>
<li> 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，交换不相邻的元素以对数组的局部进行排序，最终用插入排序将局部有序的数组排序。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//wikipedia解法，对其步长计算没理解</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(h &lt; len/<span class="hljs-number">3</span>)<br>        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(h &gt;= <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h; i &lt; length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt;= h &amp;&amp; v[j] &lt; v[j - h]; j -= h)<br>                <span class="hljs-built_in">swap</span>(v[j], v[j - h]);<br>        &#125;<br>        h = h / <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//步长为排序个数折半，步长折半减小，最终必须为1</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> h = len &gt;&gt; <span class="hljs-number">1</span>; h &gt; <span class="hljs-number">0</span>; h &gt;&gt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt;= h &amp;&amp; v[j] &lt; v[j - h]; j -= h)<br>                <span class="hljs-built_in">swap</span>(v[j], v[j - h]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序：统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<p>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。<br>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。<br>计数排序不是比较排序，排序的速度快于任何比较排序算法。<br>时间复杂度为 O（n+k），空间复杂度为 O（n+k）</p>
<p>思路：</p>
<ol>
<li> 找出无序序列v的最大和最小元素</li>
<li> 创建次数数组vCount，对无序序列的元素出现的次数进行统计</li>
<li> 对计数进行累加，从次数数组的头开始，每一项和前一项相加，此时次数数组的值就是该元素在有序数组中的位置</li>
<li> 反向填充有序数组ans，将每个元素i放在ans的<strong>第vCount[i]项</strong>（从1开始算）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CountSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(!len)<span class="hljs-keyword">return</span>;	<span class="hljs-comment">// 确保待排序容器非空</span><br>    <br>    <span class="hljs-comment">// 使用 v 的最大值 + 1 作为计数容器 vCount 的大小</span><br>    <span class="hljs-keyword">int</span> vCountLength = (*<span class="hljs-built_in">max_element</span>(v.begin, v.end)) + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vCount</span><span class="hljs-params">(vCountLength, <span class="hljs-number">0</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 统计每个键值出现的次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        ++vCount[v[i]];<br>    <br>    <span class="hljs-comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vCountLength; i++)<br>        vCount[i] += vCount[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 将键值放到目标位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)	<span class="hljs-comment">// 此处逆序是为了保持相同键值的稳定性</span><br>        ans[--vCount[v[i]]] = v[i];<br>&#125;<br><br><span class="hljs-comment">//优化，待排序数组数量不多，但是数值大:对vCount大小进行精确设置，对v[i]稍加处理后才作为vCount下标</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CountSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(!len)<span class="hljs-keyword">return</span>;	<span class="hljs-comment">// 确保待排序容器非空</span><br>    <br>    <span class="hljs-comment">// 使用 v 的最大值 + 1 作为计数容器 vCount 的大小</span><br>    <span class="hljs-keyword">int</span> max = *<span class="hljs-built_in">max_element</span>(v.begin, v.end);<br>    <span class="hljs-keyword">int</span> min = *<span class="hljs-built_in">min_element</span>(v.begin, b.end);<br>    <span class="hljs-keyword">int</span> vCountLength = max - min + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vCount</span><span class="hljs-params">(vCountLength, <span class="hljs-number">0</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 统计每个键值出现的次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        ++vCount[v[i]-min];<br>    <br>    <span class="hljs-comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vCountLength; i++)<br>        vCount[i] += vCount[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 将键值放到目标位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)	<span class="hljs-comment">// 此处逆序是为了保持相同键值的稳定性</span><br>        ans[--vCount[v[i] - min]] = v[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。<br>思路：</p>
<ol>
<li>设置一个定量的数组当作空桶子</li>
<li>寻访序列，把元素放到对应的桶内的同时执行插入排序，保持桶内元素有序</li>
<li>对每个桶进行合并，前提是桶内有序</li>
<li>将桶内数据倒出来，此时数据已经是排序好的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> in BUCKET_NUM = <span class="hljs-number">10</span>;	<span class="hljs-comment">//假设数据分布在[0，100)之间</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>)</span>:data(i), next(nullptr)&#123;</span>&#125;<br>    ListNode *next;<br>    <span class="hljs-keyword">int</span> data;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">InsertBucket</span><span class="hljs-params">(ListNode *head, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    ListNode temp, <span class="hljs-built_in">new_node</span>(val);<br>    temp.next = head;<br>    ListNode *pre = &amp;temp, *cur = head;<br>    <span class="hljs-keyword">while</span>(!cur &amp;&amp; cur -&gt; data &lt;= val)&#123;<br>        pre = cur;<br>        cur = cur -&gt; next;<br>    &#125;<br>    new_node.next = cur;<br>    pre -&gt; next = &amp;new_node;<br>    <span class="hljs-keyword">return</span> temp.next;<br>&#125;<br><br><span class="hljs-function">ListNode* <span class="hljs-title">MergeBucket</span><span class="hljs-params">(ListNode *head1, ListNode *head2)</span></span>&#123;<br>    ListNode merge;<br>    <span class="hljs-keyword">while</span>(!head1 &amp;&amp; !head2)&#123;<br>        <span class="hljs-keyword">if</span>(head1 -&gt; data &lt;= head2 -&gt; data)&#123;<br>            merge.next = head1;<br>            head1 = head1 -&gt; next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            merge.next = head2;<br>            head2 = head2 -&gt; next;<br>        &#125;<br>        merge = merge.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!head1)merge.next = head1;<br>    <span class="hljs-keyword">if</span>(!head2)merge.next = head2;<br>    <br>    <span class="hljs-keyword">return</span> merge.next;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BucketSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">buckets</span><span class="hljs-params">(BUCKET_NUM, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)&#123;<br>        <span class="hljs-keyword">int</span> index = v[i]/BUCKET_NUM;<br>        ListNode *head = buckets[index];<br>        buciets[index] = <span class="hljs-built_in">InsertBucket</span>(head, v[i]);<br>    &#125;<br>    ListNode *head = buckets[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; BUCKET_NUM; ++i)<br>        head = <span class="hljs-built_in">MergeBucket</span>(head, buckets[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : v)&#123;<br>        i = head -&gt; data;<br>        head = head -&gt; next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span></span>&#123;	<span class="hljs-comment">//计算最大元素的位数</span><br>    <span class="hljs-keyword">int</span> max_bit = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> p  = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(m &gt;= p)&#123;<br>        m /= <span class="hljs-number">10</span>;<br>        ++max_bit;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_bit;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RadixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> max_bit = <span class="hljs-built_in">MaxBit</span>(*<span class="hljs-built_in">max_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()));<br>    <span class="hljs-keyword">int</span> len = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;	<span class="hljs-comment">//存放每次按位排序后的结果</span><br>    <span class="hljs-keyword">int</span> radix = <span class="hljs-number">1</span>;				<span class="hljs-comment">//从右向左数，第1位，按位排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= max_bit; ++i)&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <br>        <span class="hljs-comment">//类似计数排序，按位进行计数排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j)&#123;<br>            ++count[(v[j]/radix) % <span class="hljs-number">10</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; ++j)&#123;<br>            count[j] += count[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span>; --j)&#123;<br>            temp[--count[(v[j]/radix) % <span class="hljs-number">10</span>]] = v[j];<br>        &#125;<br>        v = tmp;<br>        radix *= <span class="hljs-number">10</span>;	<span class="hljs-comment">//对排序的位数进行更新</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>