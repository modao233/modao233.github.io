<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>PL</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/Effective C++/item7-wei-duo-tai-ji-lei-sheng-ming-virtualxi-gou-han-shu/">Item7-为多态基类声明 virtual 析构函数</a></h1><div class=post-meta-inline><span class=post-date> 2021-01-06 </span></div><div class=post-content><p>Item7-为多态基类声明 virtual 析构函数<h2 id=duo-tai-ji-lei-ying-gai-sheng-ming-yi-ge-virtual-xi-gou-han-shu>多态基类应该声明一个 virtual 析构函数</h2><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>TimeKeeper </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>TimeKeeper</span><span style=color:#eff1f5;>();</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>~TimeKeeper</span><span style=color:#eff1f5;>();</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>AtomicClock</span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>TimeKeeper </span><span style=color:#eff1f5;>{ </span><span>... </span><span style=color:#eff1f5;>}</span><span>;	</span><span style=color:#65737e;>//原子钟</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>WaterClock</span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>TimeKeeper </span><span style=color:#eff1f5;>{ </span><span>... </span><span style=color:#eff1f5;>}</span><span>;	</span><span style=color:#65737e;>//水钟</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>WristWatch</span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>TimeKeeper </span><span style=color:#eff1f5;>{ </span><span>... </span><span style=color:#eff1f5;>}</span><span>;	</span><span style=color:#65737e;>//腕表</span><span style=color:#65737e;>
</span><span>
</span><span style=color:#65737e;>//@ 使用时</span><span style=color:#65737e;>
</span><span>TimeKeeper *ptk = </span><span style=color:#bf616a;>getTimeKeeper</span><span>();  </span><span>
</span><span>...                         </span><span>
</span><span style=color:#b48ead;>delete</span><span> ptk;                        </span><span>
</span></code></pre><p>getTimeKeeper() 是一个 factory 函数，返回指针指向一个 TimeKeeper 派生类的动态分配对象，返回的对象位于 heap，因此需要对其返回的对象适当地 delete 掉。<p>C++ 明确指出：当派生类对象经由一个基类指针删除，而该基类指针带有 non-virtual 析构函数，则结果未定义——实际执行时通常发生的是对象的 derived 部分没被销毁，而 base 类部分通常会被销毁，造成一个诡异的“局部销毁”对象，可能造成资源泄漏、败坏数据结构、徒增调试时间。<p>消除这个问题的做法是：给 base 类一个 virtual 析构函数。这样通过基类指针销毁派生类将会符合期望：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>TimeKeeper </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>TimeKeeper</span><span style=color:#eff1f5;>();</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>virtual </span><span style=color:#8fa1b3;>~TimeKeeper</span><span style=color:#eff1f5;>();</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span><span>
</span><span>TimeKeeper *ptk = </span><span style=color:#bf616a;>getTimeKeeper</span><span>();</span><span>
</span><span>...</span><span>
</span><span style=color:#b48ead;>delete</span><span> ptk;  </span><span>
</span></code></pre><p>类似 TimeKeeper 这样的基类一般都包含除了析构函数以外的其它 virtual 函数，因为 virtual 函数的目的就是允许派生类的实现得以定制化。例如，TimeKeeper 可以有一个虚函数 getCurrentTime，它在各种不同的派生类中有不同的实现。<strong>几乎所有拥有虚函数的类差不多都应该有一个虚析构函数。</strong><p>如果一个类不包含虚函数，通常表示它并不意图被用作一个基类。当一个类不打算作为基类时，令其析构函数为 virtual 通常是个馊主意。考虑一个用来表示二维空间中的点的类：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Point </span><span style=color:#eff1f5;>{                           </span><span style=color:#65737e;>//@ a 2D point</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>Point</span><span style=color:#eff1f5;>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>xCoord</span><span style=color:#eff1f5;>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>yCoord</span><span style=color:#eff1f5;>);</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>~Point</span><span style=color:#eff1f5;>();</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>private</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>int</span><span style=color:#eff1f5;> x, y;</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span></code></pre><p>如果一个 int 占用 32 bits，一个 Point object 正好适用于 64-bit 的寄存器。而且，这样一个 Point object 可以被作为一个 64-bit 的量传递给其它语言写的函数，比如 C 或者 FORTRAN。如果 Point 的析构函数被虚拟，情况就完全不一样了。<p>虚函数的实现要求对象携带额外的信息，这些信息用于在运行时确定该对象应该调用哪一个虚函数。这份信息通常由 vptr（virtual table pointer）指针指出，vptr指向一个由函数指针构成的数组，称为 vtbl（virtual table）。每个带有 virtual 函数的类，都有一个相应的 vtbl，当对象调用某一 virtual 函数，实际被调用的函数取决于该对象的 vptr 所指的哪个 vtbl——编译器在其中寻找适当的函数指针。<p>virtual 函数的实现并不重要，重要的是如果 Point class 内含 virtual 函数，其对象的体积会增加：在一个 32-bit 架构中，它们将从 64 bits长到 96 bits（两个 ints 加上 vptr）；在一个 64-bit 架构中，它们可能从 64 bits 长到 128 bits，因为在这样的架构中指针的大小是 64 bits 的。Point 对象不再适合 64-bit 寄存器。而且，对象在 C++ 和其它语言（比如 C）中，看起来不再具有相同的结构，因为它们在其它语言中的对应物没有 vptr。结果，Points 不再可能传入其它语言写成的函数或从其中传出，除非你为 vptr 做出明确的补偿（这属于实现细节），也因此失去可移植性。<p>因此，无故地将所有析构函数声明为 virtual ，就像从未声明它们为 virtual 一样，都是错误的。许多人的心得是：只有当 class 内含至少一个 virtual 函数，才为它声明 virtual 析构函数。<p>标准 string 类型不包含虚拟函数，但是被误导的程序员有时将它当作基类使用：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>SpecialString</span><span style=color:#eff1f5;>: </span><span style=color:#b48ead;>public </span><span style=color:#a3be8c;>std::string </span><span style=color:#eff1f5;>{   </span><span style=color:#65737e;>// bad idea! std::string has a</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  </span><span>...                                       </span><span style=color:#65737e;>// non-virtual destructor</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span></code></pre><p>乍看似乎无害，但如果在程序的某个地方因为某种原因，你将一个指向 SpecialString 的指针转型为一个指向 string 的指针，然后你将 delete 施加于这个指向 string 的指针，就会出现“未定义行为”！<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>SpecialString *pss =   </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>SpecialString</span><span>("</span><span style=color:#a3be8c;>Impending Doom</span><span>");</span><span>
</span><span>std::string *ps;</span><span>
</span><span>...</span><span>
</span><span>ps = pss;   </span><span>
</span><span>...</span><span>
</span><span style=color:#b48ead;>delete</span><span> ps;    	</span><span style=color:#65737e;>//@ undefined! In practice, *ps's SpecialString resources will be leaked, 			  </span><span style=color:#65737e;>
</span><span>				</span><span style=color:#65737e;>//@ because the SpecialString destructor won't be called.</span><span style=color:#65737e;>
</span></code></pre><p>同样的分析适用于任何不带 virtual 析构函数的类，包括全部的 STL 容器类型（例如，vector，list，set，tr1::unordered_map）。<p>一定不要继承一个标准库容器或任何其它“带有 non-virtual 析构函数”的 class。<p>有时候希望有抽象 class，但没有任何 pure virtual 函数，则可以为希望成为抽象的 class 声明一个 pure virtual 析构函数。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>AWOV </span><span style=color:#eff1f5;>{       </span><span style=color:#65737e;>//@ AWOV = "Abstract w/o Virtuals"</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>virtual </span><span style=color:#8fa1b3;>~AWOV</span><span style=color:#eff1f5;>() </span><span>= </span><span style=color:#d08770;>0</span><span style=color:#eff1f5;>;          </span><span style=color:#65737e;>//@ declare pure virtual destructor</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span></code></pre><p>这个类有一个纯虚函数，所以它是抽象的，又因为它有一个虚析构函数，所以不必担心析构函数问题。然而这里有个窍门：你必须为这个纯虚析构函数提供一份定义：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>AWOV::</span><span style=color:#8fa1b3;>~AWOV</span><span>() { } </span><span style=color:#65737e;>// definition of pure virtual dtor</span><span style=color:#65737e;>
</span></code></pre><p>析构函数的运作方式是：最深层派生（most derived）的那个 class 的析构函数最先被调用，然后是其每一个 base class 的析构函数被调用。编译器会在 AWOV 的 derived class 的析构函数中创建一个对<code>~AWOV()</code>的调用动作，所以必须为这个函数提供一份定义，如果没有定义，链接器会报错。<p>“给 base class 一个 virtual 析构函数”这个规则只适用于 polymorphic（带多态性质的）base class，这个 base class 的设计目的是为了用来“通过 base class接口处理 derived class对象”。<p>并非所有 base class 的设计目的都是为了多态用途，如标准 string 和 STL都不被设计为 base class使用，更别提多态了。还有某些 class 的设计目的是作为 base class 使用，但不是为了多态用途。它们都不需要 virtual 析构函数。<h2 id=zong-jie>总结</h2><ul><li>polymorphic（带多态性质的）base class 应该声明一个virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数<li>class 的设计目的如果不是作为 base class使用，或不是为了具备多态性，就不该声明 virtual 析构函数</ul></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>