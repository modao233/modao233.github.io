<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「工作日还有多少天，休息日还剩几小时」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">

</div>

<div class="content-area">
	<div class="title">
		
	</div>
	
	<div class="page-date">
		2021-12-05
	</div>
	
	<div class="category-area">
		
			
		
	</div>
	
	<div class="content">
		<p>Linux发行版本 = 启动引导程序 + 内核 + 驱动 + 应用软件</p>
<p><strong>Linux基本特性：</strong></p>
<ul>
<li><p>单内核（宏内核）：作为一个单独的大过程来实现，所有内核服务运行在一个单独的大内核地址空间。相较微内核而言，具有简单和性能高的特点（直接函数调用，少了IPC的开销）</p>
</li>
<li><p>抢占式</p>
</li>
<li><p>支持多用户、多任务、多线程、多CPU（SMP）</p>
</li>
<li><p>模块化设计，可动态加载内核模块</p>
</li>
<li><p>万物皆文件</p>
</li>
<li><p>Unix基因：借鉴了Unix的许多设计并实现了Unix的API</p>
</li>
</ul>
<p><strong>Linux文件系统：</strong></p>
<ul>
<li>虚拟文件系统(VFS)：对不同的文件系统做一个抽象，提供统一的API访问接口<ul>
<li>嵌入式Linux应用中，主要的存储设备为RAM和FLASH</li>
<li>常用的基于存储设备的文件系统类型包括：jffs2, yaffs, cramfs, ext4, ramdisk, ramfs/tmpfs，procfs等<ul>
<li>ramdisk：将一部分固定大小的内存当作分区来使用。在编译内核时和内核一起打包，作为根文件系统</li>
<li>ramfs/tmpfs：基于内存的文件系统，大小随内容而变</li>
<li>procfs：启动时动态生成的伪文件系统，用于查看和设定内核参数</li>
</ul>
</li>
</ul>
</li>
<li>MTD(Memory Technology Device)：存储技术设备，为底层硬件(Flash)和上层(文件系统)之间提供一个统一的抽象接口。它专门针对各种非易失性存储器(以Flash为主)而设计的，有基于扇区的擦除、读/写操作接口。</li>
</ul>
<p><img src="1925550-20210721230634500-708577461.png"></p>
<p><strong>Linux系统活动空间：</strong></p>
<ul>
<li>内核空间</li>
<li>用户空间</li>
</ul>
<p>32位系统中：</p>
<ul>
<li>高 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用</li>
<li>低 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由用户进程使用</li>
<li>需要硬件系统提供页机制（MMU）管理内存，实现内存映射、内存保护</li>
</ul>
<p>处理器在任何时刻的活动必然为以下三种之一：</p>
<ol>
<li>运行于用户空间，执行用户进程</li>
<li>运行于内核空间，处于进程上下文，代表某个特定进程执行</li>
<li>运行于内核空间，处于中断上下文，处理特定中断</li>
</ol>
<p>内核态&amp;用户态：</p>
<ul>
<li>内核态：当内核运行的时候，系统以内核态进入内核空间执行</li>
<li>用户态：执行一个用户程序时，系统以用户态进入用户空间执行</li>
</ul>
<p><strong>Linux进程：</strong></p>
<ul>
<li>进程是处于执行期的程序（目标码存放在某种存储介质上）以及相关资源（打开的文件句柄、挂起的信号量、内存地址空间、执行线程，以及数据段等）的总称。</li>
<li>每个进程拥有一个唯一的标识符：PID</li>
<li>进程提供两种虚拟机制：虚拟处理器和虚拟内存</li>
<li>init进程：PID为1。所有进程的祖先。在内核启动的最后阶段，由内核线程加载外部程序/sbin/init后拥有了用户态空间，蜕变成为一个用户进程。负责解析执行脚本/etc/inittab，完成系统的启动。</li>
</ul>
<p>进程创建：fork()函数</p>
<ul>
<li>fork()通过clone()实现，但它并没有直接复制所有的资源，而是通过写时拷贝技术来推迟或避免页拷贝。实际开销仅仅是复制进程页表和创建唯一的进程描述符。</li>
<li>fork()系统调用从内核返回两次：一次回到父进程，一次回到新产生的子进程</li>
</ul>
<p>exec()函数：创建新的地址空间，载入新程序</p>
<p>exit()函数：终止进程并将占用的资源释放掉，同时：</p>
<ul>
<li>通知父进程为自己“收尸”</li>
<li>给自己的子进程（如果存在）找一个新的父进程：一个进程退出后，其子进程变成孤儿进程，并由其父进程收养。</li>
</ul>
<p>进程退出执行后，被设置为僵死状态。直至父进程通过wait()这组函数来为其“收尸”：等待子进程退出、接收返回值、释放进程描述符</p>
<p>僵尸进程，ps中显示Z状态的进程，意味着其父进程没有调用wait()对其进行“收尸”。原因通常有两个：</p>
<ul>
<li>父进程编码错误，收到子进程退出信号后没有调用wait()</li>
<li>子进程在主线程中调用pthread_exit()退出主线程，这种情况下，只要线程组中还有其他线程运行，这个进程都不会退出。因而也就不会发退出信号给父进程<ul>
<li>父进程是init的进程也是如此</li>
</ul>
</li>
</ul>
<p>Linux存在进程树，所有的进程都是init进程的后代。</p>
<p>Linux内核没有线程的概念。在内核看来，线程只是一个普通的进程（只是线程和其他一些进程共享某些资源，如文件描述符、地址空间等）。和进程一样，每个线程都拥有唯一隶属于自己的task_sruct。</p>
<p>线程的创建和普通进程的创建类似，也是通过clone()系统调用完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p>而fork()的实现是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">clone(SIGCHLD, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p><strong>Linux进程调度</strong></p>
<p>Linux进程调度的基本单位是线程</p>
<p>进程可以分为两种类型：</p>
<ul>
<li><p>I/O消耗型，Linux更倾向于优先调度I/O消耗型进程。</p>
</li>
<li><p>CPU消耗型</p>
</li>
</ul>
<p>进程优先级：Linux采用了两种不同的优先级范围</p>
<ul>
<li>nice值(-20 ~ 19)： 值越大意味着优先级越低。（普通进程）</li>
<li>实时优先级(0~99)：值越大意味着优先级越高。（实时进程）</li>
</ul>
<p>通过ps命令查看，NI列即为进程的nice值，PR列即为进程的实时优先级<br>实时进程的优先级高于普通进程。所以实时优先级和nice优先级处于互不相交的两个范畴</p>
<p>进程调度策略：</p>
<ul>
<li>SCHED_NORMAL：普通调度策略。基于CFS算法根据nice值对普通级别的进程进行公平调度。（不再有时间片概念，而是根据vruntime变量挑选下个任务）</li>
<li>SCHED_FIFO：实时先入先出调度策略。一旦一个SCHED_FIFO级进程处于可执行状态，就会一直执行。知道它自己受阻塞或显式地释放CPU。只有更高级别的SCHED_FIFO或SCHED_RR级进程任何才能抢占。</li>
<li>SCHED_RR：实时轮流调度策略，相当于带时间片的SCHED_FIFO——当SCHED_RR任务耗尽它的时间片时，同一级别的其他实时进程被轮流调度。</li>
</ul>
<p>进程调度相关API</p>
<ul>
<li>设置调度策略和实时优先级：sched_setscheduler()</li>
<li>获取调度策略和实时优先级：sched_getscheduler()</li>
<li>将指定进程的静态nice值增加一个给定的量。只有超级用户才能在调用它时使用负值：nice()</li>
<li>将指定进程绑定CPU：sched_setaffinity()</li>
<li>显式让出CPU时间：sched_yield()</li>
</ul>
<p>系统调用(syscall)是用户进程和内核交互的接口。应用程序通过这些接口，可以访问硬件设备，申请资源，创建新进层，进行IPC通信等。实际上，提供这些接口主要是为了保证同稳定可靠。</p>
<p>编程实践中，我们一般不是直接使用系统调用接口，而是通过在用户空间封装的API。</p>
<p>原理：用户空间的程序无法直接调用内核空间中的函数。为了实现系统调用，用户程序通过触发异常（软中断）来使系统陷入内核，由内核中的系统调用处理程序system_call来执行相应的系统调用</p>
<p><strong>Linux互斥机制：</strong></p>
<ul>
<li>内核空间<ul>
<li>原子变量&amp;原子操作</li>
<li>自旋锁：在SMP系统用于处理器之间的互斥，适合保护很短的临界区，并且不允许在临界区睡眠。申请自旋锁的时候，如果自旋锁被其他处理器占有，本处理器自旋等待</li>
<li>信号量：本质上，信号量是一个计数器，它用来记录对某个资源（如共享内存）的存取状况。信号量为0时，进程进入睡眠状态，直至信号量值大于0，进程被唤醒</li>
<li>互斥锁：禁止多个线程同时进入受保护的代码“临界区”</li>
<li>原子变量和自旋锁可应用于任何上下文。信号量和互斥锁只能应用于进程上下文</li>
</ul>
</li>
<li>用户空间<ul>
<li>Futex：Fast Userspace Mutex（快速用户空间互斥体）。是一种用户态和内核态混合的同步机制。当进程/线程尝试进入或退出临界区时，会检查futex变量（一个存在特定内存位置（可以是共享内存）的整型变量）。如果竞争没有发生，则只会改变futex变量的值，而无须做wait/wake系统调用，从而大大提高效率。</li>
<li>编程时，一般不会直接使用futex这种基础的接口，而是使用基于futex封装的更高级别的锁抽象，如信号量和互斥锁<ul>
<li>信号量：sem_t sem;</li>
<li>互斥锁：pthread_mutex_t mutex;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Linux安全机制：</strong></p>
<ul>
<li><p>DAC机制</p>
<ul>
<li>自主访问控制（DAC，Discretionary Access Control），基础的传统的Linux权限管理的机制。</li>
<li>DAC模型中，参与的对象有3种：主体(subject)、客体(object)、规则(policy)</li>
<li>文件客体的所有者（或者管理员）负责管理访问控制</li>
<li>DAC简单高效，但权限划分粒度过大</li>
</ul>
</li>
<li><p>Capability机制</p>
<ul>
<li>Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 Capabilites。比如发送信号(kill)CAP_KILL，设置系统时间CAP_SYS_TIME</li>
<li>Capabilites 作为线程的属性存在，每个单元可以独立启用和禁用。</li>
<li>在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作</li>
<li>对DAC机制不足的补充。对root特权进行细粒度的控制，实现按需授权，从而减小系统的安全攻击面。</li>
</ul>
</li>
<li><p>MAC</p>
<ul>
<li>强制访问控制（Mandatory Access Control），SELinux（Security Enhanced Linux）使用的安全策略。在DAC的基础上，把行为、规则、判定结果进一步细分。所以它的权限管理粒度更细，但是开销也稍大</li>
<li>管理员管理访问控制，管理员指定策略，用户不能改变它，任何主体不能改变</li>
<li>MAC可以定义所有的进程（称为主体subject）对系统的其他部分（文件、设备、socket、端口和其它进程等，称为客体object）进行操作的权限或许可</li>
<li>安全上下文由4个部分组成：身份标识(user):角色(role):类型(type):级别(level)<br>主客体间是否可以进行读写，主要在于Type的类型是否匹配，对于主体，它的类型称为domain，域；对于客体，它的类型称为Type，类型</li>
</ul>
</li>
</ul>

	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>