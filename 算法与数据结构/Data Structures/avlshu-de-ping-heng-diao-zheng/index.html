<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/算法与数据结构/Data Structures/avlshu-de-ping-heng-diao-zheng/">AVL树的平衡调整</a></h1><div class=post-meta-inline><span class=post-date> 2018-07-10 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/algorithm/>#Algorithm</a></span><div class=post-content><p>AVL树的全称是平衡搜索二叉树，本质上也是一个二叉搜索树（BST），满足BST树的所有性质。<h2 id=avljian-jie>AVL简介</h2><p>在BST中搜索一个结点的平均时间复杂度是<code>O(lgn)</code>，最坏情况会出现<code>O(n)</code>，即出现连续的左/右子树：<p><img alt=image-20200722110541352 src=image-20200722110541352.png><p>这种情况其实就已经是链式存储，无法将树的优势体现出来。为了避免这种情况，我们就要保证这个树随时都是平衡的。当然要求不能那么严格，不需要保证它完全平衡（每个节点的左右子树高度差的绝对值都为0），AVL树就要求的是只要每个节点的左右子树高度差的绝对值不超过1，就可以称作平衡。<h2 id=avlzi-xuan>AVL自旋</h2><p><strong>平衡因子(BF)</strong>：每个节点的左右子树的高度差的绝对值<p>在AVL树中，插入一个节点之后都会判断是否打破了这个平衡。如果打破了，就需要对树进行调整，让它仍然满足平衡的定义，并且不改变中序遍历的正确性。这步操作就叫做旋转。即，是否需要旋转以及具体的旋转实现都要包含在插入函数里。<p>根据插入的位置不同，旋转的类型也分为4种：LL，LR，RL，RR：<ul><li>左左LL：插入点位于x的左孩子的左子树中，右旋。<li>左右LR：插入点位于x的左孩子的右子树中，较低的先左旋，转换为LL问题，再右旋。<li>右左RL：插入点位于x的右孩子的左子树中，较低的先右旋，转化为RR问题。再左旋。<li>右右RR：插入点威武x的右孩子的右子树中，左旋。</ul><h2 id=zi-xuan-xiang-jie>自旋详解</h2><p>AVL树定义以及前置函数定义：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>typedef struct</span><span> AVLTree</span><span>
</span><span>{</span><span>
</span><span>    </span><span style=color:#b48ead;>int</span><span> height;                </span><span style=color:#65737e;>//当前节点的高度。</span><span style=color:#65737e;>
</span><span>    </span><span style=color:#b48ead;>int</span><span> data;</span><span>
</span><span>    </span><span style=color:#b48ead;>struct</span><span> AVLTree* lchild;</span><span>
</span><span>    </span><span style=color:#b48ead;>struct</span><span> AVLTree* rchild;</span><span>
</span><span>}Tree,*pTree;</span><span>
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>GetHeight</span><span>(pTree </span><span style=color:#bf616a;>tree</span><span>)            </span><span style=color:#65737e;>//获取当前节点的高度。</span><span style=color:#65737e;>
</span><span>{</span><span>
</span><span>    </span><span style=color:#b48ead;>if</span><span>(tree == </span><span style=color:#d08770;>nullptr</span><span>) </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;</span><span>
</span><span>    </span><span style=color:#b48ead;>return</span><span> tree-></span><span style=color:#bf616a;>height</span><span>;</span><span>
</span><span>}</span><span>
</span><span> </span><span>
</span><span style=color:#b48ead;>bool </span><span style=color:#8fa1b3;>IsBalanced</span><span>(pTree </span><span style=color:#bf616a;>tree</span><span>)            </span><span style=color:#65737e;>//判断是否平衡。</span><span style=color:#65737e;>
</span><span>{</span><span>
</span><span>    </span><span style=color:#b48ead;>int</span><span> BF = </span><span style=color:#bf616a;>GetHeight</span><span>(tree-></span><span style=color:#bf616a;>lchild</span><span>) - </span><span style=color:#bf616a;>GetHeight</span><span>(tree-></span><span style=color:#bf616a;>rchild</span><span>);</span><span>
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#96b5b4;>abs</span><span>(BF) < </span><span style=color:#d08770;>2</span><span>;</span><span>
</span><span>}</span><span>
</span><span> </span><span>
</span></code></pre><h3 id=zuo-zuo-ll>左左LL</h3><p>导致失衡的节点node(1)是节点node(3)的左子树的左孩子，即为LL情况。<p><img alt=image-20200722111715724 src=image-20200722111715724.png><p>算法步骤：<ol><li>对于节点node(3)，先取它的左孩子node(2)作为临时节点temp；<li>将temp的右孩子作为node的左孩子；<li>再将node作为temp的右孩子；<li>更新height<li>node = temp。此时，temp就成为了原来node一样的存在。</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>pTree </span><span style=color:#8fa1b3;>Rotate_LL</span><span>(pTree </span><span style=color:#bf616a;>tree</span><span>)</span><span>
</span><span>{</span><span>
</span><span>    pTree temp = tree-></span><span style=color:#bf616a;>lchild</span><span>;</span><span>
</span><span>    tree-></span><span style=color:#bf616a;>lchild </span><span>= temp-></span><span style=color:#bf616a;>rchild</span><span>;</span><span>
</span><span>    temp-></span><span style=color:#bf616a;>rchild </span><span>= tree;</span><span>
</span><span> </span><span>
</span><span>    </span><span style=color:#65737e;>//更新高度,先更新node再更新temp。</span><span style=color:#65737e;>
</span><span>    tree-></span><span style=color:#bf616a;>height </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHeight</span><span>(tree-></span><span style=color:#bf616a;>lchild</span><span>),</span><span style=color:#bf616a;>GetHeight</span><span>(tree-></span><span style=color:#bf616a;>rchild</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span>    temp-></span><span style=color:#bf616a;>height </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHeight</span><span>(temp-></span><span style=color:#bf616a;>lchild</span><span>),</span><span style=color:#bf616a;>GetHeight</span><span>(temp-></span><span style=color:#bf616a;>rchild</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span> </span><span>
</span><span>    </span><span style=color:#b48ead;>return</span><span> temp;</span><span>
</span><span>}</span><span>
</span></code></pre><p>调整结果：<p><img alt=image-20200722111910017 src=image-20200722111910017.png><h3 id=you-you-rr>右右RR</h3><p>RR型由于和LL型是对称的，所以只需要将LL中的所有左右互换就可以了。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>pTree </span><span style=color:#8fa1b3;>Rotate_RR</span><span>(pTree </span><span style=color:#bf616a;>tree</span><span>)</span><span>
</span><span>{</span><span>
</span><span>    pTree temp = tree-></span><span style=color:#bf616a;>rchild</span><span>;</span><span>
</span><span>    tree-></span><span style=color:#bf616a;>rchild </span><span>= temp-></span><span style=color:#bf616a;>lchild</span><span>;</span><span>
</span><span>    temp-></span><span style=color:#bf616a;>lchild </span><span>= tree;</span><span>
</span><span> </span><span>
</span><span>    </span><span style=color:#65737e;>//更新高度,先更新node再更新temp。</span><span style=color:#65737e;>
</span><span>    tree-></span><span style=color:#bf616a;>height </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHeight</span><span>(tree-></span><span style=color:#bf616a;>lchild</span><span>),</span><span style=color:#bf616a;>GetHeight</span><span>(tree-></span><span style=color:#bf616a;>rchild</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span>    temp-></span><span style=color:#bf616a;>height </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHeight</span><span>(temp-></span><span style=color:#bf616a;>lchild</span><span>),</span><span style=color:#bf616a;>GetHeight</span><span>(temp-></span><span style=color:#bf616a;>rchild</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span> </span><span>
</span><span>    </span><span style=color:#b48ead;>return</span><span> temp;</span><span>
</span><span>}</span><span>
</span></code></pre><h3 id=zuo-you-lr>左右LR</h3><p>引起失衡的是node节点的左子树的右孩子。<p><img alt=image-20200722113201966 src=image-20200722113201966.png><p>在节点值为4的节点插入5，是4的右孩子。此时已经失衡。即为LR问题。<p>算法步骤：<ol><li><p>先获取node（值为10的节点）的左孩子节点，记为temp。</p><li><p>对temp进行RR。</p><li><p>对node进行LL。</p></ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>pTree </span><span style=color:#8fa1b3;>Rotate_LR</span><span>(pTree </span><span style=color:#bf616a;>tree</span><span>)</span><span>
</span><span>{</span><span>
</span><span>    pTree temp = tree-></span><span style=color:#bf616a;>lchild</span><span>;</span><span>
</span><span>    tree-></span><span style=color:#bf616a;>lchild </span><span>= </span><span style=color:#bf616a;>Rotate_RR</span><span>(temp);</span><span>
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>Rotate_LL</span><span>(tree);</span><span>
</span><span>}</span><span>
</span></code></pre><h3 id=you-zuo-rl>右左RL</h3><p>RL型由于和LR型是对称的，所以只需要将LR中的所有左右互换就可以了。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>pTree </span><span style=color:#8fa1b3;>Rotate_RL</span><span>(pTree </span><span style=color:#bf616a;>tree</span><span>)</span><span>
</span><span>{</span><span>
</span><span>    pTree temp = tree-></span><span style=color:#bf616a;>rchild</span><span>;</span><span>
</span><span>    tree-></span><span style=color:#bf616a;>rchild </span><span>= </span><span style=color:#bf616a;>Rotate_LL</span><span>(temp);</span><span>
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>Rotate_RR</span><span>(tree);</span><span>
</span><span>}</span><span>
</span></code></pre><h2 id=zong-ti-dai-ma>总体代码</h2><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>#include</span><span><</span><span style=color:#a3be8c;>iostream</span><span>></span><span>
</span><span style=color:#b48ead;>#include</span><span><</span><span style=color:#a3be8c;>cstdio</span><span>></span><span>
</span><span style=color:#b48ead;>#include</span><span><</span><span style=color:#a3be8c;>stack</span><span>></span><span>
</span><span style=color:#b48ead;>using namespace</span><span> std;</span><span>
</span><span style=color:#b48ead;>typedef struct</span><span> AVLNode *position;</span><span>
</span><span style=color:#b48ead;>typedef</span><span> position AVLTree;</span><span>
</span><span style=color:#b48ead;>struct </span><span>AVLNode{</span><span>
</span><span>	</span><span style=color:#b48ead;>int</span><span> data;</span><span>
</span><span>	AVLTree left;</span><span>
</span><span>	AVLTree right;</span><span>
</span><span>	</span><span style=color:#b48ead;>int</span><span> h;</span><span>
</span><span>};</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>GetHight</span><span>(AVLTree </span><span style=color:#bf616a;>A</span><span>){</span><span>
</span><span>	</span><span style=color:#b48ead;>if</span><span>(A == </span><span style=color:#d08770;>NULL</span><span>)	</span><span style=color:#b48ead;>return </span><span>-</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span>	</span><span style=color:#b48ead;>return</span><span> A-></span><span style=color:#bf616a;>h</span><span>;</span><span>
</span><span>}</span><span>
</span><span style=color:#65737e;>//左单旋</span><span style=color:#65737e;>
</span><span>AVLTree </span><span style=color:#8fa1b3;>SLR</span><span>(AVLTree </span><span style=color:#bf616a;>A</span><span>){</span><span>
</span><span>	AVLTree B = A-></span><span style=color:#bf616a;>left</span><span>;</span><span>
</span><span>	A-></span><span style=color:#bf616a;>left </span><span>= B-></span><span style=color:#bf616a;>right</span><span>;</span><span>
</span><span>	B-></span><span style=color:#bf616a;>right </span><span>= A;</span><span>
</span><span>	A-></span><span style=color:#bf616a;>h </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHight</span><span>(A-></span><span style=color:#bf616a;>left</span><span>),</span><span style=color:#bf616a;>GetHight</span><span>(A-></span><span style=color:#bf616a;>right</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span>	B-></span><span style=color:#bf616a;>h </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHight</span><span>(B-></span><span style=color:#bf616a;>left</span><span>),</span><span style=color:#bf616a;>GetHight</span><span>(B-></span><span style=color:#bf616a;>right</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span>	</span><span style=color:#b48ead;>return</span><span> B;</span><span>
</span><span>} </span><span>
</span><span style=color:#65737e;>//右单旋</span><span style=color:#65737e;>
</span><span>AVLTree </span><span style=color:#8fa1b3;>SRR</span><span>(AVLTree </span><span style=color:#bf616a;>A</span><span>){</span><span>
</span><span>	AVLTree B = A-></span><span style=color:#bf616a;>right</span><span>;</span><span>
</span><span>	A-> </span><span style=color:#bf616a;>right </span><span>= B-></span><span style=color:#bf616a;>left</span><span>;</span><span>
</span><span>	B-></span><span style=color:#bf616a;>left </span><span>= A;</span><span>
</span><span>	A-></span><span style=color:#bf616a;>h </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHight</span><span>(A-></span><span style=color:#bf616a;>left</span><span>),</span><span style=color:#bf616a;>GetHight</span><span>(A-></span><span style=color:#bf616a;>right</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span>	B-></span><span style=color:#bf616a;>h </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHight</span><span>(B-></span><span style=color:#bf616a;>left</span><span>),</span><span style=color:#bf616a;>GetHight</span><span>(B-></span><span style=color:#bf616a;>right</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span>	</span><span style=color:#b48ead;>return</span><span> B;</span><span>
</span><span>}</span><span>
</span><span style=color:#65737e;>//左右双旋</span><span style=color:#65737e;>
</span><span>AVLTree </span><span style=color:#8fa1b3;>DLRR</span><span>(AVLTree </span><span style=color:#bf616a;>A</span><span>){</span><span>
</span><span>	AVLTree B = A-></span><span style=color:#bf616a;>left</span><span>;</span><span>
</span><span>	A-></span><span style=color:#bf616a;>left </span><span>= </span><span style=color:#bf616a;>SRR</span><span>(B);</span><span>
</span><span>	</span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>SLR</span><span>(A);</span><span>
</span><span>}</span><span>
</span><span style=color:#65737e;>//右左双旋 </span><span style=color:#65737e;>
</span><span>AVLTree </span><span style=color:#8fa1b3;>DRLR</span><span>(AVLTree </span><span style=color:#bf616a;>A</span><span>){</span><span>
</span><span>	AVLTree B = A-></span><span style=color:#bf616a;>right</span><span>;</span><span>
</span><span>	A-></span><span style=color:#bf616a;>right </span><span>= </span><span style=color:#bf616a;>SLR</span><span>(B);</span><span>
</span><span>	</span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>SRR</span><span>(A);</span><span>
</span><span>}</span><span>
</span><span>AVLTree </span><span style=color:#8fa1b3;>Insert</span><span>(AVLTree </span><span style=color:#bf616a;>T</span><span>,</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>x</span><span>){</span><span>
</span><span>	</span><span style=color:#b48ead;>if</span><span>(T == </span><span style=color:#d08770;>NULL</span><span>){</span><span>
</span><span>		T = </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>AVLNode</span><span>();</span><span>
</span><span>		T-></span><span style=color:#bf616a;>data </span><span>= x;</span><span>
</span><span>		T-></span><span style=color:#bf616a;>left </span><span>= </span><span style=color:#d08770;>NULL</span><span>;</span><span>
</span><span>		T-></span><span style=color:#bf616a;>right </span><span>= </span><span style=color:#d08770;>NULL</span><span>;</span><span>
</span><span>		T-></span><span style=color:#bf616a;>h </span><span>= </span><span style=color:#d08770;>0</span><span>;</span><span>
</span><span>	}</span><span style=color:#b48ead;>else if</span><span>(x < T-></span><span style=color:#bf616a;>data</span><span>){</span><span>
</span><span>		T-></span><span style=color:#bf616a;>left </span><span>= </span><span style=color:#bf616a;>Insert</span><span>(T-></span><span style=color:#bf616a;>left</span><span>,x);</span><span>
</span><span>		</span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#bf616a;>GetHight</span><span>(T-></span><span style=color:#bf616a;>left</span><span>) - </span><span style=color:#bf616a;>GetHight</span><span>(T-></span><span style=color:#bf616a;>right</span><span>) == </span><span style=color:#d08770;>2</span><span>)</span><span>
</span><span>			</span><span style=color:#b48ead;>if</span><span>(x < T-></span><span style=color:#bf616a;>left</span><span>-></span><span style=color:#bf616a;>data</span><span>)	T = </span><span style=color:#bf616a;>SLR</span><span>(T);</span><span>
</span><span>			</span><span style=color:#b48ead;>else</span><span> T = </span><span style=color:#bf616a;>DLRR</span><span>(T);</span><span>
</span><span>	}</span><span style=color:#b48ead;>else if</span><span>(x > T-></span><span style=color:#bf616a;>data</span><span>){</span><span>
</span><span>		T-></span><span style=color:#bf616a;>right </span><span>= </span><span style=color:#bf616a;>Insert</span><span>(T-></span><span style=color:#bf616a;>right</span><span>,x);</span><span>
</span><span>		</span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#bf616a;>GetHight</span><span>(T-></span><span style=color:#bf616a;>left</span><span>)-</span><span style=color:#bf616a;>GetHight</span><span>(T-></span><span style=color:#bf616a;>right</span><span>) == -</span><span style=color:#d08770;>2</span><span>)</span><span>
</span><span>			</span><span style=color:#b48ead;>if</span><span>(x > T-></span><span style=color:#bf616a;>right</span><span>-></span><span style=color:#bf616a;>data</span><span>)	T = </span><span style=color:#bf616a;>SRR</span><span>(T);</span><span>
</span><span>			</span><span style=color:#b48ead;>else</span><span>	T = </span><span style=color:#bf616a;>DRLR</span><span>(T);</span><span>
</span><span>	}</span><span>
</span><span>	T-></span><span style=color:#bf616a;>h </span><span>= </span><span style=color:#bf616a;>max</span><span>(</span><span style=color:#bf616a;>GetHight</span><span>(T-></span><span style=color:#bf616a;>left</span><span>),</span><span style=color:#bf616a;>GetHight</span><span>(T-></span><span style=color:#bf616a;>right</span><span>))+</span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span>	</span><span style=color:#b48ead;>return</span><span> T;</span><span>
</span><span>}</span><span>
</span></code></pre><h2 id=can-kao-wen-zhang>参考文章</h2><p><a href=https://blog.csdn.net/czc1997/article/details/82846830>数据结构：AVL树的平衡调整——LL，LR，RL，RR</a><p><a href=https://blog.csdn.net/weixin_41162823/article/details/82466517>AVL树的调整（笔记）</a></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>