<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「生活可以更简单, 欢迎来到我的开源世界」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E6%A8%A1%E5%9E%8B"><span class="toc-text">I&#x2F;O模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E5%A4%8D%E7%94%A8"><span class="toc-text">I&#x2F;O复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E5%A4%8D%E7%94%A8-select"><span class="toc-text">I&#x2F;O复用-select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E5%A4%8D%E7%94%A8-poll"><span class="toc-text">I&#x2F;O复用-poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E5%A4%8D%E7%94%A8-epoll"><span class="toc-text">I&#x2F;O复用-epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-create"><span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-ctl"><span class="toc-text">epoll_ctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-wait"><span class="toc-text">epoll_wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E9%80%9A%E7%9F%A5%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%88%91%E4%BB%AC%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">不同的通知模型如何影响我们的程序设计？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6epoll%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-text">深入探究epoll的语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-text">优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-poll-epoll"><span class="toc-text">select&#x2F;poll&#x2F;epoll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ET%E3%80%81LT%E3%80%81EPOLLONESHOT"><span class="toc-text">ET、LT、EPOLLONESHOT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		网络编程-IO复用
	</div>
	
	<div class="page-date">
		2021-03-03
	</div>
	
	<div class="category-area">
		
			 
				「
				<div class="category">
					<a href="/categories/UNP">UNP</a>
				
				</div>
				」
			
		
	</div>
	
	<div class="content">
		<p>网络编程-IO复用</p>
<span id="more"></span>

<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>Unix下可用的I/O模型有五种：</p>
<ul>
<li>  阻塞式I/O</li>
<li>  非阻塞式I/O</li>
<li>  I/O复用（select和poll、epoll）</li>
<li>  信号驱动式I/O（SIGIO）</li>
<li>  异步I/O（POSIX的aio_系列函数）</li>
</ul>
<blockquote>
<p>  详见Unix网络编程卷一第六章</p>
</blockquote>
<h2 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h2><p>select()和poll()在Unix系统中存在时间长，主要优势在于可移植性，主要缺点在于当同时检查大量的文件描述符时性能拓展性不佳。</p>
<p>epoll API的关键优势在于能让应用高效地检查大量的文件描述符，主要缺点是专属于Linux系统的API。</p>
<p><img src="image-20210125175611142.png" alt="image-20210125175611142"></p>
<h3 id="I-O复用-select"><a href="#I-O复用-select" class="headerlink" title="I/O复用-select"></a>I/O复用-select</h3><p>select()首次出现在BSD系统的套接字API中。</p>
<p>select()系统调用的用途：在一段指定的时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。</p>
<p>系统调用select()会一直阻塞，直到一个或多个文件描述符集合成为就绪态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-comment">//若有就绪描述符则返回其数目，若超时则返回0，若出错则返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, </span></span><br><span class="hljs-params"><span class="hljs-function">           fd_set *exceptset, <span class="hljs-keyword">const</span> struct timeval *timeout)</span></span>;<br></code></pre></td></tr></table></figure>

<p><strong>探究下fd_set的结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*typesizes.h*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __FD_SETSIZE		1024</span><br><br><span class="hljs-comment">/*select.h*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __fd_mask;<br><br><span class="hljs-comment">//long int类型共有多少bits</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NFDBITS	(8 * (int) sizeof (__fd_mask))</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//long int型数组，数组大小 = 描述符最大数 / long int的位数</span><br>    <span class="hljs-comment">//数组大小为 __FD_SETSIZE bits</span><br>    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];<br>&#125; fd_set;<br></code></pre></td></tr></table></figure>

<p><strong>select()程序示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usageError</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* progName)</span></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &#123;timeout | -&#125; fd-num[rw]...\n&quot;</span>, progName);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;    - means infinite timeout; \n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;    r = monitor for read\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;    w = monitor for wirite\n\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;    e.g.: %s - 0rw 1w\n&quot;</span>, progName);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cmdLineErr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>    va_list argList;<br><br>    fflush(<span class="hljs-built_in">stdout</span>);           <span class="hljs-comment">/* Flush any pending stdout */</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Command-line usage error: &quot;</span>);<br>    va_start(argList, format);<br>    <span class="hljs-built_in">vfprintf</span>(<span class="hljs-built_in">stderr</span>, format, argList);<br>    va_end(argList);<br><br>    fflush(<span class="hljs-built_in">stderr</span>);           <span class="hljs-comment">/* In case stderr is not line-buffered */</span><br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    fd_set readfds, writefds;<br>    <span class="hljs-keyword">int</span> ready, nfds, fd, numRead, j;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> *<span class="hljs-title">pto</span>;</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span> || <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;--help&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>        usageError(argv[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>        pto = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        pto = &amp;timeout;<br>        timeout.tv_sec = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>        timeout.tv_usec = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    nfds = <span class="hljs-number">0</span>;<br>    FD_ZERO(&amp;readfds);<br>    FD_ZERO(&amp;writefds);<br><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">2</span>; j &lt; argc; j++)&#123;<br>        numRead = <span class="hljs-built_in">sscanf</span>(argv[j], <span class="hljs-string">&quot;%d%2[rw]&quot;</span>, &amp;fd, buf);<br>        <span class="hljs-keyword">if</span>(numRead != <span class="hljs-number">2</span>)&#123;<br>            usageError(argv[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fd &gt;= FD_SETSIZE)&#123;<br>            cmdLineErr(<span class="hljs-string">&quot;file descriptor exceeds limit (%d)\n&quot;</span>, FD_SETSIZE);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fd &gt;= nfds)&#123;<br>            nfds = fd + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;r&#x27;</span>) != <span class="hljs-literal">NULL</span>)&#123;<br>            FD_SET(fd, &amp;readfds);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;w&#x27;</span>) != <span class="hljs-literal">NULL</span>)&#123;<br>            FD_SET(fd, &amp;writefds);<br>        &#125;<br>    &#125;<br>    ready = select(nfds, &amp;readfds, &amp;writefds, <span class="hljs-literal">NULL</span>, pto);<br>    <span class="hljs-keyword">if</span>(ready == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errExit(select)&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ready = %d\n&quot;</span>, ready);<br>    <span class="hljs-keyword">for</span>(fd = <span class="hljs-number">0</span>; fd &lt; nfds; fd++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: %s%s\n&quot;</span>,fd, FD_ISSET(fd, &amp;readfds) ? <span class="hljs-string">&quot;r&quot;</span> : <span class="hljs-string">&quot;&quot;</span>, <br>        FD_ISSET(fd, &amp;writefds) ? <span class="hljs-string">&quot;w&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pto != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout after select(): %ld.%03ld\n&quot;</span>,<br>               (<span class="hljs-keyword">long</span>) timeout.tv_sec, (<span class="hljs-keyword">long</span>) timeout.tv_usec / <span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>select处理正常数据和带外数据：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_adress port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    bzero(&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = htons(port);<br><br>    <span class="hljs-keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(listenfd &gt;= <span class="hljs-number">0</span>);<br>    ret = bind(listenfd, (struct sockaddr*)&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    assert(ret != <span class="hljs-number">-1</span>);<br>    ret = listen(listenfd, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-keyword">sizeof</span>(client_address);<br>    <span class="hljs-keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);<br>    <span class="hljs-keyword">if</span>(connfd &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error is: %d\n&quot;</span>, errno);<br>        close(listenfd);<br>    &#125;<br><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    fd_set read_fds;<br>    fd_set exception_fds;<br>    FD_ZERO(&amp;read_fds);<br>    FD_ZERO(&amp;exception_fds);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>        FD_SET(connfd, &amp;read_fds);<br>        FD_SET(connfd, &amp;exception_fds);<br>        ret = select(connfd + <span class="hljs-number">1</span>, &amp;read_fds, <span class="hljs-literal">NULL</span>, &amp;exception_fds, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;selection failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(FD_ISSET(connfd, &amp;read_fds))&#123;<br>            ret = recv(connfd, buf, <span class="hljs-keyword">sizeof</span>(buf)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of normal data: %s\n&quot;</span>, ret, buf);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FD_ISSET(connfd, &amp;exception_fds))&#123;<br>            ret = recv(connfd, buf, <span class="hljs-keyword">sizeof</span>(buf)<span class="hljs-number">-1</span>, MSG_OOB);<br>            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of oob data: %s\n&quot;</span>, ret, buf);<br>        &#125;<br>    &#125;<br>    close(connfd);<br>    close(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="I-O复用-poll"><a href="#I-O复用-poll" class="headerlink" title="I/O复用-poll"></a>I/O复用-poll</h3><p>poll函数起源于SVR3，最初局限于流设备，SVR4取消了这种限制，允许poll工作在任何描述符上。</p>
<p>poll提供的功能与select类似，不过在处理流设备时，它能够提供额外的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span>&#123;</span><br>    <span class="hljs-keyword">int</span>		fd;<br>    <span class="hljs-keyword">short</span>	events;	<span class="hljs-comment">//指定要测试的条件</span><br>    <span class="hljs-keyword">short</span>	revents;<span class="hljs-comment">//返回描述符的状态</span><br>&#125;<br><span class="hljs-comment">//若有就绪描述符返回其数目，超时返回0，出错返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(struct pollfd *fdarray, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> nfds, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>  select()同poll()返回正整数的区别：如果一个文件描述符在返回的集合中出现了不止一次，系统调用select()会将同一个文件描述符计数多次。而系统调用poll()返回的是就绪态文件描述符个数，且一个文件描述符只会统计一次，就算在相应的revents字段中设定了多个位掩码也是如此。</p>
</blockquote>
<p><strong>poll示例程序：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usageError</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* progName)</span></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &#123;timeout | -&#125; fd-num[rw]...\n&quot;</span>, progName);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;    - means infinite timeout; \n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;    r = monitor for read\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;    w = monitor for wirite\n\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;    e.g.: %s - 0rw 1w\n&quot;</span>, progName);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> numPipes, j, ready, randPipe, numWrites;<br>    <span class="hljs-keyword">int</span> (*pfds)[<span class="hljs-number">2</span>];<span class="hljs-comment">//指向数组的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> *<span class="hljs-title">pollFd</span>;</span><br><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span> || <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;--help&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s num-pipes [num-writes]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    numPipes = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);<br><br>    pfds = (<span class="hljs-keyword">int</span> (*)[<span class="hljs-number">2</span>])<span class="hljs-built_in">calloc</span>(numPipes, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>]));<br>    <span class="hljs-keyword">if</span>(pfds == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error malloc&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    pollFd = (pollfd*)<span class="hljs-built_in">calloc</span>(numPipes, <span class="hljs-keyword">sizeof</span>(struct pollfd));<br>    <span class="hljs-keyword">if</span>(pollFd == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error malloc&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; numPipes; j++)&#123;<br>        <span class="hljs-keyword">if</span>(pipe(pfds[j]) == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error pipe %d&quot;</span>, j);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    numWrites = (argc &gt; <span class="hljs-number">2</span>) ? strtol(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>) : <span class="hljs-number">1</span>;<br>    srandom((<span class="hljs-keyword">int</span>)time(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; numWrites; j++)&#123;<br>        randPipe = random() % numPipes;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Writing to fd: %3d (read fd: %3d)\n&quot;</span>,<br>                pfds[randPipe][<span class="hljs-number">1</span>], pfds[randPipe][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span> (write(pfds[randPipe][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write %d&quot;</span>, pfds[randPipe][<span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; numPipes; j++)&#123;<br>        pollFd[j].fd = pfds[j][<span class="hljs-number">0</span>];<br>        pollFd[j].events = POLLIN;<br>    &#125;<br><br>    ready = poll(pollFd, numPipes, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(ready == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;poll error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;poll() returned: %d\n&quot;</span>, ready);<br><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; numPipes; j++)&#123;<br>        <span class="hljs-keyword">if</span>(pollFd[j].revents &amp; POLLIN)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Readable: %d %3d\n&quot;</span>, j, pollFd[j].fd);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="I-O复用-epoll"><a href="#I-O复用-epoll" class="headerlink" title="I/O复用-epoll"></a>I/O复用-epoll</h3><p>epoll API由三组系统调用组成;</p>
<ul>
<li>  <code>epoll_create()</code>创建一个epoll实例</li>
<li>  <code>epoll_ctl()</code>操作同epoll实例相关联的兴趣列表</li>
<li>  <code>epoll_wait()</code>返回与epoll相关联的就绪列表中的成员</li>
</ul>
<p>epoll实例：epoll API的核心数据结构，和一个打开的文件描述符相关联。这个文件描述符不用来做IO操作，相反它是内核数据结构的句柄，这些内核数据结构实现了两个目的：</p>
<ul>
<li>  记录兴趣列表</li>
<li>  维护就绪列表</li>
</ul>
<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>;<br></code></pre></td></tr></table></figure>

<p>参数size指定我们想要通过epoll实例来检查的描述符个数，不是上限，只是告知内核应该如何为内部数据结构划分初始大小。</p>
<p>函数返回epoll实例的文件描述符，该文件描述符不需要时需要close()。</p>
<p>当所有与epoll实例相关的文件描述符都被关闭时，实例被销毁，相关资源释放。（多个文件描述符可能引用到相同的epoll实例，这是由于调用了fork()或dup()这样的类似函数所致）。</p>
<blockquote>
<p>  linux2.6.8版以来，size参数被忽略不用。</p>
<p>  linux2.6.27以来，Linux支持一个新的系统调用epoll_create1()：</p>
<ul>
<li>  去掉了无用的参数size</li>
<li>增加了一个可用来修改系统调用行为的flags参数<ul>
<li>  flag目前只支持一个标志：EPOLL_CLOEXEC，使内核在新的文件描述符上启动了执行即关闭（close-on-exec）标志（FD_CLOEXEC)</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">int</span> fd, struct epoll *ev)</span></span>;<br></code></pre></td></tr></table></figure>

<p>成功返回0，失败返回-1并设置errno。</p>
<p>参数fd：指明修改兴趣列表中哪一个文件描述符的设定</p>
<p>参数op：指定需要执行的操作</p>
<ul>
<li>  EPOLL_CTL_ADD：添加</li>
<li>  EPOLL_CTL_MOD：修改</li>
<li>  EPOLL_CTL_DEL：删除</li>
</ul>
<p>参数ev：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span>&#123;</span><br>    <span class="hljs-keyword">uint32_t</span>	 events;<span class="hljs-comment">//epoll事件，位掩码</span><br>    <span class="hljs-keyword">epoll_data_t</span> data;	<span class="hljs-comment">//用户数据 </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>events描述事件类型，其中epoll事件类型有以下几种</p>
<ul>
<li>  EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>  EPOLLOUT：表示对应的文件描述符可以写</li>
<li>  EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>  EPOLLERR：表示对应的文件描述符发生错误</li>
<li>  EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>  EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</li>
<li>  EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span>&#123;</span><br>    <span class="hljs-keyword">void</span>		*ptr;<br>    <span class="hljs-keyword">int</span>			fd;<br>    <span class="hljs-keyword">uint32_t</span>	u32;<br>    <span class="hljs-keyword">uint64_t</span>	u64;<br>&#125;<span class="hljs-keyword">epoll_data_t</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>  结构体epoll_event在的events字段是一个位掩码，指定待检查的描述符fd上感兴趣的事件集合</li>
<li>data字段是一个联合体，当描述符fd成为就绪态时，联合体的成员可用来指定传回给调用进程的信息<ul>
<li>  联合体成员不能一起使用，常用fd</li>
<li>  想要将文件描述符和用户数据关联起来，以实现快速的数据访问，只能使用其它手段，比如放弃使用fd，而在ptr指向的用户数据中包含fd</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>max_user_watches上限</strong></p>
<p>  每个注册到epoll实例上的文件描述符需要占用一小段不能被交换的内核内存空间，因此内核提供了一个接口用来定义每个用户可以注册到epoll实例上的文件描述符总数。</p>
<p>  这个上限值可以通过max_user_watches来查看和修改，max_user_watches是专属于Linux系统的/proc/sys/fd/epoll目录下的一个文件。默认上限值根据可用系统内存计算得出。</p>
</blockquote>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event *evlist, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure>

<p>成功返回就绪态的文件描述符的个数，失败返回-1并设置errno</p>
<p>参数evlist指向的结构体数组中返回的是有关就绪态文件描述符的信息。数组evlist的空间由调用者负责申请，所包含的元素个数在参数maxevents中指定。</p>
<p>在数组evlist中每个元素返回的都是单个就绪态文件描述符的信息：</p>
<ul>
<li>  events字段返回在该描述符上已经发生的事件掩码</li>
<li>  data字段返回的是适用epoll_ctl()注册监听事件时在ev.data中所指定的值。data字段是唯一可获知同这个事件相关的文件描述符号的途径，因此，在调用epoll_ctl()时要么将ev.data.fd设为文件描述符号，要么将ev.data.ptr设为指向包含文件描述符号的结构体</li>
</ul>
<p>参数timeout用来确定epoll_wait()的阻塞行为：</p>
<ul>
<li>  timeout为-1，调用将一直阻塞，直到兴趣列表中的文件描述符上有事件发生，或者直到捕获到一个信号为止</li>
<li>  timeout为0，执行一次非阻塞式的检查</li>
<li>  timeout大于0，调用将阻塞至多timeout毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止</li>
</ul>
<p>在多线程程序中，可以在一个线程中使用epoll_ctl()将文件描述符添加到另一个线程中由epoll_wait()所监视的epoll实例的兴趣列表中去。这些对兴趣列表的修改将立刻得到处理，而epoll_wait()调用将返回有关新添加的文件描述符的就绪信息。</p>
<p>epoll事件：除了有一个额外的前缀E外，大多数位掩码的名称同poll中对应的事件掩码名称相同。例外情况：</p>
<ul>
<li>  EPOLLET：epoll支持边缘触发</li>
<li>  EPOLLONESHOT：只触发一次，触发完标记为非激活状态，需要使用EPOLL_CTL_MOD操作重新激活对这个文件描述符的检查</li>
</ul>
<p><img src="image-20210126233317669.png" alt="image-20210126233317669"></p>
<h4 id="不同的通知模型如何影响我们的程序设计？"><a href="#不同的通知模型如何影响我们的程序设计？" class="headerlink" title="不同的通知模型如何影响我们的程序设计？"></a>不同的通知模型如何影响我们的程序设计？</h4><p>水平触发</p>
<ul>
<li>  确定文件描述符的I/O状态已经ready</li>
<li>  已经ready，对这个文件描述符执行一些I/O操作（比如读取几个字节数据），然后继续监视它的IO状态</li>
<li>  仍然有未读取的数据，还会继续触发通知，也就是说不用一次执行完所有的IO操作（比如一次读取缓冲区的全部内容）</li>
</ul>
<p>边缘触发：</p>
<ul>
<li>  只有新的IO事件发生时，才会触发通知</li>
<li>  直到下次IO事件发生，不会再触发通知</li>
</ul>
<blockquote>
<p>  注：对于边缘触发，当触发通知时，我们并不知道有多少IO可用（例如有多少字节可以读），所以一般使用边缘触发通知方式要遵循如下规则：</p>
<ol>
<li> 接收到事件通知后，程序应该尽可能多的执行IO（读写），因为仅仅通知这一次，不读取完毕，数据可能就丢失了</li>
<li> 为了避免IO阻塞，每个被监视的文件描述符应该是非阻塞模式打开的，然后收到事件通知后，重复的执行IO直到返回错误信息</li>
</ol>
</blockquote>
<h4 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h4><p><strong>epoll程序示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BUF     1000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENTS  5</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> epfd, ready, fd, s, j, numOpenFds;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">evlist</span>[<span class="hljs-title">MAX_EVENTS</span>];</span><br>    <span class="hljs-keyword">char</span> buf[MAX_BUF];<br><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span> || <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;--help&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s file...\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    epfd = epoll_create(argc - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(epfd == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error epoll_create&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; argc; j++)&#123;<br>        fd = open(argv[j], O_RDONLY);<br>        <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error open&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Opened \&quot;%s\&quot; on fd %d\n&quot;</span>, argv[j], fd);<br><br>        ev.events = EPOLLIN;<br>        ev.data.fd = fd;<br>        <span class="hljs-keyword">if</span>(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev) == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error epoll_ctl&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    numOpenFds = argc - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(numOpenFds &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;About to epoll_wait()\n&quot;</span>);<br>        ready = epoll_wait(epfd, evlist, MAX_EVENTS, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(ready == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(errno == EINTR)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error epoll_wait&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Ready: %d\n&quot;</span>, ready);<br><br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; ready; j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  fd = %d; events: %s%s%s\n&quot;</span>, evlist[j].data.fd,<br>                (evlist[j].events &amp; EPOLLIN)  ? <span class="hljs-string">&quot;EPOLLIN &quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>                (evlist[j].events &amp; EPOLLHUP) ? <span class="hljs-string">&quot;EPOLLHUP&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>                (evlist[j].events &amp; EPOLLERR) ? <span class="hljs-string">&quot;EPOLLERR&quot;</span>:<span class="hljs-string">&quot;&quot;</span>);<br>            <span class="hljs-keyword">if</span>(evlist[j].events &amp; EPOLLIN)&#123;<br>                s = read(evlist[j].data.fd, buf, MAX_BUF);<br>                <span class="hljs-keyword">if</span>(s == <span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error read&quot;</span>);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    read %d bytes : %.*s&quot;</span>,s,s,buf);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(evlist[j].events &amp; (EPOLLHUP | EPOLLERR))&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    closing fd %d\n&quot;</span>, evlist[j].data.fd);<br>                <span class="hljs-keyword">if</span>(close(evlist[j].data.fd) == <span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error close&quot;</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>                &#125;<br>                numOpenFds--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;All file descriptors closed; bye\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ET模式比LT模式触发事件的次数更少：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    fcntl(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">bool</span> enable_et)</span></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN;<br>    <span class="hljs-keyword">if</span>(enable_et)&#123;<br>        event.events |= EPOLLET;<br>    &#125;<br>    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    setnonblocking(fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lt</span><span class="hljs-params">(epoll_event *events, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> listenfd)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)&#123;<br>        <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;<br>        <span class="hljs-keyword">if</span>(sockfd == listenfd)&#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>            <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-keyword">sizeof</span>(client_address);<br>            <span class="hljs-keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);<br>            addfd(epollfd, connfd, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event trigger once\n&quot;</span>);<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>            <span class="hljs-keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)&#123;<br>                close(sockfd);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened \n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">et</span><span class="hljs-params">(epoll_event* events, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> listenfd)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)&#123;<br>        <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;<br>        <span class="hljs-keyword">if</span>(sockfd == listenfd)&#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>            <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-keyword">sizeof</span>(client_address);<br>            <span class="hljs-keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);<br>            addfd(epollfd, connfd, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event trigger once\n&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>,BUFFER_SIZE);<br>                <span class="hljs-keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>((errno == EAGAIN) || (errno == EWOULDBLOCK))&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read later\n&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    close(sockfd);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>                    close(sockfd);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>,ret, buf);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happend \n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port  = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    bzero(&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = htons(port);<br><br>    <span class="hljs-keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(listenfd &gt;= <span class="hljs-number">0</span>);<br><br>    ret = bind(listenfd, (struct sockaddr*)&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    ret = listen(listenfd, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    epoll_event events[MAX_EVENT_NUMBER];<br>    <span class="hljs-keyword">int</span> epollfd = epoll_create(<span class="hljs-number">5</span>);<br>    assert(epollfd != <span class="hljs-number">-1</span>);<br>    addfd(epollfd, listenfd, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        lt(events, ret, epollfd, listenfd);<br>        <span class="hljs-comment">//et(events, ret, epollfd, listenfd);</span><br>    &#125;<br>    close(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>EPOLLONESHOT程序示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER    1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE         1024</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fds</span>&#123;</span><br>    <span class="hljs-keyword">int</span> epollfd;<br>    <span class="hljs-keyword">int</span> sockfd;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    fcntl(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">bool</span> oneshot)</span></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET;<br>    <span class="hljs-keyword">if</span>(oneshot)&#123;<br>        event.events |= EPOLLONESHOT;<br>    &#125;<br>    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    setnonblocking(fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset_oneshot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd)</span></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;<br>    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sockfd = ((fds*)arg)-&gt;sockfd;<br>    <span class="hljs-keyword">int</span> epollfd = ((fds*)arg)-&gt;epollfd;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start new thread to receive data on fd: %d\n&quot;</span>, sockfd);<br>    <span class="hljs-keyword">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>            close(sockfd);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;foreiner closed the connection\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(errno == EAGAIN)&#123;<br>                reset_oneshot(epollfd, sockfd);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read later\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get content: %s\n&quot;</span>, buf);<br>            sleep(<span class="hljs-number">5</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end thread receving data on fd : %d\n&quot;</span>, sockfd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    bzero(&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = htons(port);<br><br>    <span class="hljs-keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(listenfd &gt;= <span class="hljs-number">0</span>);<br><br>    ret = bind(listenfd, (struct sockaddr*)&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    ret = listen(listenfd, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    epoll_event events[MAX_EVENT_NUMBER];<br>    <span class="hljs-keyword">int</span> epollfd = epoll_create(<span class="hljs-number">5</span>);<br>    assert(epollfd != <span class="hljs-number">-1</span>);<br><br>    addfd(epollfd, listenfd, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)&#123;<br>            <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;<br>            <span class="hljs-keyword">if</span>(sockfd == listenfd)&#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>                <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-keyword">sizeof</span>(client_address);<br>                <span class="hljs-keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);<br>                addfd(epollfd, connfd, <span class="hljs-literal">true</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;<br>                <span class="hljs-keyword">pthread_t</span> thread;<br>                fds fds_for_new_worker;<br>                fds_for_new_worker.epollfd = epollfd;<br>                fds_for_new_worker.sockfd = sockfd;<br>                pthread_create(&amp;thread, <span class="hljs-literal">NULL</span>, worker, (<span class="hljs-keyword">void</span>*)&amp;fds_for_new_worker);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened \n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="深入探究epoll的语义"><a href="#深入探究epoll的语义" class="headerlink" title="深入探究epoll的语义"></a>深入探究epoll的语义</h4><p><img src="image-20210129105701198.png" alt="image-20210129105701198"></p>
<p>当我们通过epoll_create创建一个<strong>epoll实例</strong>时，内核在内存中创建一个新的<strong>i-node</strong>，并打开<strong>文件描述</strong>，随后在调用epoll_create的进程中为打开的<strong>文件描述</strong>分配一个新的<strong>文件描述符</strong>。</p>
<p>同epoll实例的兴趣列表相关联的是打开的<strong>文件描述</strong>，而不是<strong>epoll文件描述符</strong>。</p>
<p>文件描述表示的是一个打开文件的上下文信息（大小、内容、编码等与文件有关的信息），这部分内容实际上由内核来管理的。</p>
<p>用户空间的应用程序通过open()等系统调用向内核请求，内核分配给用户空间一个文件描述符，用户空间的应用程序通过文件描述符操作文件。</p>
<p>一个文件描述可以对应多个文件描述符，当文件描述对应的文件描述符都关闭时，内核知道此时没有用户空间的程序需要使用文件描述了，则内核负责回收。</p>
<blockquote>
<p>  将文件描述比喻为一个抽屉，通过open()获得的文件描述符比喻为抽屉把手（句柄），通过把手操作抽屉里的内容。</p>
</blockquote>
<p>文件描述实际上是内核中的一个数据结构，而用户空间中的文件描述符只不过是一个整数，epoll的兴趣列表实际关注的是内核中的数据结构。</p>
<p><strong>重新释意：</strong></p>
<p>epoll_ctl()的EPOLL_CTL_ADD操作：内核在兴趣列表中添加一个元素，这个元素同时记录了需要检查的<strong>文件描述符的数量</strong>以及对应的打开<strong>文件描述</strong>的引用。</p>
<p>epoll_wait()：调用的目的是让内核负责监视打开的<strong>文件描述</strong>。</p>
<ul>
<li>  之前的观点：如果一个文件描述符是epoll兴趣列表的成员，当关闭它后会自动从列表中移除</li>
<li>  改进的观点：一旦所有指向打开的文件描述的文件描述符都被关闭后，这个打开的文件描述将从epoll兴趣列表中移除</li>
</ul>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>select 的问题：</p>
<ul>
<li>  监听的文件描述符有上限 FD_SETSIZE，一般是 1024。因为 <code>fd_set</code> 是个 bitmap，它为最多 <code>nfds</code> 个描述符都用一个 bit 去表示是否监听，即使相应位置的描述符不需要监听在 <code>fd_set</code> 里也有它的 bit 存在。<code>nfds</code> 用于创建这个 bitmap 所以 <code>fd_set</code> 是有限大小的。</li>
<li>  在用户侧，select 返回后它并不是只返回处于 ready 状态的描述符，而是会返回传入的所有的描述符列表集合，包括 ready 的和非 ready 的描述符，用户侧需要去<strong>遍历所有</strong> readfds、writefds、exceptfds 去看哪个描述符是 ready 状态，再做接下来的处理。还要清理这个 ready 状态，做完 IO 操作后再塞给 select 准备执行下一轮 IO 操作</li>
<li>  在 Kernel 侧，select 执行后每次都要<strong>陷入内核遍历三个描述符集合数组</strong>为文件描述符<strong>注册监听</strong>，即在描述符指向的 Socket  或文件等上面设置处理函数，从而在文件 ready 时能调用处理函数。等有文件描述符 ready 后，在 select 返回退出之前，kernel 还需要再次遍历描述符集合，将设置的这些处理函数拆除再返回</li>
<li>  有<strong>惊群问题</strong>。假设一个文件描述符 123 被多个进程或线程注册在自己的 select 描述符集合内，当这个文件描述符 ready 后会将所有监听它的进程或线程全部唤醒</li>
<li>  无法动态添加描述符，比如一个线程已经在执行 select 了，突然想写数据到某个新描述符上，就只能等前一个 select 返回后重新设置 FD_Set 重新执行 select</li>
</ul>
<p>select 也有个优点，就是跨平台更容易。实现这个接口的 OS 更多。</p>
<p>poll：</p>
<ul>
<li>  相对于 select 来说，poll 解决了 fds 长度上限问题，解决了监听描述符无法复用问题</li>
<li>  用户仍然需要在 poll 返回后遍历 fds  去找 ready 的描述符，也需要清理 ready 描述符对应的 revents</li>
<li>  Kernel 也同样是每次 poll 调用需要去遍历 fds  注册监听，poll 返回时候拆除监听</li>
<li>  仍然有与 select 一样的惊群问题，也有无法动态修改描述符的问题</li>
</ul>
<p>epoll 优点:</p>
<ul>
<li>  监听的描述符没有上限；</li>
<li>  <code>epoll_wait</code> 每次只会返回 Ready 的描述符，不用完整遍历所有被监听的描述符；</li>
<li>  监听的描述符被注册到 epoll 后会与 epoll 的描述符绑定，维护在内核，不主动通过 <code>epoll_ctl</code> 执行删除不会自动被清理，所以每次执行 <code>epoll_wait</code> 后用户侧不用重新配置监听，Kernel 侧在 <code>epoll_wait</code> 调用前后也不会反复注册和拆除描述符的监听；</li>
<li>  可以通过 <code>epoll_ctl</code> 动态增减监听的描述符，即使有另一个线程已经在执行 <code>epoll_wait</code>；</li>
<li>  <code>epoll_ctl</code> 在注册监听的时候还能传递自定义的 <code>event_data</code>，一般是传描述符，但应用可以根据自己情况传别的；</li>
<li>  即使没线程等在 <code>epoll_wait</code> 上，Kernel 因为知道所有被监听的描述符，所以在这些描述符 Ready 时候就能做处理，等下次有线程调用 <code>epoll_wait</code> 时候直接返回。这也帮助 epoll 去实现 IO Edge Trigger，即 IO Ready 时候 Kernel 就标记描述符为 Ready 之后在描述符被读空或写空前不再去监听它，后面详述；</li>
<li>  多个不同的线程能同时调用 <code>epoll_wait</code> 等在同一个 epoll 描述符上，有描述符 Ready 后它们就去执行；</li>
</ul>
<p>epoll 缺点：</p>
<ul>
<li>  <code>epoll_ctl</code> 是个<strong>系统调用</strong>，每次修改监听事件，增加监听描述符时候都是一次系统调用，并且没有批量操作的方法。比如一口气要监听一万个描述符，要把一万个描述符从监听读改到监听写等就会很耗时，很低效；</li>
<li>  对于服务器上大量连上又断开的连接处理效率低，即 <code>accept()</code> 执行后生成一个新的描述符需要执行 <code>epoll_ctl</code> 去注册新 Socket 的监听，之后 <code>epoll_wait</code> 又是一次系统调用，如果 Socket 立即断开了 <code>epoll_wait</code> 会立即返回，又需要再用 <code>epoll_ctl</code> 把它删掉；</li>
<li>  依然有惊群问题，需要配合使用方式避免，后面详述；</li>
</ul>
<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h2><ul>
<li><p>调用函数</p>
<ul>
<li>  select和poll都是一个函数，epoll是一组函数</li>
</ul>
</li>
<li><p>文件描述符数量</p>
<ul>
<li>  select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐</li>
<li>  poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目</li>
<li>  epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效</li>
</ul>
</li>
<li><p>将文件描述符从用户传给内核</p>
<ul>
<li>  select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</li>
<li>  epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上</li>
</ul>
</li>
<li><p>内核判断就绪的文件描述符</p>
<ul>
<li>  select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生</li>
<li>  epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。</li>
<li>  epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list</li>
</ul>
</li>
<li><p>应用程序索引就绪文件描述符</p>
<ul>
<li>  select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</li>
<li>  epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可</li>
</ul>
</li>
<li><p>工作模式</p>
<ul>
<li>  select和poll都只能工作在相对低效的LT模式下</li>
<li>  epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 </li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>  当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll</li>
<li>  当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll</li>
<li>  当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</li>
</ul>
</li>
</ul>
<h2 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a>ET、LT、EPOLLONESHOT</h2><ul>
<li><p>LT水平触发模式</p>
<ul>
<li>  epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li>
<li>  当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理</li>
</ul>
</li>
<li><p>ET边缘触发模式</p>
<ul>
<li>  epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li>
<li>  必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain</li>
</ul>
</li>
<li><p>EPOLLONESHOT</p>
<ul>
<li>  一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li>
<li>  我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，**当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p>  《Unix网络编程》</p>
</li>
<li><p>  《Linux/Unix系统编程手册》</p>
</li>
<li><p>  《Linux高性能服务器编程》</p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127148459">深入学习理解 IO 多路复用</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://medium.com/@copyconstruct/the-method-to-epolls-madness-d9d2d6378642">Medium: The method to epoll’s madness</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://article.itxueyuan.com/dX2X9r">20分钟了解Epoll + 聊天室实战</a></p>
</li>
</ul>

	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>