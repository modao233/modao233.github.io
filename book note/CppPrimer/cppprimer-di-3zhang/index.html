<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>PL</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/CppPrimer/cppprimer-di-3zhang/">C++ Primer 第3章 字符串、向量和数组</a></h1><div class=post-meta-inline><span class=post-date> 2018-06-11 </span></div><div class=post-content><p>C++ Primer 第3章 字符串、向量和数组<h2 id=3-1-ming-ming-kong-jian-de-usingsheng-ming>3.1 命名空间的using声明</h2><p>作用域操作符(::)的含义：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。<p>通过使用using声明，可以简单的使用到命名空间中的成员。有了using声明就无须专门的前缀也能使用所需的名字了。<p>按照规定，每个using 声明引入命名空间中的一个成员。每个用到的i那个字都必须有自己的声明语句，而且每句话都以分号结束。<p>位于头文件的代码一般来说不应该使用using声明，这是为了防止产生始料未及的名字冲突。<h2 id=3-2-biao-zhun-ku-lei-xing-string>3.2 标准库类型string</h2><p>标准库类型string 表示可变长的字符序列，使用string类型必须首先包含string头文件，string定义在命名空间std中。<h3 id=3-2-1-ding-yi-he-chu-shi-hua-stringdui-xiang>3.2.1 定义和初始化string对象</h3><p>初始化string对象常用的方式：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string s1;    </span><span style=color:#65737e;>//默认初始化，s1是一个空字符串
</span><span>string s2 = s1;    </span><span style=color:#65737e;>//s2是s1的副本
</span><span>string </span><span style=color:#8fa1b3;>s2</span><span>(</span><span style=color:#bf616a;>s1</span><span>);    </span><span style=color:#65737e;>//s2是s1的副本
</span><span>string </span><span style=color:#8fa1b3;>s3</span><span>("</span><span style=color:#a3be8c;>hiya</span><span>");    </span><span style=color:#65737e;>//s3是字面值”hiya“的副本，除了字符串最后的那个空字符外
</span><span>string s3 = "</span><span style=color:#a3be8c;>hiya</span><span>";    </span><span style=color:#65737e;>//s3是字符串字面值的副本
</span><span>string </span><span style=color:#8fa1b3;>s4</span><span>(</span><span style=color:#bf616a;>n</span><span>, '</span><span style=color:#a3be8c;>c</span><span>');    </span><span style=color:#65737e;>//s4的内容是n个字符c组成的串
</span></code></pre><p>拷贝初始化：如果使用等会（=）初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。<p>直接初始化：如果不使用等号，则执行的是直接初始化。<p>当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像s4那样初始化要用到的值有多个，一般只能使用直接初始化：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string s5 = "</span><span style=color:#a3be8c;>hiya</span><span>";        </span><span style=color:#65737e;>//拷贝初始化
</span><span>string </span><span style=color:#8fa1b3;>s6</span><span>("</span><span style=color:#a3be8c;>hiya</span><span>");        </span><span style=color:#65737e;>//直接初始化
</span><span>string </span><span style=color:#8fa1b3;>s7</span><span>(</span><span style=color:#d08770;>10</span><span>, '</span><span style=color:#a3be8c;>c</span><span>');        </span><span style=color:#65737e;>//直接初始化，s7的内容是cccccccccc
</span></code></pre><p>对于多个值进行初始化，也可以使用拷贝初始化，不过需要<strong>显示</strong>创建一个（临时）对象用于拷贝：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string s8 = </span><span style=color:#bf616a;>string</span><span>(</span><span style=color:#d08770;>10</span><span>,'</span><span style=color:#a3be8c;>c</span><span>');
</span></code></pre><h3 id=3-2-2-stringdui-xiang-shang-de-cao-zuo>3.2.2 string对象上的操作</h3><table><thead><tr><th>string的操作<th>操作说明<tbody><tr><td>os << s<td>将s写到输出流os当中，返回os<tr><td>is >> s<td>从is中读取字符串赋给s，字符串以空白分隔，返回is<tr><td>getline(is, s)<td>从is中读取一行赋给s，返回is<tr><td>s.empty()<td>s为空返回true，否则返回false<tr><td>s.size()<td>返回s中字符的个数<tr><td>s[n]<td>返回s中第n个字符的引用，位置n从0算起<tr><td>s1 + s2<td>返回s1和s2连接后的结果<tr><td>s1 = s2<td>用s2的副本代替s1中原本的字符<tr><td>s1 == s2<td>如果s1和s2中所含的字符完全一样，则它们相等；<tr><td>s1 != s2<td>string对象的相等性判断对字母的大小写敏感<tr><td><，<=，>，>=<td>利用字符在字典中的顺序进行比较，对大小写敏感</table><p>string对象的输入以第一个<strong>非空白</strong>（空格符、换行符、制表符等）字符读起，直至遇到下一处空白为止。<p>string对象的输入输出操作返回运算符左侧的运算对象作为其结果，因此，可以多个输入或输出连写在一起。<p>想要保留输入时的空白符，应该使用getline函数，函数从给定的输入流中读取内容，直到遇到换行符为止（换行符也被读进来了），但是所读的内容存入到string对象时，换行符并未存入到srting对象中，而是被丢弃了。<p>size函数返回一个string::size_type类型：它是一个无符号类型的值，足够存放下任何string对象的大小。<p>string类及其他大多数标准库类型都定义了几种配套类型，这些配套类型体现了标准库类型与<strong>机器无关</strong>的特性。<p>C++11新标准中，允许编译器通过auto或者decltype来推断变量类型：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>auto</span><span> len = line.</span><span style=color:#bf616a;>size</span><span>();    </span><span style=color:#65737e;>//len的类型是string::size_type
</span></code></pre><p>如果一条表达式已有size()函数就不要使用int 了，可以避免混用int 和 unsigned可能带来的问题。<p>相等性运算符分别检验两个string对象相等或不相等，string对象相等意味着它们的长度相同而且所包含的字符也全相同。<p>关系运算符<，<=，>，>=：<ol><li>如果两个string对象长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，则较短string小于较长string<li>如果两个string对象在某些对应的位置上不一样，则string对象的比较结果其实是string对象中第一对相异字符比较的结果</ol><p>两个string对象相加，得到的是一个新的string对象，其包含的字符由两部分组成：前半部分是加号左侧string对象所含字符，后半部分是加号右侧string对象所含字符。<p>复合赋值运算符（+=）则是将右侧string对象的内容追加到左侧string对象的后面。<p>当把string对象和字符字面值以及字符串字面值混在一条语句中使用时，<strong>必须确保每个加法运算符（+）两侧的运算对象至少有一个是string类型</strong>：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string s4 = s1 + "</span><span style=color:#a3be8c;>, </span><span>";            </span><span style=color:#65737e;>//正确：把一个string对象和一个字面值相加
</span><span>string s5 = "</span><span style=color:#a3be8c;>hello</span><span>" + "</span><span style=color:#a3be8c;>, </span><span>";        </span><span style=color:#65737e;>//错误：两个运算对象都不是string
</span><span>
</span><span>string s6 = s1 + "</span><span style=color:#a3be8c;>, </span><span>" + "</span><span style=color:#a3be8c;>world</span><span>";</span><span style=color:#65737e;>//正确：每个加法运算符都有一个运算对象是string
</span><span>string s6 = (s1 + "</span><span style=color:#a3be8c;>, </span><span>") + "</span><span style=color:#a3be8c;>world</span><span>";    </span><span style=color:#65737e;>//上面的等价
</span><span>string s7 = "</span><span style=color:#a3be8c;>hello</span><span>" + "</span><span style=color:#a3be8c;>, </span><span>" + "</span><span style=color:#a3be8c;>world</span><span>";    </span><span style=color:#65737e;>//错误：不能把字面值直接相加
</span></code></pre><p>标准库允许把字符字面值和字符串字面值转换成string对象。因为历史原因，也为了与C兼容，所以C++语言的字符串字面值并不是标准库类型string的对象，字符串字面值与string是不同的类型。<h3 id=3-2-3-chu-li-stringdui-xiang-zhong-de-zi-fu>3.2.3 处理string对象中的字符</h3><table><thead><tr><th>cctype头文件中的函数<th>函数说明<tbody><tr><td>isalnum(c)<td>当c是字母或数字时为真<tr><td>isalpha(c)<td>当c是字母时为真<tr><td>iscntrl(c)<td>当c是控制字符时为真<tr><td>isdigit(c)<td>当c是数字时为真<tr><td>isgraph(c)<td>当c不是空格但可以打印时为真<tr><td>islower(c)<td>当c是小写字母时为真<tr><td>isprint(c)<td>当c是可打印字符时为真（即c是空格或c具有可视形式）<tr><td>ispunct(c)<td>当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）<tr><td>isspace(c)<td>当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）<tr><td>isupper(c)<td>当c是大写字母时为真<tr><td>isxdigit(c)<td>当c是十六进制数字时为真<tr><td>tolower(c)<td>如果c是大写字母，输出对应小写字母，否则原样输出c<tr><td>toupper(c)<td>如果c是小写字母，输出对应大写字母，否则原样输出c</table><p>C++标准库兼容了C语言的标准库，C语言的头文件形如<strong>name.h</strong>，C++则将这些文件命名为<strong>cname</strong>。在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中则不然。<p>C++11新标准提供了一种语法：范围for语句。这种语句遍历给定序列中的每个元素并对序列中每个值执行某种操作，形式是：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>for </span><span>(declaration : expression)
</span><span>    statement
</span></code></pre><p>如果想对string 对象中的<strong>每个字符</strong>做点什么操作，这是最好的办法，如：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string </span><span style=color:#8fa1b3;>str</span><span>("</span><span style=color:#a3be8c;>some string</span><span>");
</span><span style=color:#b48ead;>for </span><span>(</span><span style=color:#b48ead;>auto</span><span> c : str)    </span><span style=color:#65737e;>//只读，不可修改
</span><span>    cout << c << endl;
</span><span>    
</span><span style=color:#b48ead;>for </span><span>(</span><span style=color:#b48ead;>auto </span><span>&c : str)
</span><span>    c = </span><span style=color:#96b5b4;>toupper</span><span>(c);
</span><span>cout << s << endl;
</span></code></pre><p>访问string对象中的单个字符有两种方式：<ol><li><p>使用下标</p> <p>下标运算符（[]）接受的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。</p> <p>下标从0计起，必须大于等于0，小于s.size()。超出范围的下标会越界。</p> <p>下标的值称作”下标“或”索引“，任何表达式只要它的值是一个整型值就能作为索引，如果某个索引是带符号类型的值，将自动转换成string::size_type表达的无符号类型。</p> <p>在访问指定字符之前，首先要检查string对象s是否为空，如果s为空，则s[0]的结果将是未定义的。</p> <p>只要字符串不是常量，就能为下标运算符返回的字符赋新值。</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string </span><span style=color:#8fa1b3;>s</span><span>("</span><span style=color:#a3be8c;>some string</span><span>");
</span><span style=color:#b48ead;>if </span><span>(!s.</span><span style=color:#bf616a;>empty</span><span>())
</span><span>    s[</span><span style=color:#d08770;>0</span><span>] = </span><span style=color:#96b5b4;>toupper</span><span>(s[</span><span style=color:#d08770;>0</span><span>]);
</span><span>    
</span><span style=color:#b48ead;>for </span><span>(</span><span style=color:#b48ead;>decltype</span><span>(s.</span><span style=color:#bf616a;>size</span><span>()) index = </span><span style=color:#d08770;>0</span><span>; index != s.</span><span style=color:#bf616a;>size</span><span>() && !</span><span style=color:#96b5b4;>isspace</span><span>(s[index]); ++index)
</span><span>    s[index] = </span><span style=color:#96b5b4;>toupper</span><span>(s[index]);
</span></code></pre> <p><strong>逻辑与运算符（&&），如果参与运算的两个运算对象都为真，则逻辑与结果为真；否则结果为假。C++语言规定，只有当左侧运算对象为真时才会检查右侧运算对象的情况。</strong></p> <p>使用下标可进行随机访问，但是下标必须合法。</p><li><p>使用迭代器</p></ol><h2 id=3-3-biao-zhun-ku-lei-xing-vector>3.3 标准库类型vector</h2><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>vector</span><span>>
</span><span style=color:#b48ead;>using</span><span> std::vector;
</span></code></pre><p>vector是一个类模板，C++语言既有类模板，也有函数模板。模板本身不是类或对象，编译器根据模板创建类或函数的过程称为实例化。<p>vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如：vector<int>。<p><p>组成vector的元素可以是vector，C++11新标准对此的定义有所改善：</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//过去，右尖括号不能连在一起写，要用空格分开
</span><span>vector&LTvector<</span><span style=color:#b48ead;>int</span><span>> > a;
</span><span style=color:#65737e;>//C++11
</span><span>vector&LTvector<</span><span style=color:#b48ead;>int</span><span>>> a;
</span></code></pre> <h3 id=3-3-1-ding-yi-he-chu-shi-hua-vectordui-xiang>3.3.1 定义和初始化vector对象</h3> <table><thead><tr><th>初始化vector对象的方法<th>方法说明<tbody><tr><td>vector<t> v1<td><td>v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</td><tr><tr><td>vector<t> v2(v1)<td><td>v2中包含v1所有元素的副本</td><tr><tr><td>vector<t> v2 = v1<td><td>等价于v2(v1)，v2中包含v1所有元素的副本</td><tr><tr><td>vector<t> v3(n, val)<td><td>v3包含了n个重复的元素，每个元素的值都是val</td><tr><tr><td>vector<t> v4(n)<td><td>v4包含了n个重复地执行了值初始化的对象</td><tr><tr><td>vector<t> v5{a, b, c...}<td><td>v5包含了初始值个数的元素，每个元素被赋予相应的初始值</td><tr><tr><td>vector<t> v5 = {a, b, c...}<td><td>等价于v5{a, b, c...}</td><tr><tbody><table><p>C++11新标准还提供了列表初始化。用<strong>花括号</strong>括起来的0个或多个初始元素值被赋给vector对象：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>vector&LTstring> articles = {"</span><span style=color:#a3be8c;>a</span><span>", "</span><span style=color:#a3be8c;>an</span><span>", "</span><span style=color:#a3be8c;>the</span><span>"};
</span></code></pre><p>通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值。此时库会创建一个<strong>值初始化的</strong>元素初值，该值由元素类型决定：<ul><li>元素是内置类型，使用默认值<li>元素是类类型，元素由类默认初始化<li>如果元素的类型不支持默认初始化，则必须明确提供初始值<li>只提供元素数量而没有设定初始值，只能使用直接初始化</ul><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>v1</span><span>(</span><span style=color:#d08770;>10</span><span>);        </span><span style=color:#65737e;>//v1有10个元素，每个元素的值都是0
</span><span>vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>v2</span><span>{</span><span style=color:#d08770;>10</span><span>};        </span><span style=color:#65737e;>//v2有1个元素：10
</span><span>
</span><span>vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>v3</span><span>(</span><span style=color:#d08770;>10</span><span>, </span><span style=color:#d08770;>1</span><span>);    </span><span style=color:#65737e;>//v3有10个元素，每个元素的值都是1
</span><span>vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>v4</span><span>{</span><span style=color:#d08770;>10</span><span>, </span><span style=color:#d08770;>1</span><span>};    </span><span style=color:#65737e;>//v4有2个元素：10和1
</span></code></pre><p>圆括号提供的值用来构造vector对象；花括号的值作为元素的值，执行列表初始化。<p>如果初始化使用花括号但是提供的值又不能用来列表初始化，就会考虑用这样的值来构造对象。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>vector&LTstring> </span><span style=color:#bf616a;>v5</span><span>{"</span><span style=color:#a3be8c;>hi</span><span>"};    </span><span style=color:#65737e;>//列表初始化，v5有1个元素
</span><span>vector&LTstring> </span><span style=color:#8fa1b3;>v6</span><span>("</span><span style=color:#a3be8c;>hi</span><span>");    </span><span style=color:#65737e;>//错误：不能用字符串字面值构建vector对象
</span><span>vector&LTstring> </span><span style=color:#bf616a;>v7</span><span>{</span><span style=color:#d08770;>10</span><span>};        </span><span style=color:#65737e;>//v7有10个默认初始化的元素
</span><span>vector&LTstring> </span><span style=color:#bf616a;>v8</span><span>{</span><span style=color:#d08770;>10</span><span>, "</span><span style=color:#a3be8c;>hi</span><span>"};</span><span style=color:#65737e;>//v8有10个值为“hi”的元素
</span></code></pre><h3 id=3-3-2-xiang-vectordui-xiang-zhong-tian-jia-yuan-su>3.3.2 向vector对象中添加元素</h3><p>如果循环体内部包含有向vector对象添加元素的语句，则不能使用<strong>范围for循环</strong>，范围for循环语句体内不应该改变其所遍历的序列的大小。<h3 id=3-3-3-qi-ta-vectorcao-zuo>3.3.3 其他vector操作</h3><table><thead><tr><th>vector支持的操作<th>操作说明<tbody><tr><td>v.empty()<td>如果v不包含任何元素，返回真，否则返回假<tr><td>v.size()<td>返回v中元素的个数<tr><td>v.push_back(t)<td>向v的尾端添加一个值为t的元素<tr><td>v[n]<td>返回v中第n个位置上的元素引用<tr><td>v1 = v2<td>用v2中元素的拷贝替换v1中的元素<tr><td>v1 = {a, b, c...}<td>用列表中元素的拷贝替换v1中的元素<tr><td>v1 == v2<td>v1和v2相等，当且仅当它们的元素数量相同，且对应位置的元素值都相同<tr><td>v1 != v2<td><tr><td><，<=，>，>=<td>以字典顺序进行比较</table><p>size函数返回vector对象中元素的个数，返回值类型是由vector定义的size_type类型。<p><strong>要使用size_type，需要首先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型</strong>:<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>vector<</span><span style=color:#b48ead;>int</span><span>>::size_type        </span><span style=color:#65737e;>//正确
</span><span>vector::size_type            </span><span style=color:#65737e;>//错误
</span></code></pre><p>vector各个相等性运算符和关系运算符和string的相应运算符功能一致。只有当元素的值可比较时，vector对象才能被比较。<p>使用下标访问对象元素时，必须确认下标合法，<strong>而且不能用下标形式添加元素</strong>。<p>vector对象（以及string对象）的下标运算符可用于访问已经存在的元素，而不能用于添加元素。<p>使用下标访问一个不存在的元素将引发错误，这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。缓冲区溢出指的就是这类错误。<h2 id=3-4-die-dai-qi-jie-shao>3.4 迭代器介绍</h2><p>类似于指针类型，迭代器也提供了对对象的间接访问。有效的迭代器指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都是无效的。<h3 id=3-4-1-shi-yong-die-dai-qi>3.4.1 使用迭代器</h3><p>迭代器的获取不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型拥有名为<strong>begin</strong>和<strong>end</strong>的成员。<p>如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器，指向容器“尾元素的下一个位置”。<table><thead><tr><th>标准容器迭代器的运算符<th>相关说明<tbody><tr><td>*iter<td>返回迭代器iter所指元素的引用<tr><td>iter->mem<td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem<tr><td>++iter<td>令iter指示容器中的下一个元素<tr><td>--iter<td>令iter指示容器中的上一个元素<tr><td>iter1 == iter2<td>判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等；反之，不相等<tr><td>iter1 != iter2<td></table><p>和指针类似，可以使用解引用迭代器来获取它所指向的元素，执行解引用的迭代器必须合法并确实指向某个元素。解引用一个非法迭代器或尾后迭代器都是未定义的行为。<p>因为end返回的迭代器并不实际指示某个元素，所以不能对其进行<strong>递增</strong>或<strong>解引用</strong>的操作。<p>使用迭代器的for循环常用的是 != ,原因和大多数人更愿意使用迭代器而非下标一样：这种编程风格在标准库提供的所有容器上都有效。所有标准库容器上都定义了 == 和 !=，但是大多数都没有定义 <。<p>拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型:<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>vector<</span><span style=color:#b48ead;>int</span><span>>::iterator it;            </span><span style=color:#65737e;>//it能读写vector&LTint>的元素
</span><span>string::interator it2;                </span><span style=color:#65737e;>//it2能读写string对象中的字符
</span><span>
</span><span>vector<</span><span style=color:#b48ead;>int</span><span>>::const_iterator it3;    </span><span style=color:#65737e;>//it3只能读元素，不能写元素
</span><span>string::const_interator it4;        </span><span style=color:#65737e;>//it4只能读字符，不能写字符
</span></code></pre><p>如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既可以使用iterator也能使用const_iterator。<p>begin和end返回的具体类型由对象是否常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator。<p>C++11新标准引入了两个新函数：cbegin和cend，便于专门得到const_iterator类型的返回值。<p>vector对象能够动态增长，其某些操作会使迭代器失效，因此有些限制：<ul><li>不能在范围for循环中向vector对象添加元素<li>任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</ul><h3 id=3-4-2-die-dai-qi-yun-suan>3.4.2 迭代器运算</h3><table><thead><tr><th>vector和string迭代器支持的运算<th>相关说明<tbody><tr><td>iter + n<td>迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来性比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置<tr><td>iter - n<td>迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来性比向后移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置<tr><td>iter1 += n<td>迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1<tr><td>iter1 -= n<td>迭代器加法的复合赋值语句，将iter1减n的结果赋给iter1<tr><td>iter1 - iter2<td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向同一个容器中的元素或者尾元素的下一位置<tr><td>>，>=，<，<=<td>迭代器的关系运算符，如果某迭代器所指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向同一个容器中的元素或者尾元素的下一位置</table><p>两个迭代器相减的结果的值类型是difference_type，是带符号整型数。string和vector都定义了这个类型。<h2 id=3-5-shu-zu>3.5 数组</h2><p>数组是一种复合类型，声明形如a[d]，其中a是数组的名字，d是数组的维度（必须大于0，必须是一个常量表达式）。<h3 id=3-5-1-ding-yi-he-chu-shi-hua-nei-zhi-shu-zu>3.5.1 定义和初始化内置数组</h3><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>unsigned</span><span> cnt = </span><span style=color:#d08770;>42</span><span>;            </span><span style=color:#65737e;>//不是常量表达式
</span><span>cosntexpr </span><span style=color:#b48ead;>unsigned</span><span> sz = </span><span style=color:#d08770;>42</span><span>;    </span><span style=color:#65737e;>//常量表达式
</span><span style=color:#b48ead;>int</span><span> arr[</span><span style=color:#d08770;>10</span><span>];                </span><span style=color:#65737e;>//含有10个整数的数组
</span><span style=color:#b48ead;>int </span><span>*parr[sz];                </span><span style=color:#65737e;>//含有42个整型指针的数组
</span><span>string bad[cnt];            </span><span style=color:#65737e;>//错误：cnt不是常量表达式
</span><span>string strs[</span><span style=color:#bf616a;>get_size</span><span>()];    </span><span style=color:#65737e;>//当get_size()是constexpr时正确，否则错误
</span></code></pre><p><strong>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值</strong>。<p>定义数组时必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。<p>可以对数组的元素进行列表初始化，此时允许忽略数组的维度：<ul><li>如果在声明时没有指明维度，编译器根据初始值的数量计算并推测出来<li>指明了维度，那么初始值的总数量不应该超出指定的大小，如果维度比初始值数量大，则提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值</ul><p>字符数组有一种额外的初始化形式：使用字符串字面值对数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符会像字符串的其他字符一样被拷贝到字符数组中去：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>char</span><span> a1[] = {'</span><span style=color:#a3be8c;>c</span><span>', '</span><span style=color:#a3be8c;>+</span><span>', '</span><span style=color:#a3be8c;>+</span><span>'};        </span><span style=color:#65737e;>//列表初始化，没有空字符
</span><span style=color:#b48ead;>char</span><span> a2[] = {'</span><span style=color:#a3be8c;>c</span><span>', '</span><span style=color:#a3be8c;>+</span><span>', '</span><span style=color:#a3be8c;>+</span><span>', '</span><span style=color:#96b5b4;>\0</span><span>'};    </span><span style=color:#65737e;>//列表初始化，含有显示的空字符
</span><span style=color:#b48ead;>char</span><span> a3[] = "</span><span style=color:#a3be8c;>C++</span><span>";                </span><span style=color:#65737e;>//自动添加表示字符串结束的空字符
</span><span style=color:#b48ead;>const char</span><span> a4[</span><span style=color:#d08770;>6</span><span>] = "</span><span style=color:#a3be8c;>Daniel</span><span>";    </span><span style=color:#65737e;>//错误：没有空间可存放空字符！
</span></code></pre><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> a[] = {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>};    </span><span style=color:#65737e;>//含有3个整数的数组
</span><span style=color:#b48ead;>int</span><span> a2[] = a;        </span><span style=color:#65737e;>//错误：不允许使用一个数组初始化另一个数组
</span><span>a2 = a;                </span><span style=color:#65737e;>//错误：不能把一个数组直接赋值给另一个数组
</span></code></pre><p>复杂的数组声明：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int </span><span>*ptrs[</span><span style=color:#d08770;>10</span><span>];        </span><span style=color:#65737e;>//ptrs是含有10个整型指针的数组
</span><span style=color:#b48ead;>int </span><span>&refs[</span><span style=color:#d08770;>10</span><span>] = </span><span style=color:#65737e;>/* ? */</span><span>;    </span><span style=color:#65737e;>//错误：不存在引用的数组
</span><span style=color:#b48ead;>int </span><span>(*Parray)[</span><span style=color:#d08770;>10</span><span>] = &arr;    </span><span style=color:#65737e;>//Parray指向一个含有10个整数的数组
</span><span style=color:#b48ead;>int </span><span>(&arrRef)[</span><span style=color:#d08770;>10</span><span>] = arr;    </span><span style=color:#65737e;>//arrRef引用一个含有10个整数的数组
</span><span style=color:#b48ead;>int </span><span>*(&array)[</span><span style=color:#d08770;>10</span><span>] = ptrs;    </span><span style=color:#65737e;>//array引用的对象是一个含有10个int型指针的数组
</span></code></pre><p>类型修饰符从右向左绑定，有小括号的话则是从内向外。Parray是个指向大小为10的数组的指针，arrRef引用的对象是一个大小为10的整型数组。<h3 id=3-5-2-fang-wen-shu-zu-yuan-su>3.5.2 访问数组元素</h3><p>数组元素能够使用范围for语句或下标运算符来访问。使用数组下标时，通常将其定义为size_t类型（一种机器相关的无符号类型），它被设计得足够大以便能表示内存中任意对象的大小，定义在cstddef头文件中。<p>数组的下标也要进行严格检查，合理的下标应该大于等于0而且小于数组的大小。<p>大多数常见的安全问题都源于缓冲区溢出错误，当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此错误。<h3 id=3-5-3-zhi-zhen-he-shu-zu>3.5.3 指针和数组</h3><p>通常情况，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组的元素使用取地址符就能得到指向该元素的指针:<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string nums[] = {"</span><span style=color:#a3be8c;>one</span><span>", "</span><span style=color:#a3be8c;>two</span><span>", "</span><span style=color:#a3be8c;>three</span><span>"};
</span><span>string *p = &nums[</span><span style=color:#d08770;>0</span><span>];    </span><span style=color:#65737e;>//p指向nums的第一个元素
</span><span>string *p2 = nums;        </span><span style=color:#65737e;>//等价p2 = &nums[0]
</span></code></pre><p>数组有一个特性：在很多用的数组名的地方，编译器会自动地将其替换为一个指向数组首元素的指针。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> ia[] = {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>3</span><span>,</span><span style=color:#d08770;>4</span><span>,</span><span style=color:#d08770;>5</span><span>};
</span><span style=color:#b48ead;>auto </span><span style=color:#8fa1b3;>ia2</span><span>(</span><span style=color:#bf616a;>ia</span><span>);    </span><span style=color:#65737e;>//ia2是一个整型指针，指向ia的第一个元素
</span><span style=color:#b48ead;>auto </span><span style=color:#8fa1b3;>ia2</span><span>(&</span><span style=color:#bf616a;>ia</span><span>[</span><span style=color:#d08770;>0</span><span>]);    </span><span style=color:#65737e;>//等价上面语句，ia会自动转换成&ia[0]
</span><span>ia2 = </span><span style=color:#d08770;>42</span><span>;        </span><span style=color:#65737e;>//错误：ia2是一个指针，不能用int值给指针赋值
</span></code></pre><p>当使用decltype关键字时，上诉转换不会发生，decltype(ia)返回的类型是整数数组：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>decltype</span><span>(ia) ia3 = {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>3</span><span>,</span><span style=color:#d08770;>4</span><span>,</span><span style=color:#d08770;>5</span><span>};
</span><span>ia3 = p;    </span><span style=color:#65737e;>//错误，不能用整型指针给数组赋值
</span><span>ia3[</span><span style=color:#d08770;>4</span><span>] = i;    </span><span style=color:#65737e;>//正确：把i的值赋给i3的一个元素
</span></code></pre><p>指向数组元素的指针具有更多功能，vector和string的迭代器支持的运算，数组指针都支持。通过数组的名字或首元素地址可以得到指向首元素的指针，数组的尾指针则需要设法获取：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int </span><span>*e = &arr[</span><span style=color:#d08770;>10</span><span>];    </span><span style=color:#65737e;>//指向arr尾元素的下意味着的指针
</span></code></pre><p>不能对尾指针指向解引用或递增的操作。<p>C++11新标准引入了两个名为begin和end的函数，更简单、安全的获取数组的首尾指针。与容器的成员函数同名但是不是成员函数,使用形式是将数组作为它们的参数：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> ia[] = {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>3</span><span>,</span><span style=color:#d08770;>4</span><span>,</span><span style=color:#d08770;>5</span><span>,</span><span style=color:#d08770;>6</span><span>,</span><span style=color:#d08770;>7</span><span>,</span><span style=color:#d08770;>8</span><span>,</span><span style=color:#d08770;>9</span><span>};
</span><span style=color:#b48ead;>int </span><span>*beg = </span><span style=color:#bf616a;>begin</span><span>(ia);    </span><span style=color:#65737e;>//指向ia首元素的指针
</span><span style=color:#b48ead;>int </span><span>*last = </span><span style=color:#bf616a;>end</span><span>(ia);    </span><span style=color:#65737e;>//指向arr尾元素的下一位置的指针
</span></code></pre><p>两个指针相减的结果是它们之间的距离，是一种名为<strong>prtdiff_t</strong>的标准库类型，和size_t一样，prtdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负数，所以它是一种带符号类型。<p>只有两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，才能用关系运算符进行比较。如果两个指针指向不相关的对象，则不能比较它们。<p>指针运算同样适用于空指针和所指对象并非数组的指针，后一种情况下，两个指针必须指向同一个对象或该对象的下一位置。如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针相减，结果是0。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> ia[] = {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>4</span><span>,</span><span style=color:#d08770;>6</span><span>,</span><span style=color:#d08770;>8</span><span>};
</span><span style=color:#b48ead;>int</span><span> i = ia[</span><span style=color:#d08770;>2</span><span>];
</span><span style=color:#b48ead;>int </span><span>*p = ia;
</span><span>i = *(p + </span><span style=color:#d08770;>2</span><span>);    </span><span style=color:#65737e;>//等价于i = ia[2]
</span><span style=color:#b48ead;>int </span><span>*p = &ia[</span><span style=color:#d08770;>2</span><span>];    </span><span style=color:#65737e;>//p指向索引为2的元素
</span><span style=color:#b48ead;>int</span><span> j = p[</span><span style=color:#d08770;>1</span><span>];        </span><span style=color:#65737e;>//等价于*(p + 1)，就是ia[3]表示的那个元素
</span><span style=color:#b48ead;>int</span><span> k = p[-</span><span style=color:#d08770;>2</span><span>];        </span><span style=color:#65737e;>//p[-2]是ia[0]表示的那个元素
</span></code></pre><p>标准库类型（string、vector等）限定使用的下标必须是无符号类型，而内置的下标运算无此要求，但是地址必须指向原来的指针所指同一数组中的元素。<h3 id=3-5-4-cfeng-ge-zi-fu-chuan>3.5.4 C风格字符串</h3><p>字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串<strong>存放在字符数组中并以空字符结束（‘\0’）</strong>。<table><thead><tr><th>C风格字符串的函数（不负责验证字符串参数）<th>函数相关说明<tbody><tr><td>strlen(p)<td>返回p的长度，空字符不计算在内<tr><td>strcmp(p1, p2)<td>比较p1和p2的相等性。如果p1==p2，返回0；如果p1 > p2，返回一个正值；如果p1 < p2，返回一个负值<tr><td>strcat(p1, p2)<td>将p2附加到p1之后，返回p1<tr><td>strcpy(p1, p2)<td>将p2拷贝给p1，返回p1</table><p>传入此类函数的指针必须指向以空字符串作为结束的<strong>数组</strong>：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>char</span><span> ca[] = {'</span><span style=color:#a3be8c;>C</span><span>', '</span><span style=color:#a3be8c;>+</span><span>', '</span><span style=color:#a3be8c;>+</span><span>'};    </span><span style=color:#65737e;>//不以空字符结束
</span><span>cout << </span><span style=color:#96b5b4;>strlen</span><span>(ca) << endl;        </span><span style=color:#65737e;>//严重错误：ca没有以空字符结束
</span></code></pre><p>比较标准库string对象时，用的是普通的关系运算符和相等性运算符：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string s1 = "</span><span style=color:#a3be8c;>A string example</span><span>";
</span><span>string s2 = "</span><span style=color:#a3be8c;>A different string</span><span>";
</span><span style=color:#b48ead;>if</span><span>(s1 < s2)            </span><span style=color:#65737e;>//false：s2小于s1
</span></code></pre><p>如果把这些运算用在两个C风格字符串上，实际比较的将是指针而非字符串本身：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const char</span><span> ca1[] = "</span><span style=color:#a3be8c;>A string example</span><span>";
</span><span style=color:#b48ead;>const char</span><span> ca2[] = "</span><span style=color:#a3be8c;>A differenet string</span><span>";
</span><span style=color:#b48ead;>if </span><span>(ca1 < ca2)        </span><span style=color:#65737e;>//未定义的：试图比较两个无关地址
</span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#96b5b4;>strcmp</span><span>(ca1, ca2) < </span><span style=color:#d08770;>0</span><span>)    </span><span style=color:#65737e;>//和两个string对象的比较s1 < s2 效果一样
</span></code></pre><p>连接或拷贝C风格字符串也与标准库string对象的同样操作差别很大：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string largeStr = s1 + " " + s2;
</span><span style=color:#b48ead;>const char</span><span> ca3 = ca1 + ca2;        </span><span style=color:#65737e;>//错误：试图将两个指针相加。无意义，非法。
</span><span>
</span><span style=color:#65737e;>//正确方法是使用strcat函数和strcpy函数，而且必须提供一个存放结果字符串的数组，
</span><span style=color:#65737e;>//该数组必须足够大，以便容纳字符串以及末尾的空字符
</span><span style=color:#bf616a;>strcpy</span><span>(largeStr, ca1);
</span><span style=color:#bf616a;>strcat</span><span>(largeStr, " ");
</span><span style=color:#bf616a;>strcat</span><span>(largeStr, ca2);
</span></code></pre><p>largeStr数组大小计算错误将引发严重错误，我们在故事largeStr所需的空间时不容易估算准确，而且largeStr所存的内容一旦改变，就必须重新检查其空间是否足够。<p>使用标准库string要比使用C风格字符串更安全、更高效。<h3 id=3-5-5-yu-jiu-dai-ma-de-jie-kou>3.5.5 与旧代码的接口</h3><p>很多C++程序在标准库出现之前就已经写成了，还有一些C++程序实际上是C语言或其它语言的接口程序，它们都没有用C++标准库，因此现代C++程序必须与充满了字符数组或C风格字符串的代码衔接。<p>允许使用字符串字面值来初始化string对象，更一般的情况是，任何出现字符串字面值的地方都可以用空字符结束的字符数组来替代：<ul><li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值<li>在string对象的加法中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）：在string对象的复合赋值运算（+=等）中允许使用以空字符结束的字符数组作为右侧的运算对象</ul><p>上述性质反过来不成立：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>string </span><span style=color:#8fa1b3;>s</span><span>("</span><span style=color:#a3be8c;>Hello world</span><span>");    </span><span style=color:#65737e;>//s的内容是Hello World
</span><span style=color:#b48ead;>char </span><span>*str = s;                </span><span style=color:#65737e;>//错误：不能使用string对象来初始化char*
</span><span style=color:#b48ead;>const char </span><span>*str = s.</span><span style=color:#bf616a;>c_str</span><span>();    </span><span style=color:#65737e;>//正确：string对象通过函数初始化指向字符的指针
</span></code></pre><p>结果指针的类型是const char*，从而确保我们不会改变字符数组的内容。我们无法保证c_str函数返回的数组一直有效，事实上，如果后续操作改变了s的值可能让之前返回的数组失去作用。如果执行完c_str函数后程序相一直能使用其返回的数组，最好将该数组重新拷贝一份。<p>不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象，只需要指明要拷贝区域的首元素地址和尾后元素地址就可以了：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> int_arr[] = {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>3</span><span>,</span><span style=color:#d08770;>4</span><span>,</span><span style=color:#d08770;>5</span><span>};
</span><span>vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>ivec</span><span>(</span><span style=color:#bf616a;>begin</span><span>(int_arr), </span><span style=color:#bf616a;>end</span><span>(int_arr));
</span><span>vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#8fa1b3;>subVec</span><span>(int_arr + </span><span style=color:#d08770;>1</span><span>, int_arr+</span><span style=color:#d08770;>4</span><span>);
</span><span style=color:#65737e;>//int_arr[1]、int_arr[2]、int_arr[3]三个元素
</span></code></pre><p><strong>现代的C++程序应该尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串</strong><h2 id=3-6-duo-wei-shu-zu>3.6 多维数组</h2><p>严格来说，C++没有多维数组，通常所说的多维数组其实是数组的数组。<p>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> ia[</span><span style=color:#d08770;>3</span><span>][</span><span style=color:#d08770;>4</span><span>];    </span><span style=color:#65737e;>//大小为3的数组，每个元素是含有4个整数的数组
</span><span style=color:#65737e;>//大小为10的数组，它的每个元素都是大小为20的数组
</span><span>/这些数组的元素是含有30个整数的数组
</span><span style=color:#b48ead;>int</span><span> arr[</span><span style=color:#d08770;>10</span><span>][</span><span style=color:#d08770;>20</span><span>][</span><span style=color:#d08770;>30</span><span>] = {</span><span style=color:#d08770;>0</span><span>};    </span><span style=color:#65737e;>//将所有元素初始化为0
</span></code></pre><p><strong>按照由内而外的顺序阅读此类定义</strong>有助于更好的理解真实含义。<p>对于二维数组来说，常把第一个维度称作行，第二个维度称作列。<p>允许使用花括号括起来的一组值初始化多维数组：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> ia[</span><span style=color:#d08770;>3</span><span>][</span><span style=color:#d08770;>4</span><span>] = {    </span><span style=color:#65737e;>//三个元素，每个元素都是大小为4的数组
</span><span>    {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>3</span><span>},        </span><span style=color:#65737e;>//第1行的初始值
</span><span>    {</span><span style=color:#d08770;>4</span><span>,</span><span style=color:#d08770;>5</span><span>,</span><span style=color:#d08770;>6</span><span>,</span><span style=color:#d08770;>7</span><span>},        </span><span style=color:#65737e;>//第2行的初始值
</span><span>    {</span><span style=color:#d08770;>8</span><span>,</span><span style=color:#d08770;>9</span><span>,</span><span style=color:#d08770;>10</span><span>,</span><span style=color:#d08770;>11</span><span>}        </span><span style=color:#65737e;>//第3行的初始值
</span><span>};
</span><span style=color:#65737e;>//内层嵌套的花括号并非必须的
</span><span style=color:#b48ead;>int</span><span> ia[</span><span style=color:#d08770;>3</span><span>][</span><span style=color:#d08770;>4</span><span>] = {</span><span style=color:#d08770;>0</span><span>,</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>2</span><span>,</span><span style=color:#d08770;>3</span><span>,</span><span style=color:#d08770;>4</span><span>,</span><span style=color:#d08770;>5</span><span>,</span><span style=color:#d08770;>6</span><span>,</span><span style=color:#d08770;>7</span><span>,</span><span style=color:#d08770;>8</span><span>,</span><span style=color:#d08770;>9</span><span>,</span><span style=color:#d08770;>10</span><span>,</span><span style=color:#d08770;>11</span><span>};    </span><span style=color:#65737e;>//与上面等价
</span><span>
</span><span style=color:#65737e;>//初始化多维数组，并非所有元素的值都必须包含在初始化列表之内
</span><span style=color:#b48ead;>int</span><span> ia[</span><span style=color:#d08770;>3</span><span>][</span><span style=color:#d08770;>4</span><span>] = {{</span><span style=color:#d08770;>0</span><span>}, {</span><span style=color:#d08770;>4</span><span>}, {</span><span style=color:#d08770;>8</span><span>}};    </span><span style=color:#65737e;>//未列出的元素执行默认初始化
</span><span style=color:#65737e;>//这时候省略内层花括号的话，结果大不一样
</span><span style=color:#b48ead;>int</span><span> ix[</span><span style=color:#d08770;>3</span><span>][</span><span style=color:#d08770;>4</span><span>] = {</span><span style=color:#d08770;>0</span><span>, </span><span style=color:#d08770;>3</span><span>, </span><span style=color:#d08770;>6</span><span>, </span><span style=color:#d08770;>9</span><span>};    </span><span style=color:#65737e;>//初始化的是第1行的4个元素，其他元素默认初始化为0
</span></code></pre><p>如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>ia[</span><span style=color:#d08770;>2</span><span>][</span><span style=color:#d08770;>3</span><span>] = arr[</span><span style=color:#d08770;>0</span><span>][</span><span style=color:#d08770;>0</span><span>][</span><span style=color:#d08770;>0</span><span>];    </span><span style=color:#65737e;>//用arr的首元素为ia最后一行的最后一个元素赋值
</span><span style=color:#b48ead;>int </span><span>(&row)[</span><span style=color:#d08770;>4</span><span>] = ia[</span><span style=color:#d08770;>1</span><span>];        </span><span style=color:#65737e;>//把row绑定到ia的第二个4元素数组上
</span></code></pre><p>程序中经常使用两层嵌套的for循环来处理多维数组的元素：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>constexpr </span><span>size_t rowCnt = </span><span style=color:#d08770;>3</span><span>, colCnt = </span><span style=color:#d08770;>4</span><span>;
</span><span style=color:#b48ead;>int</span><span> ia[rowCnt][colCnt];
</span><span style=color:#b48ead;>for</span><span>(size_t i = </span><span style=color:#d08770;>0</span><span>; i != rowCnt; ++i){
</span><span>    </span><span style=color:#b48ead;>for</span><span>(size_t j = </span><span style=color:#d08770;>0</span><span>; j != colCnt; ++j){
</span><span>        ia[i][j] = i * colCnt + j;
</span><span>    }
</span><span>}
</span></code></pre><p>C++11新标准引入的范围for循环可以用于处理多维数组：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>size_t cnt = </span><span style=color:#d08770;>0</span><span>;
</span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto </span><span>&row : ia){
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto </span><span>&col : row){
</span><span>        col = cnt;
</span><span>        ++cnt;
</span><span>    }
</span><span>}
</span></code></pre><p>使用引用，是为了避免数组被自动转换成指针：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto</span><span> row : ia)
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto</span><span> col : row)
</span></code></pre><p>因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素转换成指向该数组内首元素的指针。这样row是int *类型，放在内层循环就不合法了。<p>因此要用范围for语句处理多维数组，除了内层的循环外，其他所有循环的控制变量都应该是引用类型。<p>当程序使用多维数组的名字时，也会自动将其转换成指向<strong>数组首元素</strong>的指针。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> ia[</span><span style=color:#d08770;>3</span><span>][</span><span style=color:#d08770;>4</span><span>];
</span><span style=color:#b48ead;>int </span><span>(*p)[</span><span style=color:#d08770;>4</span><span>] = ia;    </span><span style=color:#65737e;>//p指向含有4个整数的数组
</span><span style=color:#b48ead;>int </span><span>*p[</span><span style=color:#d08770;>4</span><span>];            </span><span style=color:#65737e;>//整型指针的数组
</span><span>p = &ia[</span><span style=color:#d08770;>2</span><span>];            </span><span style=color:#65737e;>//p指向ia的尾元素
</span></code></pre><p>C++11新标准提出，通过使用auto或者decltype就能尽可能地避免在数组前面加上一个指针类型了：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//p指向含有四个整数的数组
</span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto</span><span> p = ia; p != ia + </span><span style=color:#d08770;>3</span><span>; ++p){
</span><span>    </span><span style=color:#65737e;>//q指向4个整数数组的首元素，即q指向一个整数
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto</span><span> q = *p; q != *p + </span><span style=color:#d08770;>4</span><span>; ++q)
</span><span>        cout << *q << ' ';
</span><span>    cout << endl;
</span><span>}
</span><span>
</span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto</span><span> p = </span><span style=color:#bf616a;>begin</span><span>(ia); p != </span><span style=color:#bf616a;>end</span><span>(ia); ++p){
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto</span><span> q = </span><span style=color:#bf616a;>begin</span><span>(*p); q != </span><span style=color:#bf616a;>end</span><span>(*q); ++q)
</span><span>        cout << *q << ' ';
</span><span>    cout << endl;
</span><span>}
</span></code></pre><p>读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名简化多维数组的指针：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>using </span><span>int_array = </span><span style=color:#b48ead;>int</span><span>[</span><span style=color:#d08770;>4</span><span>];
</span><span style=color:#b48ead;>typedef int</span><span> int_array[</span><span style=color:#d08770;>4</span><span>];    </span><span style=color:#65737e;>//等价的typedef声明
</span><span style=color:#b48ead;>for</span><span>(int_array *p = ia; p != ia +</span><span style=color:#d08770;>3</span><span>; ++p){
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int </span><span>*q = *p; q != *p + </span><span style=color:#d08770;>4</span><span>; ++q)
</span><span>        cout << *q << ' ';
</span><span>    cout << endl;
</span><span>}
</span></code></pre><div></div><div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>