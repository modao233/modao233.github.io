<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/Linux/linuxji-chu-ming-ling/>Linux基础命令</a></h1><div class=post-meta-inline><span class=post-date> 2021-01-03 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/linux/>#Linux</a></span><div class=post-content><p>介绍Linux常用命令工具。<h2 id=wen-dang-bang-zhu>文档帮助</h2><p>查看命令简要说明：<code>whatis</code><ul><li>参数-w开启正则匹配</ul><p>查看命令详细说明：<code>info</code><p>strace：strace常用来跟踪进程执行时的系统调用和所接收的信号<p>查看命令说明文档：<code>man</code><ul><li><p>基于命令的功能来搜索命令：man -k</p><li><p>根据命令的名称快速查找命令的功 能：man -f</p><li><p>重建man数据库：man -u</p><li><p>读取命令的特定man page：man [1-8]</p> <ol><li><p>普通命令，如cd、chmod、lp、mkdir和passwd。</p><li><p>由内核提供的底层系统调用，如intro和chmod。</p><li><p>C库函数，如beep、HTML::Parser和Mail::Internet。</p><li><p>特殊文件，如/dev中找到的设备，包括控制台（console）、打 印机（lp）和鼠标（mouse）。</p><li><p>文件格式和约定，如apt.conf、dpkg.cfg、hosts和 passwd。</p><li><p>游戏，如atlantik、bouncingcow、kmahjongg和rubik。</p><li><p>杂项，包括宏包（macro package）。如ascii、samba和utf8。</p><li><p>root用户使用的系统管理命令，如mount和shutdown。</p></ol></ul><p>读取命令的描述：<code>whatis</code>，相当于<code>man -f</code><ul><li>参数-w：开启通配符匹配<li>参数-r：开启正则匹配</ul><p>基于功能查找命令：<code>opropos</code>，相当于<code>man -k</code><ul><li><p>参数-w：开启通配符匹配</p><li><p>参数-r：开启正则匹配</p><li><p>参数-e：开启精确匹配</p></ul><p><code>whereis</code>：查找命令的可执行文件、源文件和 man page的路径<ul><li>参数-b：如果只想搜索二进制文件<li>参数-m：如果只想搜索man page<li>参数-s：如果只想搜索源文件</ul><p><code>which</code>：命名存在多个版本时，找出将要运行的命令的版本<ul><li>参数-a：查找命令的所有位置</ul><h2 id=wen-jian-guan-li>文件管理</h2><p>创建文件，修改时间：<code>touch</code>，touch存在的主要目的是更新文件访问和修改时间<ul><li>参数-a：只更新访问时间<li>参数-m：只更新修改时间<li>参数<code>-t YYYYMMDDhhmm.ss</code>：指定修改时间</ul><p>创建目录：<code>mkdir</code><ul><li>参数-p：逐层建立子目录<li>参数-v：执行时显示执行过程</ul><p>删除：<code>rm</code><ul><li>参数-r、-R表递归子目录<li>参数-v：执行时显示执行过程<li>参数-f表示不询问<li>参数-i表示删除之前询问<li>删除空目录：<code>rmdir</code><li>删除文件和非空的目录：<code>rm -rf</code><li>参数<code>--</code>：跟在后面的任何东西都不能作为选项，而是文件或文件夹 的名称</ul><p>移动：<code>mv</code><ul><li>mv命令实际上执行了一个cp -a操作，在成功复制文件后再移除原有的文件<li>参数-i表示覆盖之前询问<li>参数-v：执行时显示执行过程<li>移动软连接时，在软连接末端加斜杆<code>/</code>移动的是软连接指定的目录，没有斜杆时移动软连接本身</ul><p>复制：<code>cp</code><ul><li><p>参数-r、-R表示递归复制</p><li><p>参数-a表示保留链接和文件属性，并递归子目录，用于制作完整备份，相当于<code>-dpR</code></p><li><p>参数-i表示覆盖之前询问</p><li><p>参数-p表示复制修改时间和访问权限</p><li><p>参数-v：执行时显示执行过程</p></ul><p>显示当前目录：<code>pwd</code><p>切换目录：<code>cd</code><p>列出目录项：<code>ls</code><ul><li>参数-l表示显示详细信息<li>参数-a表示显示隐藏文件<li>参数-R表示递归<li>参数-h以易读方式显示</ul><p>查看文件内容：<ul><li><p><code>cat</code>：从头到尾显示内容，常用来拼接文件</p> <ul><li>参数-n表示显示行号</ul><li><p><code>tac</code>：从尾到头显示内容</p><li><p><code>head</code> ：默认显示文件前10行</p> <ul><li>参数-n 4表示显示前4行的内容<li>参数-n -4表示显示除文件最后4行外的内容<li>参数-c 2表示显示前2个字节的内容<li>参数-c -2表示显示除文件最后2个字节外的内容</ul><li><p><code>tail</code>：默认显示文件后10行</p> <ul><li>参数-n 4表示显示后4行的内容<li>参数-n -4表示显示除文件前面4行外的内容<li>参数-c 2表示显示后2个字节的内容<li>参数-c +2表示显示除文件前2个字节外的内容</ul> <blockquote><p><code>more</code> & <code>less</code>的区别：<ol><li>less可以按键盘上下方向键显示上下内容,more不能通过上下方向键控制显示<li>less不必读整个文件，加载速度会比more更快<li>less退出后shell不会留下刚显示的内容,而more退出后会在shell上留下刚显示的内容</ol></blockquote></ul><p>创建链接：<ul><li><code>ln</code>：硬链接，相对独立<li><code>ln -s</code>：软连接（符号链接），相当于快捷方式</ul><h2 id=sou-suo-cha-zhao>搜索查找</h2><h3 id=gen-ju-zhi-ding-de-tiao-jian-cha-xun-find>根据指定的条件查询：<code>find</code></h3><ul><li><code>find . -name modao</code>：根据文件名modao查找当前目录 <ul><li>搜索使用的是相对路径，结果使用的也是相对路径<li>搜索使用的是绝对路径，结果使用的也是绝对路径</ul><li><code>find . -user modao</code>：根据拥有者搜索文件 <ul><li>搜索结果取反：<code>find . ! -user modao</code></ul><li><code>find . -group modao</code>：根据用户组搜索文件 <ul><li>搜索结果取反：<code>find . ！ -group modao</code></ul><li><code>find . -size 10M</code>：根据文件大小搜索文件 <ul><li>文件大小后缀: <ul><li>b：512字节块，默认值<li>c：字节<li>k：千字节<li>M：兆字节<li>G：吉字节</ul><li>如果要搜索的文件大小大于10 MB，需要在指定的大小 前面加一个加号（+）<li>如果要搜索的文件大小小于10 MB，则需要在 大小前面加一个减号（-）</ul><li><code>find . -type d</code>：根据文件类型搜索文件 <ul><li>f：普通文件<li>d：目录<li>l: 符号（软）链接<li>b：块文件<li>c：字符文件<li>p：管道文件<li>s：套接字</ul><li>参数-a：与，把搜索选项组合起来，当表达式均为true时显示结果<li>参数-o：或，把搜索选项并列起来，当表达式中只有一个为true时就显示结果<li>参数-n：取反，把搜索结果取反，当表达式为not true时显示结果<li>参数-exec：后接一个命令，对搜索到的每个文件执行命令<li>参数-fprint：将搜索结果打印到文件，后面指定文件名</ul><h3 id=sou-suo-wen-jian-ming-shu-ju-ku-locate>搜索文件名数据库：<code>locate</code></h3><p>知道文件的名称，或者名称的一部分，但不记得放在系统的哪个位置。这就是locate命令要解决的问题。locate命令能够在文件、程序和目录中查找与提供的搜索项匹配的内容，并把任何匹配的结果依次显示到终端界面上。<p>搜索结果出来得非常快，因为locate命令并没有对系统进行实时搜 索。实际上，它搜索的是每天自动更新的文件名数据库。因为locate搜索的是早已创建好的数据库，所以搜 索结果几乎能够瞬间显示出来。<p><code>locate</code>：从数据库 <code>(/var/lib/mlocate/mlocate.db) </code>查找命令，使用<code>updatedb</code>更新库。索引查找速度快，需要更新，查找结果是整个路径<ul><li><p><code>locate modao</code>：查找路径，路径内容包含modao</p><li><p>参数-i：不区分大小写的搜索</p><li><p>参数-n：管理搜索文件名数据库时返回的结果，通过指定的数字指定结果个数</p><li><p><code>updatedb</code>：更新locate使用的数据库</p><li><p><code>time updatedb</code>：更新数据库时顺便计时，处理完后显示更新花费的时间。</p><li><p><code>locate -b modao</code>：查找路径，路径基名内容包含modao</p><li><p><code>locate modao modao_test</code>：查找路径，路径内容包含modao<strong>或</strong>modao_test</p><li><p><code>locate -A modao modao_test</code>：查找路径，路径内容包含modao<strong>和</strong>modao_test</p><li><p><code>locate -c modao</code>：查找路径，路径内容包含modao，结果是显示匹配的条目数</p></ul><h3 id=zai-wen-ben-wen-jian-zhong-sou-suo-grep>在文本文件中搜索：<code>grep</code></h3><p>一般用法：<code>grep modao ./dir/*</code><p><img alt=image-20210103203410531 src=Linux%E5%9F%BA%E7%A1%80/image-20210103203410531.png><p>正则表达式中的单引号和双引号的用法也有很大区别。单引号是在告诉shell正在搜索一个字符串，而双引号则是让shell知道想要使用shell变量。<ul><li>如果要搜索精确的匹配结果，就使用单引号；<li>如果要把shell变量结 合到搜索内容中（很少有这样的需要），就使用双引号；<li>但如果搜索 关键字只包含数字和字母，完全不使用任何引号也没有问题。</ul><p>参数-R：递归式地搜索文件中的文本<p>参数-i：搜索文件中的文本，忽略大小写<p>参数-w：在文件中只搜索整个词<p>参数-n：显示搜索结果在文件中的行号<p>参数-v：显示没有包含搜索内容的行<p>参数-l：列出包含搜索内容的文件名<p>在其他命令的输出中搜索特定内容：<code>ls -1 | grep 1960</code><p>在搜索结果中进行搜索：<code>ls -1 | grep 196[6-7] | grep -v Live</code><p>查看文件中搜索内容的上下文信息：<ul><li>-A：搜索结果包括后面n行<li>-B：搜索结果包括前面n行<li>-C：搜索结果包括前面n行和后面n行 <ul><li>配合-n参数使用，通过行号数字后面的字符 <ul><li>为冒号（:）表示匹配行<li>为连字符（-）表示匹配行之前或之后的行</ul></ul></ul><h2 id=zu-he-ming-ling>组合命令</h2><p>分号<code>;</code>创建命令栈：命令栈是将所有需要运行的命令放到shell的一行上，再用分号（;） 隔开每个具体的命令。接着依次<strong>顺序执行</strong>每个命令，只有一个命令结束运行（无论成功或失败），才会运行下一个命令。<p>使用<code>&&</code>代替<code>;</code>来顺序执行命令：只有前面的命令运行<strong>成功</strong>，才运行下一个命令<p>使用<code>||</code>代替<code>;</code>来顺序执行命令：只有前面的命令运行<strong>失败</strong>，才运行下一个命令<p><code>$()</code>：命令替换，将一个命令的输出插入到另一个命令<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>mkdir $(date "+%Y-%m-%d")
</span></code></pre><h3 id=biao-zhun-shu-ru-shu-chu-liu>标准输入输出流</h3><p><code>|</code>：当把它放在两个命令之间时，它可以将第一个命令的输出作为第二个命令的输入。换句话说，|重定向stdout，将它发送到第二个命令的stdin。<p><code>></code>：将命令的输出重定向到文件，覆盖型。为了防止重定向时覆盖文件：<code>set -o noclobber</code>，从现在起，如果要使用重定向并覆盖文件，应该用<code>>|</code>代替<code>></code>。关闭noclobber：<code>set +o noclobber</code>。要一直开着<code>noclobber</code>选项，需要在<code>.bashrc</code>文件中增加一行<code>set -o noclobber</code>。<p><code>>></code>：将命令的输出追加到文件的底部，追加型（如果文件不存在，就会创建它）<p><code><</code>：将文件作为命令的输入<h2 id=wen-ben-chu-li>文本处理</h2><p>sort命令：对文本内容排序<ul><li>-d：按字典序升序排列，空行在前（默认）；<li>-r：降序<li>-b：忽略每行前面开始的空格字符，空格数量不固定时，该选项几乎是必须要使用的；<li>-f：忽略大小写进行排列<li>-h：使用易读性数字（例如：2K、1G）<li>按行中的某个字段排序： <ul><li>-k [n]：n从1开始计数，字段间默认使用空格隔开，默认-k 1<li>+[n]：n从0开始计算，默认+0</ul><li>-n：按照<strong>数值</strong>的大小排序（升序）<li>-o <输出文件>：将排序后的结果存入指定的文件<li>-u：忽略相同行<li>-c：选项检查文件是否已经排好序<li>-t <分割字符>：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符<li>--help：显示帮助<li>--version：显示版本信息</ul><p>uniq命令：比较相邻的行并去掉重复的行，对不相邻的行无效<ul><li>-c：去掉相邻重复的行，并在每列旁边重复该行出现的次数<li>-u：仅显示出现一次的行<li>-d：只显示重复的行<li>[输入文件]：指定已经排好序的文本文件，如果不指定此项，则从标准读取数据<li>[输出文件]：指定输出的文件，如果不指定此选项，则将内容显示到标准输出设备（显示终端）</ul><p>【留空】<p>sed和echo已经另外记录<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666545074&idx=1&sn=7a6f86ae45c5e7254b71da7fcbbdef8d&chksm=80dcfb19b7ab720ff5ffc78d77092b805c54b22839e02fbf4741f06be90845552172258ac978&scene=21#wechat_redirect">Linux 三剑客之 awk 详解</a><h2 id=ci-pan-guan-li>磁盘管理</h2><p>查看磁盘空间：<code>df</code>，默认以B为单位且不显示单位<ul><li>参数-h，易读方式显示（人类可读的（human-readable）），显示单位（M/G）</ul><p>查看<strong>当前</strong>目录所占空间：<code>du</code><ul><li><p>参数-h，易读方式显示</p><li><p>参数-s，只报告目录使用的总空间</p><li><p>查看当前目录下所有子文件夹排序后的大小：</p> <pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#b48ead;>for</span><span> i </span><span style=color:#b48ead;>in </span><span>`</span><span style=color:#bf616a;>ls</span><span>`; </span><span style=color:#b48ead;>do </span><span style=color:#bf616a;>du -sh </span><span>$</span><span style=color:#bf616a;>i</span><span>; </span><span style=color:#b48ead;>done </span><span>| </span><span style=color:#bf616a;>sort
</span><span style=color:#65737e;>## 或者：
</span><span style=color:#bf616a;>du -sh </span><span>`</span><span style=color:#bf616a;>ls</span><span>` | </span><span style=color:#bf616a;>sort
</span></code></pre></ul><p><strong>在linux中归档和压缩和分两步来实现的</strong><p>归档文件：<code>tar</code><ul><li><strong>参数-c：打包选项</strong><li>参数-v：显示进度<li>参数-z：调用gzip程序进行压缩，生成tar.gz<li>参数-j：调用bzip2程序进行压缩，生成tar.bz2<li><strong>参数-f：使用档案文件，后跟文件名</strong></ul><p>解包文件：<code>tar</code><ul><li><strong>参数-x：解包选项</strong><li>参数-v：显示进度<li>参数-z：调用gzip程序进行解压<li>参数-j：调用bzip2程序进行解压<li><strong>参数-f：使用档案文件，后跟文件名</strong></ul><p>测试tarball：参数-t<p>压缩文件 & 解压文件：<ul><li><p><code>gzip</code>，压缩文件后缀为gz结尾，不需要命名压缩文件，压缩后删除原文件</p> <ul><li><p>参数-c：保留原始文件，需要重定向输出</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>gzip -c paradise_lost.txt > paradise_lost.txt.gz
</span></code></pre><li><p>参数-r：递归遍历子目录，默认不递归</p><li><p><code>zcat</code>：不解压查看gz压缩文件</p><li><p>参数-d：解压文件</p><li><p>参数<code>-[0-9]</code>：压缩效果，默认为6</p></ul><li><p><code>gunzip</code>：解压gz压缩文件，解压完后删除压缩文件</p> <ul><li><p>参数-c：保留压缩文件，需要重定向输出</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>gunzip -c paradise_lost.txt.gz > paradise_lost.txt
</span></code></pre><li><p>参数-t：测试压缩文件</p></ul><li><p><code>bzip2</code>：压缩文件后缀为bz2结尾*（比gzip有着更大压缩比）*</p> <ul><li>参数-c：保留原始文件，需要重定向输出<li>参数-k，压缩或解压后保留原文件<li>参数-d，解压bz2压缩文件<li>参数<code>-[0-9]</code>：压缩效果，默认为6<li><code>bzcat</code>：不解压查看bz2压缩文件</ul><li><p><code>bgunzip2</code>：解压bz2压缩文件，解压完后删除压缩文件</p> <ul><li>参数-c：保留压缩文件，需要重定向输出<li>参数-t：测试压缩文件</ul><li><p><code>xz</code>：压缩文件后缀为xz结尾</p> <ul><li>参数-d：解压<li>参数-k：压缩或解压后保留原文件<li>参数-#：压缩比<li><code>unxz</code>：解压<li><code>xzcat</code>：不解压查看</ul><li><p><code>zip</code>：打包压缩工具，<strong>可以压缩目录</strong>，默认不删除原文件：<code>zip [目标zip文件名称] [要加到zip文件的内容]</code></p> <ul><li>参数-r：递归目录<li>参数-d：删除压缩文件中的某个文件<li>参数-m：添加某个文件到压缩文件中<li>压缩效果-[0-9]：数字越大，压缩效果越好<li>参数<code>-P [passwd]</code>：设置压缩密码<li>参数-e：设置压缩密码，交互输入更安全</ul><li><p><code>unzip</code>：解压工具</p> <ul><li>参数-v：显示更多运行时信息<li>参数-l：不解压查看文件内容<li>参数-t：测试待解压文件<li>参数-d：指定解压目录<li>参数-o：不提示，直接覆盖</ul></ul><p><img alt=image-20200718152352629 src=Linux%E5%9F%BA%E7%A1%80/image-20200718152352629.png><h2 id=jin-cheng-guan-li>进程管理</h2><h3 id=ps><code>ps</code></h3><p>查询所有进程信息：<code>ps aux</code><ul><li>a：所有用户<li>u：显示拥有每个进程的用户<li>x：没有控制tty或终端屏幕的进程</ul><p>ps命令显示当前状态（STAT）的种类<ul><li>R：运行<li>S：休眠<li>T：停止<li>Z：僵尸：表示进程已经终止，但父进程无法正常终止它</ul><blockquote><p>Z是个坏消息，因为它意味着进程基本上一直处于挂起状态，不能停止 （幸运的是，这并不意味着没有解决问题的办法）。如果某个程序有 问题，ps标明其状态为Z，这时或许只有重启计算机才能完全关闭这个 程序。<p>kill -9选项对“僵尸”进程也没有效果，这样的进程早已经死掉了，因此kill命令对它也无能为力。重启是唯一能够解决这种问题的办法，不过这样的问题通常是无关紧 要的。</blockquote><p>查看进程树：<code>ps axjf</code><p>查看特定用户拥有的进程：<code>ps U [username]</code><h3 id=kill><code>kill</code></h3><p>发送指定信号到相应进程：<code>kill</code>，默认信息是15，指正常停止，一般操作对象是PID，也可使用%jobs指定作业号<ul><li><p>参数-l，列出全部信号名称</p><li><p>参数-u，为指定用户的所有进程发送信号</p><li><p>参数-s #，指定信号，常缩写为**<code>-#</code>**</p> <p>常用信号：</p> <ul><li>HUP，1，终端短线<li>INT，2，中断（同C-c）<li>QUIT，3，退出（同C-\）<li>TERM，15，默认信号<li><strong>KILL，9，强制终止</strong><li>CONT，18，继续（与STOP相反，<code>fg/bg</code>命令）<li>STOP，19，暂停（同C-z）</ul> <blockquote><ol><li><p>当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息。有时这个信息不会马上显示，只有当按下Enter键使shell的命令提示符再次出现时，才会显示出来。</p><li><p>应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。</p><li><p>要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。</p></ol></blockquote></ul><h3 id=top><code>top</code></h3><p>top命令提供的则是进程的动态更新的视图，展示系统中正在运行着什么进程，以及每个进程正在使用多少系统资源<ul><li><code>top</code>：查看系统中使用CPU、使用内存最多的进程，<strong>交互界面</strong> <ul><li>P：根据CPU使用百分比大小进行排序<li>M：根据驻留内存大小进行排序<li>i：使top不显示任何闲置或者僵死进程<li>k：在top命令中关闭程序</ul><li><code>htop</code>： <ul><li>上左区：显示了CPU、物理内存和交换分区的信息；<li>上右区：显示了任务数量、平均负载和连接运行时间等信息<li>进程区域：显示出当前系统中的所有进程<li>操作提示区：显示了当前界面中F1-F10功能键中定义的快捷功能</ul><li><code>bpytop</code>：可视化程度更高</ul><p>分析线程堆栈：<code>pmap</code>，输出内存的状况<h3 id=lsof><code>lsof</code></h3><p>Linux系统中的所有东西都是文件，包括目录、网络连接和设备<p>列出当前系统打开的所有文件的工具：<code>lsof</code>（list open files的缩写）<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;># 列出所有打开的文件:
</span><span style=color:#bf616a;>lsof
</span><span style=color:#65737e;># 备注: 如果不加任何参数，就会打开所有被打开的文件，内容非常多，可以通过管道传给less
</span><span>
</span><span style=color:#65737e;># 列出某个用户打开的文件
</span><span style=color:#bf616a;>lsof -u</span><span> username
</span><span>
</span><span style=color:#65737e;># 列出除了某个用户外的被打开的文件
</span><span style=color:#bf616a;>lsof -u</span><span> ^username
</span><span>
</span><span style=color:#65737e;># 列出正在使用特定文件的用户
</span><span style=color:#bf616a;>lsof</span><span> /filepath/file
</span><span>
</span><span style=color:#65737e;>#递归查看某个目录的文件信息
</span><span style=color:#bf616a;>lsof</span><span> +D /filepath/filepath2/
</span><span style=color:#bf616a;>lsof </span><span>| </span><span style=color:#bf616a;>grep</span><span> ‘/filepath/filepath2/’
</span><span>
</span><span style=color:#65737e;># 列出特定程序的进程
</span><span style=color:#bf616a;>lsof -c </span><span style=color:#b48ead;>[</span><span>program</span><span style=color:#b48ead;>]
</span><span>
</span><span style=color:#65737e;># 列出多个程序的进程
</span><span style=color:#bf616a;>lsof -c </span><span style=color:#b48ead;>[</span><span>program</span><span style=color:#b48ead;>]</span><span style=color:#bf616a;> -c </span><span style=color:#b48ead;>[</span><span>program</span><span style=color:#b48ead;>]
</span><span>
</span><span style=color:#65737e;># 列出某个用户以及某个程序所打开的文件
</span><span style=color:#bf616a;>lsof -u</span><span> username</span><span style=color:#bf616a;> -c </span><span style=color:#b48ead;>[</span><span>program</span><span style=color:#b48ead;>]
</span><span>
</span><span style=color:#65737e;># 通过某个进程号显示该进行打开的文件
</span><span style=color:#bf616a;>lsof -p</span><span> 1
</span><span>
</span><span style=color:#65737e;># 列出多个进程号对应的文件信息
</span><span style=color:#bf616a;>lsof -p</span><span> 123,456,789
</span><span>
</span><span style=color:#65737e;># 列出除了某个进程号，其他进程号所打开的文件信息
</span><span style=color:#bf616a;>lsof -p</span><span> ^1
</span><span>
</span><span style=color:#65737e;># 列出所有的网络连接
</span><span style=color:#bf616a;>lsof -i
</span><span>
</span><span style=color:#65737e;># 列出所有tcp 网络连接信息
</span><span style=color:#bf616a;>lsof -i</span><span> tcp
</span><span>
</span><span style=color:#65737e;># 列出所有udp网络连接信息
</span><span style=color:#bf616a;>lsof -i</span><span> udp
</span><span>
</span><span style=color:#65737e;># 列出谁在使用某个端口
</span><span style=color:#bf616a;>lsof -i</span><span> :3306
</span><span>
</span><span style=color:#65737e;># 列出谁在使用某个特定的udp端口
</span><span style=color:#bf616a;>lsof -i</span><span> udp:55
</span><span>
</span><span style=color:#65737e;># 特定的tcp端口
</span><span style=color:#bf616a;>lsof -i</span><span> tcp:80
</span><span>
</span><span style=color:#65737e;># 列出某个用户的所有活跃的网络端口
</span><span style=color:#bf616a;>lsof -a -u</span><span> test</span><span style=color:#bf616a;> -i
</span><span>
</span><span style=color:#65737e;># 列出所有网络文件系统
</span><span style=color:#bf616a;>lsof -N
</span><span>
</span><span style=color:#65737e;>#域名socket文件
</span><span style=color:#bf616a;>lsof -u
</span><span>
</span><span style=color:#65737e;>#某个用户组所打开的文件信息
</span><span style=color:#bf616a;>lsof -g</span><span> 5555
</span><span>
</span><span style=color:#65737e;># 根据文件描述列出对应的文件信息
</span><span style=color:#bf616a;>lsof -d</span><span> description(like 2)
</span><span>
</span><span style=color:#65737e;># 根据文件描述范围列出文件信息
</span><span style=color:#bf616a;>lsof -d</span><span> 2-3
</span></code></pre><blockquote><p><a href=https://blog.csdn.net/qq_27870421/article/details/92803453>Linux lsof命令</a><p><a href=https://www.jianshu.com/p/a3aa6b01b2e1>Linux 命令神器：lsof</a></blockquote><p>使用文件或文件结构识别进程：<code>fuser</code><ul><li><p><strong>fuser命令</strong> 用于报告进程使用的文件和网络套接字。fuser命令列出了本地进程的进程号，那些本地进程使用file，参数指定的本地或远程文件。对于阻塞特别设备，此命令列出了使用该设备上任何文件的进程。</p><li><p>每个进程号后面都跟随一个字母，该字母指示进程如何使用文件。</p> <ul><li>c：指示进程的工作目录。<li>e：指示该文件为进程的可执行文件(即进程由该文件拉起)。<li>f：指示该文件被进程打开，默认情况下f字符不显示。<li>F：指示该文件被进程打开进行写入，默认情况下F字符不显示。<li>r：指示该目录为进程的根目录。<li>m：指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存。</ul> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>语法：fuser(选项)(参数)
</span><span>
</span><span>选项：
</span><span>-a：显示命令行中指定的所有文件；
</span><span>-c：和-m一样，用于POSIX兼容；
</span><span>-s：静默模式，这时候-u,-v会被忽略。-a不能和-s一起使用；
</span><span>-k：杀死访问指定文件的所有进程，如果没有指定-signal就会发送SIGKILL信号；
</span><span>-signal：使用指定的信号，而不是用SIGKILL来杀掉进程。可以通过名称或者号码来表示信号(例如-HUP,-1),这个选项要和-k一起使用，否则会被忽略；
</span><span>-i：杀死进程前需要用户进行确认；
</span><span>-l：列出所有已知信号名；
</span><span>-m name：指定一个被加载的文件系统或一个被加载的块设备,这样所有访问这个文件或者文件系统的进程都会被列出来。如果指定的是一个目录会自动转换成"name/",并使用所有挂载在那个目录下面的文件系统；
</span><span>-n space：选择不同的名称空间，这里支持不同的空间文件(文件名，此处默认)、tcp(本地tcp端口)、udp(本地udp端口)。对于端口， 可以指定端口号或者名称，如果不会引起歧义那么可以使用简单表示的形式，例如：name/space (即形如:80/tcp之类的表示)；
</span><span>-u：在每个进程后显示所属的用户名；
</span><span>-v：详细模式。输出似ps命令的输出，包含PID,USER,COMMAND等许多域,如果是内核访问的那么PID为kernel.  -V 输出版本号。 
</span><span>-4：使用IPV4套接字,不能和-6一起应用，只在-n的tcp和udp的命名存在时不被忽略。  
</span><span>-6：使用IPV6套接字,不能和-4一起应用，只在-n的tcp和udp的命名存在时不被忽略。  
</span><span>-：重置所有的选项，把信号设置为SIGKILL.  
</span><span>
</span><span>参数：文件，可以是文件名或者TCP、UDP端口号。
</span><span>
</span><span>#列出使用/etc/passwd文件的本地进程的进程号
</span><span>fuser /etc/passwd
</span><span>
</span><span>#列出使用/etc/filesystems文件的进程信息
</span><span>fuser -um /etc/filesystems
</span><span>
</span><span>#杀掉打开readme文件的程序
</span><span>fuser -m -k -i readme
</span><span>
</span><span>#查看那些程序使用tcp的80端口 
</span><span>fuser -v -n tcp 80  
</span><span>fuser -v 80/tcp  
</span><span>
</span><span>#用 -l参数可以列出fuser所知的信号
</span><span>fuser -l
</span><span>
</span><span>#终止使用给定文件系统的所有进程
</span><span>fuser -k -x -u -c /dev/hd1
</span><span>fuser -kxuc /home
</span><span>
</span><span>命令会列出了进程号和用户名，然后终止每个正在使用/dev/hd1 (/home)文件系统的进程。仅有root用户能终止属于另一用户的进程。如果您正在试图卸下/dev/hd1文件系统，而一个正在访问/dev/hd1文件系统的进程不允许这样，您可能希望使用此命令。
</span><span>
</span><span>#列出正在使用已从给定文件系统删除的文件的全部进程
</span><span>fuser -d /usr文件
</span><span>
</span><span>/dev/kmem 用于系统映像。
</span><span>/dev/mem 也用于系统映像。
</span></code></pre></ul><p>pgrep<h2 id=xing-neng-jian-kong>性能监控</h2><p>CPU监控：<code>top</code><p>内存监控：<code>free</code><ul><li>参数-m，以MB为单位<li>参数-k，以KB为单位<li>参数-g，以GB为单位</ul><p>综合监控工具：<code>vmstat</code><ul><li>参数 <ul><li>参数1：刷新时间<li>参数2：采集次数</ul><li>字段 <ul><li>procs <ul><li>r：等待执行的任务数<li>B：等待IO的进程数量</ul><li>memory <ul><li>swpd：正在使用虚拟的内存大小，单位k<li>free：空闲内存大小<li>buff：已用的buff大小，对块设备的读写进行缓冲<li>cache：已用的cache大小，文件系统的cache</ul><li>swap <ul><li>si：每秒从交换区写入内存的大小（单位：kb/s）<li>so：每秒从内存写到交换区的大小</ul><li>IO <ul><li>bi：每秒读取的块数（读磁盘）<li>bo：每秒写入的块数（写磁盘）</ul><li>system <ul><li>in：每秒中断数，包括时钟中断<li>cs：每秒上下文切换数</ul><li>CPU <ul><li>us：用户进程执行消耗cpu时间(user time)<li>sy：系统进程消耗cpu时间(system time)<li>id：空闲时间(包括IO等待时间)<li>wa：等待IO时间<li>st：Time stolen from a virtual machine. Prior to Linux 2.6.11, unknown</ul></ul></ul><p>超级监控工具：<code>dstat</code><ul><li>常用：<code>dstat -clmnsygdr</code></ul><h2 id=wang-luo-gong-ju>网络工具</h2><p>查看网络接口状态：<code>ifconfig</code><ul><li>参数-a：显示全部的接口，包括未启用的接口</ul><p>配置网络接口：<code>ifconfig</code><pre style=background-color:#2b303b;color:#c0c5ce;><code><span># eth0上的以太网卡的IP地址修改为192.168.0.125，
</span><span>ifconfig eth0 192.168.0.125
</span><span>
</span><span># 为了运行某种类型的网络数据包嗅探工具（如强大的Ethereal），
</span><span># 需要首先将网卡设置为混杂（promiscuous）模式。
</span><span>ifconfig eth0 promisc
</span><span>
</span><span># 关闭混杂模式
</span><span>ifconfig eth0 -promisc
</span><span>
</span><span># 修改［或“欺骗（spoff）”］网络设备的硬件MAC地址
</span><span># 修改MAC地址时要小心，因为万一出错，就可能与其他网络设备发生冲突，引发问题
</span><span># 首先一定要用ifconfig获得设备的默认MAC地址，以便以后可以把默认的MAC地址再修改回来
</span><span>ifconfig eth0 hw ether 00:14:CC:00:1A:00
</span></code></pre><p>查看无线网络接口的状态：<code>iwconfig</code>，可以尽可能多地得到与无线网卡相关的数据<p>配置无线网络接口：<code>iwconfig</code><p>验证计算机能否联网：<code>ping</code>，发送ICMP消息<ul><li>参数-c：指定发送次数</ul><p>追踪路由：<code>traceroute</code>，默认路由跳数为30<ul><li>参数-m：设置路由跳数</ul><p>执行DNS查询：<code>host</code><ul><li><code>host [域名]</code>：查域名关联的IP地址<li><code>host [IP]</code>：查IP地址关联的域名</ul><p>使用DHCP获得新的网络地址：<code>dhclient</code><ul><li>手动发起DHCP请求：<code>dhclient eth0</code><li>释放（或放弃）DHCP服务器分配的IP地址：<code>dhclient -r eth0</code></ul><p>启动网络连接：<code>ifup [interface]</code><ul><li>也可以使用<code>ifconfig [interface] up</code>或<code>iwconfig [interface] up</code>启动有线或无线网络连接</ul><p>关闭网络连接：<code>ifdown [interface]</code><ul><li>也可以使用<code>ifconfig [interface] down</code>或<code>iwconfig [interface] down</code>关闭有线或无线网络连接。</ul><p>显示IP路由表、修改IP路由表：<code>route</code><h3 id=ss>ss</h3><p>ss是Socket Statistics的缩写。顾名思义，ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。<p>当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。<p>ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。<p>使用方式：<ul><li><code>ss [选项]</code><li><code>ss [选项] [过滤条件]</code></ul><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>   -h, --help           this message
</span><span>   -V, --version        output version information
</span><span>   -n, --numeric        don't resolve service names
</span><span>   -r, --resolve       	resolve host names
</span><span>   -a, --all            display all sockets
</span><span>   -l, --listening      display listening socket
</span><span>   -o, --options       	show timer information
</span><span>   -e, --extended     	show detailed socket information
</span><span>   -m, --memory        	show socket memory usage
</span><span>   -p, --processes      show process using socket
</span><span>   -i, --info           show internal TCP information
</span><span>   -s, --summary        show socket usage summary
</span><span> 
</span><span>   -4, --ipv4          	display only IP version 4 sockets
</span><span>   -6, --ipv6          	display only IP version 6 sockets
</span><span>   -0, --packet display PACKET sockets
</span><span>   -t, --tcp            display only TCP sockets
</span><span>   -u, --udp            display only UDP sockets
</span><span>   -d, --dccp           display only DCCP sockets
</span><span>   -w, --raw            display only RAW sockets
</span><span>   -x, --unix           display only Unix domain sockets
</span><span>   -f, --family=FAMILY 	display sockets of type FAMILY
</span><span> 
</span><span>   -A, --query=QUERY, --socket=QUERY
</span><span>       QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]
</span><span> 
</span><span>   -D, --diag=FILE      Dump raw information about TCP sockets to FILE
</span><span>   -F, --filter=FILE   	read filter information from FILE
</span><span>       FILTER := [ state TCP-STATE ] [ EXPRESSION ]
</span></code></pre><p>常用命令：<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;># 显示所有TCP socket
</span><span style=color:#bf616a;>ss -t -a
</span><span style=color:#65737e;># 显示所有UDP socket
</span><span style=color:#bf616a;>ss -u -a
</span><span style=color:#65737e;># 列出所有打开的网络连接端口
</span><span style=color:#bf616a;>ss -l
</span><span style=color:#65737e;># 显示每个进程打开的socket
</span><span style=color:#bf616a;>ss -pl
</span><span style=color:#65737e;># 显示所有已建立的SMTP连接
</span><span style=color:#bf616a;>ss -o</span><span> state established '</span><span style=color:#a3be8c;>( dport = :smtp or sport = :smtp )</span><span>'
</span><span style=color:#65737e;># 显示所有已建立的HTTP连接
</span><span style=color:#bf616a;>ss -o</span><span> state established '</span><span style=color:#a3be8c;>( dport = :http or sport = :http )</span><span>'
</span><span style=color:#65737e;># 找出所有连接X服务器的进程
</span><span style=color:#bf616a;>ss -X</span><span> src /tmp/.X11-unix/*
</span><span style=color:#65737e;># 列出当前socket(已连接、关闭、等待)详细信息
</span><span style=color:#bf616a;>ss -s
</span></code></pre><p>ss常用的state状态：<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>established
</span><span>syn-sent
</span><span>syn-recv
</span><span>fin-wait-1
</span><span>fin-wait-2
</span><span>time-wait
</span><span>closed
</span><span>close-wait
</span><span>last-ack
</span><span>listen
</span><span>closing
</span><span>all : All of the above states
</span><span>connected : All the states except for listen and closed
</span><span>synchronized : All the connected states except for syn-sent
</span><span>bucket : Show states, which are maintained as minisockets, i.e. time-wait and syn-recv.
</span><span>big : Opposite to bucket state.
</span></code></pre><p>ss使用IP地址筛选：<code>ss src ADDRESS_PATTERN</code><ul><li><p>src：表示来源</p><li><p>ADDRESS_PATTERN：表示地址规则</p><li><p>示例：</p> <pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;># 列出来之20.33.31.1的连接
</span><span style=color:#bf616a;>ss</span><span> src 120.33.31.1
</span><span style=color:#65737e;># 列出来至120.33.31.1,80端口的连接
</span><span style=color:#bf616a;>ss</span><span> src 120.33.31.1:http
</span><span style=color:#bf616a;>ss</span><span> src 120.33.31.1:80
</span></code></pre></ul><p>ss使用端口筛选：<code>ss (dport | sport) OP PORT</code><ul><li><p>OP：运算符</p> <ul><li><code><=</code> or <code>le</code>：小于等于<li><code>>=</code> or <code>ge</code>：大于等于<li><code>==</code> or <code>eq</code>：等于<li><code>!=</code> or <code>ne</code>：不等于<li><code><</code> or <code>lt</code>：小于<li><code>></code> or <code>gt</code>：大于</ul><li><p>PORT：端口</p><li><p>过滤端口</p> <ul><li><code>dport</code>：过滤目标端口<li><code>sport</code>：过滤源端口</ul><li><p>示例：</p> <pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>ss</span><span> sport = :http 也可以是 ss sport = :80
</span><span style=color:#bf616a;>ss</span><span> dport = :http
</span><span style=color:#bf616a;>ss</span><span> dport </span><span style=color:#96b5b4;>\></span><span> :1024
</span><span style=color:#bf616a;>ss</span><span> sport </span><span style=color:#96b5b4;>\></span><span> :1024
</span><span style=color:#bf616a;>ss</span><span> sport </span><span style=color:#96b5b4;>\<</span><span> :32000
</span><span style=color:#bf616a;>ss</span><span> sport eq :22
</span><span style=color:#bf616a;>ss</span><span> dport != :22
</span><span style=color:#bf616a;>ss</span><span> state connected sport = :http
</span><span style=color:#bf616a;>ss </span><span style=color:#96b5b4;>\(</span><span> sport = :http or sport = :https </span><span style=color:#96b5b4;>\)
</span><span style=color:#bf616a;>ss -o</span><span> state fin-wait-1 </span><span style=color:#96b5b4;>\(</span><span> sport = :http or sport = :https </span><span style=color:#96b5b4;>\)</span><span> dst 192.168.1/24
</span></code></pre></ul><blockquote><p>为什么ss比netstat快? netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多</blockquote><h2 id=yong-hu-guan-li>用户管理</h2><p>添加用户：<code>useradd -m [username] -s [/bin/bash]</code><p>设置密码：<code>passwd [username]</code><p>删除用户：<code>userdel [username]</code><ul><li>参数-r，删除用户并删除用户信息</ul><p>切换用户：<code>su [username]</code><ul><li><code>su -l [uwername]</code>变更到其他用户，包括其环境变量<li><code>su</code>：变更到root用户<li><code>su -</code>：变更到root用户，包括其环境变量</ul><p>查看当前用户所属组：<code>groups</code><p>将用户添加到组：<code>usermod -G [groupname] [username]</code><p>变更用户所在组：<code>usermod -g [groupname] [username]</code>，添加到新组，从旧组中删除<p>查看所有用户及权限：<code>less /etc/passwd</code><p>查看所有用户组及权限：<code>less /etc/group</code><p>修改文件或目录属于的用户组：<code>chgrp</code><ul><li>修改文件：<code>chgrp [用户组名称/ID] 文件</code><li>递归修改目录：<code>chgrp -R [用户组名称/ID] 文件</code><li>参数-v：执行时显示执行过程<li>参数-c：只显示修改过的内容</ul><p>同时修改文件和目录的拥有者和用户组：<code>chown owner:group</code>，甚至可以省略owner实现修改用户组，被修改的文件或目录有<code>:</code>则使用反斜杠转义。<ul><li>参数-R：递归修改</ul><p>更改文件和目录的权限：<code>chmod [userMark](+|-|=)[PermissionsMark]</code><ul><li><code>userMark</code>取值： <ul><li>u：拥有者<li>g：拥有者所在组<strong>之内</strong>的其它用户<li>o：拥有者所在组<strong>之外</strong>的其它用户<li>a：所有用户</ul><li><code>PermissionsMark</code>取值： <ul><li>r：读，4<li>w：写，2<li>x：执行，1</ul><li>参数-R：递归修改</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>chmod</span><span> a+x main         对所有用户给文件main增加可执行权限
</span><span style=color:#bf616a;>chmod</span><span> g+w blogs        对组用户给文件blogs增加可写权限
</span><span style=color:#bf616a;>chmod</span><span> o= test		   删除系统中所有其他用户的所有权限
</span><span style=color:#65737e;># 数字方式
</span><span style=color:#bf616a;>chmod</span><span> 740 main     将main的用户权限设置为rwxr-----
</span><span>
</span><span style=color:#65737e;># 更改文件拥有者
</span><span style=color:#bf616a;>chown</span><span> username dirOrFile
</span><span style=color:#65737e;># 更改目录拥有者（-R选项递归更改）
</span><span style=color:#bf616a;>chown -R</span><span> weber server/
</span></code></pre><blockquote><p>可以对文件或目录使用chmod 000，但是那样的话，唯一能 够对它进行任何操作或再使用chmod命令修改权限的用户就只有 root了。</blockquote><h2 id=huan-jing-bian-liang>环境变量</h2><p>Bash快捷操作:<ul><li><code>C-u</code>：删除光标到行首的所有字符，在某些设置下，删除全行<li><code>C-w</code>：删除当前光标到前边的最近一个空格之间的字符（保留空格后面的字符）<li><code>C-H</code>：删除光标前边的字符，相当于退格键</ul><p>用户环境信息配置文件，保存于用户主目录：<ul><li><code>.bashrc</code>：用于交互式<code>non-loginshell</code><li><code>.profile</code>：用于交互式<code>login shell</code></ul><blockquote><p><code>~/.profile</code>与<code>~/.bashrc</code>的区别:<ul><li>这两者都具有个性化定制功能<li><code>~/.profile</code>可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次<li><code>~/.bashrc</code>也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次</ul></blockquote><p>系统全局环境信息配置文件，保存于<code>/etc</code>目录：<ul><li><code>/etc/profile</code><li><code>/etc/bashrc</code></ul><blockquote><p>当登入系统获得一个shell进程时，其读取环境设置脚本分为三步:<ol><li>首先读入的是全局环境变量设置文件<code>/etc/profile</code>，然后根据其内容读取额外的文档，如<code>/etc/profile.d</code>和<code>/etc/inputrc</code><li>读取当前登录用户Home目录下的文件<code>~/.bash_profile</code>，其次读取<code>~/.bash_login</code>，最后读取<code>~/.profile</code>，这三个文档设定基本上是一样的，读取有优先关系<li>读取<code>~/.bashrc</code></ol></blockquote><h2 id=xi-tong-guan-li>系统管理</h2><p>查看Linux系统版本：<ul><li><code>uname -a</code><li><code>lsb_release -a</code>，等价于<code>more /etc/lsb-release</code><li><code>more /etc/os-release</code></ul><p>查看CPU信息：<code>cat /proc/cpuinfo</code><p>查看CPU核心：<code>cat /proc/cpuinfo | grep processor | wc -l</code><p>查看内存信息：<code>cat /proc/meminfo</code><p>查看架构：<code>arch</code><p>系统时间：<code>date</code><ul><li>参数-s，设置系统日期和时间（格式如：2000-12-30 13:02:00）<li>格式化输出：<code>date +%Y%m%d.%H%M%S</code></ul><p>设置时区：<code>tzselect</code><p>将系统时间写入CMOS：<code>clock -w</code><h2 id=zhu-yao-can-kao>主要参考</h2><p><a href=https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html>Linux工具快速教程</a><blockquote><p>本文命令测试环境：Ubuntu 18.04 x86_64</blockquote></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>