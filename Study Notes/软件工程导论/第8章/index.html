<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「生活可以更简单, 欢迎来到我的开源世界」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">软件维护的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">软件维护的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%B4%E6%8A%A4%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%B4%E6%8A%A4%E5%B7%AE%E5%88%AB%E5%B7%A8%E5%A4%A7"><span class="toc-text">结构化维护与非结构化维护差别巨大</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%B4%E6%8A%A4"><span class="toc-text">1. 非结构化维护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%B4%E6%8A%A4"><span class="toc-text">2. 结构化维护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%B8%A6%E4%BB%B7%E9%AB%98%E6%98%82"><span class="toc-text">维护的带价高昂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E7%9A%84%E9%97%AE%E9%A2%98%E5%BE%88%E5%A4%9A"><span class="toc-text">维护的问题很多</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">软件维护的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%B4%E6%8A%A4%E7%BB%84%E7%BB%87"><span class="toc-text">1. 维护组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%B4%E6%8A%A4%E6%8A%A5%E5%91%8A"><span class="toc-text">2. 维护报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">3. 维护的事件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%9D%E5%AD%98%E7%BB%B4%E6%8A%A4%E8%AE%B0%E5%BD%95"><span class="toc-text">4. 保存维护记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%84%E4%BB%B7%E7%BB%B4%E6%8A%A4%E6%B4%BB%E5%8A%A8"><span class="toc-text">5. 评价维护活动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="toc-text">软件的可维护性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B3%E5%AE%9A%E8%BD%AF%E4%BB%B6%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-text">决定软件可维护性的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7"><span class="toc-text">1. 可理解性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7"><span class="toc-text">2. 可测试性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7"><span class="toc-text">3. 可修改性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-text">4. 可移植性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7"><span class="toc-text">5. 可重用性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3"><span class="toc-text">文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%A4%8D%E5%AE%A1"><span class="toc-text">可维护性复审</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%80%A7%E7%BB%B4%E6%8A%A4"><span class="toc-text">预防性维护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%86%8D%E5%B7%A5%E7%A8%8B%E8%BF%87%E7%A8%8B"><span class="toc-text">软件再工程过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BA%93%E5%AD%98%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90"><span class="toc-text">1. 库存目录分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%87%E6%A1%A3%E9%87%8D%E6%9E%84"><span class="toc-text">2. 文档重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="toc-text">3. 逆向工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84"><span class="toc-text">4. 代码重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E9%87%8D%E6%9E%84"><span class="toc-text">5. 数据重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%AD%A3%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="toc-text">6. 正向工程</span></a></li></ol></li></ol>
</div>

<div class="content-area">
	<div class="title">
		第8章 维护
	</div>
	
	<div class="page-date">
		2020-04-20
	</div>
	
	<div class="category-area">
		
			 
				「
				<div class="category">
					<a href="/categories/Study Notes">Study Notes</a>
				
				</div>
				」
			 
				「
				<div class="category">
					<a href="/categories/软件工程导论">软件工程导论</a>
				
				</div>
				」
			
		
	</div>
	
	<div class="content">
		<p>第8章 维护</p>
<span id="more"></span>

<p>在软件产品被开发出来并交付用户使用之后，就进入了软件的运行维护阶段。</p>
<p><strong>软件工程的目的是要提高软件的可维护性，减少软件维护所需要的工作量，降低软件系统的总成本。</strong></p>
<h2 id="软件维护的定义"><a href="#软件维护的定义" class="headerlink" title="软件维护的定义"></a>软件维护的定义</h2><p>软件维护就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。</p>
<p>软件维护的四项活动：</p>
<ol>
<li> <strong>改正性维护</strong>：诊断和改正错误的过程。</li>
<li> <strong>适应性维护</strong>：为了和变化了的环境适当地配合而进行的修改软件的活动。</li>
<li> <strong>完善性维护</strong>：在使用软件的过程中，用户往往提出增加新功能或修改已有功能的建议，还可能提出一般性的改进意见，为了满足这类要求而修改软件的活动。</li>
<li> <strong>预防性维护</strong>：为了改进未来的可维护性或可靠性，而主动地修改软件。</li>
</ol>
<h2 id="软件维护的特点"><a href="#软件维护的特点" class="headerlink" title="软件维护的特点"></a>软件维护的特点</h2><h3 id="结构化维护与非结构化维护差别巨大"><a href="#结构化维护与非结构化维护差别巨大" class="headerlink" title="结构化维护与非结构化维护差别巨大"></a>结构化维护与非结构化维护差别巨大</h3><h4 id="1-非结构化维护"><a href="#1-非结构化维护" class="headerlink" title="1. 非结构化维护"></a>1. 非结构化维护</h4><p>非结构化维护需要付出很大代价(浪费精力并且遭受挫折的打击)，这种维护方式是没有使用良好定义的方法学开发出来的软件的必然结果。</p>
<h4 id="2-结构化维护"><a href="#2-结构化维护" class="headerlink" title="2. 结构化维护"></a>2. 结构化维护</h4><p>以完整的软件配置为基础的结构化维护，是在软件开发过程中应用软件工程方法学的结果。虽然有了软件的完整配置并不能保证维护中没有问题，但是确实能减少精力的浪费并且能提高维护的总体质量。</p>
<h3 id="维护的带价高昂"><a href="#维护的带价高昂" class="headerlink" title="维护的带价高昂"></a>维护的带价高昂</h3><h3 id="维护的问题很多"><a href="#维护的问题很多" class="headerlink" title="维护的问题很多"></a>维护的问题很多</h3><h2 id="软件维护的过程"><a href="#软件维护的过程" class="headerlink" title="软件维护的过程"></a>软件维护的过程</h2><p>维护过程本质上是修改和压缩了的软件定义和开发过程，而且事实上远在提出一项维护要求之前，与软件维护有关的工作已经开始了。</p>
<p>首先必须建立一个维护组织，随后必须确定报告和评价的过程，而且必须为每个维护要求规定一个标准化的事件序列。此外，还应该建立一个适用于维护活动的记录保管过程，并且规定复审标准。</p>
<h3 id="1-维护组织"><a href="#1-维护组织" class="headerlink" title="1. 维护组织"></a>1. 维护组织</h3><h3 id="2-维护报告"><a href="#2-维护报告" class="headerlink" title="2. 维护报告"></a>2. 维护报告</h3><h3 id="3-维护的事件流"><a href="#3-维护的事件流" class="headerlink" title="3. 维护的事件流"></a>3. 维护的事件流</h3><p>不管维护类型如何，都需要进行同样的技术工作。这些工作包括修改软件设计、复查、必要的代码修改、单元测试和集成测试(包括使用以前的测试方案的回归测试)、验收测试和复审。</p>
<p><img src="1.png" alt="image-20200508135923905"></p>
<h3 id="4-保存维护记录"><a href="#4-保存维护记录" class="headerlink" title="4. 保存维护记录"></a>4. 保存维护记录</h3><h3 id="5-评价维护活动"><a href="#5-评价维护活动" class="headerlink" title="5. 评价维护活动"></a>5. 评价维护活动</h3><h2 id="软件的可维护性"><a href="#软件的可维护性" class="headerlink" title="软件的可维护性"></a>软件的可维护性</h2><p>可以把软件的可维护性定性地定义为： 维护人员理解、改正、改动或改进这个软件的难易程度。</p>
<h3 id="决定软件可维护性的因素"><a href="#决定软件可维护性的因素" class="headerlink" title="决定软件可维护性的因素"></a>决定软件可维护性的因素</h3><h4 id="1-可理解性"><a href="#1-可理解性" class="headerlink" title="1. 可理解性"></a>1. 可理解性</h4><p>软件可理解性表现为外来读者理解软件的结构、功能、接口和内部处理过程的难易程度。模块化（模块结构良好，高内聚，松耦合）、详细的设计文档、结构化设计、程序内部的文档和良好的高级程序设计语言等等，都对提高软件的可理解性有重要贡献。</p>
<h4 id="2-可测试性"><a href="#2-可测试性" class="headerlink" title="2. 可测试性"></a>2. 可测试性</h4><p>诊断和测试的容易程度取决于软件容易理解的程度。良好的文档对诊断和测试是至关重要的，此外，软件结构、可用的测试工具和调试工具，以及以前设计的测试过程也都是非常重要的。维护人员应该能够得到在开发阶段用过的测试方案，以便进行回归测试。在设计阶段应该尽力把软件设计成容易测试和容易诊断的。</p>
<h4 id="3-可修改性"><a href="#3-可修改性" class="headerlink" title="3. 可修改性"></a>3. 可修改性</h4><p>软件容易修改的程度和设计原理及启发规则直接有关。模块化、耦合、内聚、信息隐藏等等，都影响软件的可修改性。</p>
<h4 id="4-可移植性"><a href="#4-可移植性" class="headerlink" title="4. 可移植性"></a>4. 可移植性</h4><p>软件可移植性指的是，把程序从一种计算环境（硬件配置和操作系统）转移到另一种计算环境的难易程度。</p>
<h4 id="5-可重用性"><a href="#5-可重用性" class="headerlink" title="5. 可重用性"></a>5. 可重用性</h4><p>重用（reuse）是指同一事物不做修改或稍加改动就在不同环境中多次重复使用。</p>
<p>大量使用可重用的软件构件来开发软件，可以从下述两个方面提高软件的可维护性：</p>
<ol>
<li> 通常，可重用的软件构件在开发时经过很严格的测试，可靠性比较高，且在每次重用过程中都会发现并清除一些错误，随着时间推移，这样的构件将变成无错误的。因此，软件中使用的可重用构件越多，软件的可靠性越高，改正性维护需求越少。</li>
<li> 很容易修改可重用的软件构件使之再次应用在新环境中，因此，软件中使用的可重用构件越多，适应性和完善性维护也就越容易。</li>
</ol>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><strong>文档是影响软件可维护性的决定因素。</strong>由于长期使用的大型软件系统在使用过程中必然会经受多次修改，所以文档比程序代码更重要。</p>
<p>软件系统的文档可以分为用户文档和系统文档两类。用户文档主要描述系统功能和使用方法，并不关心这些功能是怎样实现的；系统文档描述系统设计、实现和测试等各方面的内容。</p>
<p>总的说来，软件文档应该满足下述要求：</p>
<ol>
<li> 必须描述如何使用这个系统，没有这种描述时即使是最简单的系统也无法使用</li>
<li> 必须描述怎样安装和管理这个系统</li>
<li> 必须描述系统需求和设计</li>
<li> 必须描述系统的实现和测试，以便使系统成为可维护的</li>
</ol>
<h3 id="可维护性复审"><a href="#可维护性复审" class="headerlink" title="可维护性复审"></a>可维护性复审</h3><p>可维护性是所有软件都应该具备的基本特点，在软件工程过程的每一个阶段都应该考虑并努力提高软件的可维护性，在每个阶段结束前的技术审查和管理复审中，应该着重对可维护性进行复审。</p>
<p>在测试结束时进行最正式的可维护性复审，这个复审称为配置复审。配置复审的目的是保证软件配置的所有成分是完整的、一致的和可理解的，而且为了便于修改和管理已经编目归档了。</p>
<p>维护应该针对整个软件配置，不应该只修改源程序代码。当对源程序代码的修改没有反映在设计文档或用户手册中时，就会产生严重的后果。</p>
<h2 id="预防性维护"><a href="#预防性维护" class="headerlink" title="预防性维护"></a>预防性维护</h2><p>预防性维护方法是由Miller提出来的，他把这种方法定义为：“把今天的方法学应用到昨天的系统上，以支持明天的需求。”</p>
<p>粗看起来，在一个正在工作的程序版本已经存在的情况下重新开发一个大型程序，似乎是一种浪费。其实不然，下述事实很能说明问题：</p>
<ol>
<li> 维护一行源代码的代价可能是最初开发该行源代码代价的14~40倍</li>
<li> 重新设计软件体系结构（程序及数据结构）时使用了现代设计概念，它对将来的维护可能有很大的帮助</li>
<li> 由于现有的程序版本可作为软件原型（现在正在工作的程序）使用，开发生产率可大大高于平均水平</li>
<li> 用户具有较多使用该软件的经验，因此，能够很容易地搞清新的变更需求和变更的范围</li>
<li> 利用逆向工程和再工程的工具，可以使一部分工作自动化</li>
<li> 在完成预防性维护的过程中可以建立起完整的软件配置（文档、程序和数据）</li>
</ol>
<h2 id="软件再工程过程"><a href="#软件再工程过程" class="headerlink" title="软件再工程过程"></a>软件再工程过程</h2><p>预防性维护实质上是软件再工程。</p>
<p>典型的软件再工程过程模型如图所示，该模型定义了6类活动。在某些情况下这些活动以线性顺序发生，但也并非总是这样，例如，为了理解某个程序的内部工作原理，可能在文档重构开始之前必须先进行逆向工程。</p>
<p>在图中显示的再工程范型是一个循环模型。这意味着作为该范型的组成部分的每个活动都可能被重复，而且对于任意一个特定的循环来说，过程可以在完成任意一个活动之后终止。</p>
<p><img src="2.png" alt="image-20200508143837187"></p>
<h3 id="1-库存目录分析"><a href="#1-库存目录分析" class="headerlink" title="1. 库存目录分析"></a>1. 库存目录分析</h3><p>对库中每个程序都做逆向工程或再工程是不现实的。</p>
<p>下述3类程序有可能成为预防性维护的对象：</p>
<ol>
<li> 预定将使用多年的程序；</li>
<li> 当前正在成功地使用着的程序；</li>
<li> 在最近的将来可能要做重大修改或增强的程序。</li>
</ol>
<p>应该仔细分析库存目录，按照业务重要程度、寿命、当前可维护性、预期的修改次数等标准，把库中的应用系统排序，从中选出再工程的候选者，然后明智地分配再工程所需要的资源。</p>
<h3 id="2-文档重构"><a href="#2-文档重构" class="headerlink" title="2. 文档重构"></a>2. 文档重构</h3><p>老程序固有的特点是缺乏文档。具体情况不同，处理这个问题的方法也不同：</p>
<ol>
<li> 如果一个程序是相对稳定的，正在走向其有用生命的终点，而且可能不会再经历什么变化，那么，让它保持现状是一个明智的选择</li>
<li> 为了便于今后的维护，必须更新文档，但是由于资源有限，应采用“使用时建文档”的方法，也就是说，不是一下子把某应用系统的文档全部都重建起来，而是只针对系统中当前正在修改的那些部分建立完整文档</li>
<li> 如果某应用系统是完成业务工作的关键，而且必须重构全部文档，则仍然应该设法把文档工作减少到必需的最小量</li>
</ol>
<h3 id="3-逆向工程"><a href="#3-逆向工程" class="headerlink" title="3. 逆向工程"></a>3. 逆向工程</h3><p>软件的逆向工程是分析程序以便在比源代码更高的抽象层次上创建出程序的某种表示的过程，也就是说，逆向工程是一个恢复设计结果的过程。</p>
<h3 id="4-代码重构"><a href="#4-代码重构" class="headerlink" title="4. 代码重构"></a>4. 代码重构</h3><p>某些老程序具有比较完整、合理的体系结构，但是，个体模块的编码方式却是难于理解、测试和维护的。在这种情况下，可以重构这些模块的代码。</p>
<p>通常，重构并不修改整体的程序体系结构，它仅关注个体模块的设计细节以及在模块中定义的局部数据结构。如果重构扩展到模块边界之外并涉及软件体系结构，则重构变成了正向工程。</p>
<h3 id="5-数据重构"><a href="#5-数据重构" class="headerlink" title="5. 数据重构"></a>5. 数据重构</h3><p>对数据体系结构差的程序很难进行适应性修改和增强，数据体系结构比源代码本身对程序的长期生存力有更大影响。</p>
<p>数据重构是一种全范围的再工程活动。数据结构对程序体系结构及程序中的算法有很大影响，对数据的修改必然会导致体系结构或代码层的改变。</p>
<h3 id="6-正向工程"><a href="#6-正向工程" class="headerlink" title="6. 正向工程"></a>6. 正向工程</h3><p>正向工程也称为革新或改造。正向工程过程应用软件工程的原理、概念、技术和方法来重新开发某个现有的应用系统。在大多数情况下，被再工程的软件不仅重新实现现有系统的功能，而且加入了新功能和提高了整体性能。</p>

	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>