<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/编程语言/Cpp/tan-yi-tan-c-zhong-de-zhi-de-lei-xing/>左值、右值、move</a></h1><div class=post-meta-inline><span class=post-date> 2020-12-28 </span></div><div class=post-content><p>原文：https://zhuanlan.zhihu.com/p/265815272<h2 id=c-98>C++98</h2><p>历史上，我们把值分为两类，左值 ( lvalue ) 和右值 ( rvalue )。<p>右值，就是只能在等号右边的值，比如字面量。<p>左值，就是在等号左边出现的值，当然在等号右边也能出现。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span> a = </span><span style=color:#d08770;>1</span><span>; </span><span style=color:#65737e;>// a 是左值, 1 是右值，这个 1 被称作字面量
</span></code></pre><p>但是这样的分类方法，在遇到 const int 这样的类型时，就发现一个 const int 既不能分为左值，也不能分类为右值。（有且只有初始化时才能在等号左边出现）<p>所以在 C 中，左值，就是表示了一个“对象”(object) 的值，比如一个变量，一个指针等等。在 C++98 中，还把函数变成了左值。<p>左值的特点就是，可以绑定上左值引用。如果要引用一个右值，那引用必须是一个常引用。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int</span><span> a = </span><span style=color:#d08770;>100</span><span>; </span><span style=color:#65737e;>// a 是一个左值
</span><span style=color:#b48ead;>int </span><span>&b = a; </span><span style=color:#65737e;>// b 是一个左值引用, 对 b 操作任何事情完全就是对 a 操作
</span></code></pre><h2 id=c-11>C++11</h2><p>在 C++11 中引入了一种新的语义——移动语义。具体地说，就是可以移动构造，还有移动赋值。<p>移动语义有点像“废物利用”一样。如果采用了移动构造，你就可以把自己身上的数据移动给新的成员，避免了不必要的数据复制。比如要移动几千个 std::string 类型的成员，C++98 中只能够复制一份再删除一份，而 C++11 中，就可以改一下 std::string 内部指针的位置，很方便。<p>但是要注意，只有废物才能被利用，我们给这类“废物”一个名字，就叫 xvalue，x 的意思是“将要过期的”(expiring)。原来的右值 rvalue 中细分成为了“纯右值” prvalue (pure rvalue)<p>所以在 C++11 中，有了三种数据类型：<ul><li>lvalue<li>xvalue<li>prvalue</ul><p>其中 xvalue 和 prvalue 统称 rvalue；而 lvalue 和 xvalue 统称 glvalue.<p>---+++<p>我们举一些例子。<p>prvalue:<ol><li>字面量（除了字符串）<li>像 a++ 这样内置的后自增表达式（返回一个临时对象）<li>像 a+b 这样内置的运算、逻辑运算等<li><strong><code>返回一个非引用类型</code>的函数</strong>的返回值<li>强制转换成了非引用类型<li>lambda 表达式</ol><p>等等，更具体的分类可以看拓展阅读。<p>xvalue:<ol><li><strong><code>返回一个右值引用</code>的函数</strong>的返回值。比如 std::move(x)<li>强制转换了右值引用</ol><p>也就是说，通过使用 std::move(x) 就可以把 x 的类型变成 xvalue，就可以调用移动构造函数了（如果实现了这个函数）。<p>（小提示：不要写出 return std::move(x); 这种语句，写 return x; 就行，不然会妨碍编译器优化。参考<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/copy_elision">这里</a>）<p>---+++<p>进一步，我们可以抽象出来这两个判断法则：<p>准则 1：能不能分辨两个表达式指的是同一个物体。比如我们可以通过比较地址。<p>准则 2：能不能使用移动语义。比如看看能不能用调用移动构造函数。<ul><li>都满足，那就是 xvalue<li>满足 1 不满足 2，就是 lvalue<li>满足 2 不满足 1，就是 prvalue</ul><p>满足 1 就统称为 glvalue，满足 2 的统称为 rvalue<p>分成这么多类，在绑定引用的时候就起了作用。比如不同的函数重载，一个 xvalue 优先会找右值引用，其次可能是常量左值的引用，这样就可以正确的发挥移动语义的作用了。<h2 id=c-17>C++17</h2><p>分类和 C++11 是一样的，但是语义上更加明确了。<ul><li>glvalues：有自己地址的长寿对象<li>prvalues：为了初始化而用的短命对象<li>xvalue：资源已经不需要了，而且可以再利用的长寿对象</ul><p>C++17 还引入了一些新的语法规定，有时候一个 prvalue 还可以 materialization 成 xvalue。当然，这些都不用太关心，写出问题了再说。<h2 id=can-kao>参考</h2><p>https://en.cppreference.com/w/cpp/language/value_category</div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>