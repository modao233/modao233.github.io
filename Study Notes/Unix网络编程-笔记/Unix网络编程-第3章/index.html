<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「工作日还有多少天，休息日还剩几小时」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-text">3.2 套接字的地址结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">IPv4套接字地址结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">通用套接字地址结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv6%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">IPv6套接字地址结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E9%80%9A%E7%94%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-text">新的通用套接字地址结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%80%BC-%E7%BB%93%E6%9E%9C%E5%8F%82%E6%95%B0"><span class="toc-text">3.3 值-结果参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%AD%97%E8%8A%82%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0"><span class="toc-text">3.4 字节排序函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">3.5 字节操作函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-inet-aton%E3%80%81inet-addr%E5%92%8Cinet-ntoa%E5%87%BD%E6%95%B0"><span class="toc-text">3.6 inet_aton、inet_addr和inet_ntoa函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-inet-pton%E5%92%8Cinet-ntop%E5%87%BD%E6%95%B0"><span class="toc-text">3.7 inet_pton和inet_ntop函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%935%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-text">总结5个函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-sock-ntop%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">3.8 sock_ntop和相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-readn%E3%80%81writen%E5%92%8Creadline%E5%87%BD%E6%95%B0"><span class="toc-text">3.9 readn、writen和readline函数</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		Unix网络编程-第3章 套接字编程简介
	</div>
	
	<div class="page-date">
		2019-12-09
	</div>
	
	<div class="category-area">
		
			 
				「
				<div class="category">
					<a href="/categories/Study Notes">Study Notes</a>
				
				</div>
				」
			 
				「
				<div class="category">
					<a href="/categories/Unix网络编程">Unix网络编程</a>
				
				</div>
				」
			
		
	</div>
	
	<div class="content">
		<p>Unix网络编程-第3章 套接字编程简介</p>
<span id="more"></span>

<h2 id="3-2-套接字的地址结构"><a href="#3-2-套接字的地址结构" class="headerlink" title="3.2 套接字的地址结构"></a>3.2 套接字的地址结构</h2><p>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。每个协议族都定义自己的套接字地址结构，这些结构的名字均已<code>sockaddr_</code>开头，并以对应每个协议族的唯一后缀结尾。</p>
<h3 id="IPv4套接字地址结构："><a href="#IPv4套接字地址结构：" class="headerlink" title="IPv4套接字地址结构："></a>IPv4套接字地址结构：</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>&#123;</span><br>    <span class="hljs-keyword">in_addr_t</span>          s_addr;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>&#123;</span><br>    <span class="hljs-keyword">uint8_t</span>            sin_len;<br>    <br>    <span class="hljs-comment">//POSIX规范只需要这个结构中的三个字段</span><br>    <span class="hljs-keyword">sa_family_t</span>        sin_family;<br>    <span class="hljs-keyword">in_port_t</span>          sin_port;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>     <span class="hljs-title">sin_addr</span>;</span><br>    <br>    <span class="hljs-keyword">char</span>               sin_zero[<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>字段</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>s_addr</td>
<td>in_addr_t</td>
<td>至少32位的无符号整数类型</td>
</tr>
<tr>
<td>sin_port</td>
<td>in_port_t</td>
<td>至少16位的无符号整数类型</td>
</tr>
<tr>
<td>sin_family</td>
<td>sa_family_t</td>
<td>任何无符号整数类型。在支持长度字段的实现中，通常是一个8位无符号整数，在不支持长度字段中，是一个16位的无符号整数</td>
</tr>
</tbody></table>
<p>套接字地址结构仅在给定主机上使用：虽然结构中某些字段用在不同主机之间的通信，但是结构本身并不在主机之间传递。</p>
<p>为了让套接字函数能够处理来自任何协议族的套接字地址结构，套接字函数定义的参数中使用指向通用套接字地址结构的指针，使用时再进行类型强制转换</p>
<h3 id="通用套接字地址结构："><a href="#通用套接字地址结构：" class="headerlink" title="通用套接字地址结构："></a>通用套接字地址结构：</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>&#123;</span><br>    <span class="hljs-keyword">uint8_t</span>            sa_len;		<span class="hljs-comment">//该字段只在一些Unix实现中有</span><br>        						  	<span class="hljs-comment">//SuSv3标准不做要求，Linux实现也不存在该字段</span><br>    <span class="hljs-keyword">sa_family_t</span>        sa_family;<br>    <span class="hljs-keyword">char</span>               sa_date[<span class="hljs-number">14</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="IPv6套接字地址结构："><a href="#IPv6套接字地址结构：" class="headerlink" title="IPv6套接字地址结构："></a>IPv6套接字地址结构：</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span>&#123;</span><br>    <span class="hljs-keyword">uint8_t</span>            s6_addr[<span class="hljs-number">16</span>];<br>&#125;;<br><br><span class="hljs-comment">//如果系统支持套接字地址结构中的长度字段，则SIN6_LEN常值必须定义</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIN6_LEN</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span>&#123;</span><br>    <span class="hljs-keyword">uint8_t</span>            sin6_len;<br>    <span class="hljs-keyword">sa_family_t</span>        sin6_family;<br>    <span class="hljs-keyword">in_port_t</span>          sin6_port;<br>    <br>    <span class="hljs-keyword">uint32_t</span>           sin6_flowinfo;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span>    <span class="hljs-title">sin6_addr</span>;</span><br>    <br>    <span class="hljs-keyword">uint32_t</span>           sin6_scope_id;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="新的通用套接字地址结构"><a href="#新的通用套接字地址结构" class="headerlink" title="新的通用套接字地址结构"></a>新的通用套接字地址结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span>&#123;</span><br>    <span class="hljs-keyword">uint8_t</span>        ss_len;<br>    <span class="hljs-keyword">sa_family_t</span>    ss_family;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>套接字地址结构比较：</strong></p>
<p><img src="%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="1579573720073"></p>
<h2 id="3-3-值-结果参数"><a href="#3-3-值-结果参数" class="headerlink" title="3.3 值-结果参数"></a>3.3 值-结果参数</h2><p>套接字的地址结构总是以引用形式传递给套接字函数的。</p>
<p>套接字的长度作为一个参数传递给套接字函数时，其传递方式取决于该结构的传递方向。</p>
<p>套接字地址结构可以在两个方向上传递：</p>
<ul>
<li><p>从进程到内核。函数：bind、connect、sendto。</p>
<p>  这些函数的一个参数是指向套接字地址结构的指针，另一个参数是该结构的整数大小。</p>
</li>
<li><p>从内核到进程。函数：accept、recvfrom、getsockname、getpeername。</p>
<p>  这些函数的一个参数是指向套接字地址结构的指针，另一个参数是指向表示该结构大小的整数变量的指针（这种类型的参数称为“值-结果”参数）。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">值-结果传参：<br>当函数被调用时，结构大小是一个值，它告诉内核该结构的大小，这样内核在写该结构时不至于越界。<br>当函数返回时，结构大小又是一个结果，它告诉进程内核在该结构中究竟存储了多少信息。<br></code></pre></td></tr></table></figure></li>
</ul>
<p>当套接字地址结构的长度使用值-结果参数时，如果套接字地址结构是固定长度则从内核返回的值总是那个长度，如果是可变长度，则返回值可能小于该结构的最大长度。</p>
<h2 id="3-4-字节排序函数"><a href="#3-4-字节排序函数" class="headerlink" title="3.4 字节排序函数"></a>3.4 字节排序函数</h2><p>主机字节序：</p>
<ul>
<li>  小端字节序：将低序字节存储在起始地址</li>
<li>  大端字节序：将高序字节存储在起始地址</li>
</ul>
<p><img src="%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F.png" alt="1579582483045"></p>
<p>最高有效位：MSB：most significant bit</p>
<p>最低有效位：LSB：least significant bit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">术语“小端”和“大端”表示：多个字节值的哪一端（小端或大端）存储在该值的起始地址（低地址）。<br></code></pre></td></tr></table></figure>

<p><strong>网络字节序：大端字节序</strong></p>
<p>网络协议必须指定一个<strong>网络字节序</strong>。由于历史原因和POSIX规范的规定，套接字地址结构中的某些字段必须按照网络字节序进行维护。</p>
<p>主机字节序和网络字节序之间相互转换使用以下4个函数：</p>
<ul>
<li>  s视为一个16位的值，例如TCP或UDP的端口号</li>
<li>  l视为一个32位的值，例如IPv4地址</li>
<li>  主机字节序和网络字节序相同的系统中这四个函数定义为空宏</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//主机：host(h)</span><br><span class="hljs-comment">//网络：network(n)</span><br><span class="hljs-comment">//短整型：short(s)</span><br><span class="hljs-comment">//长整型：long(l)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-comment">//返回网络字节序的值</span><br><span class="hljs-function"><span class="hljs-keyword">uint16_t</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> host16bitvalue)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> host32bitvalue)</span></span>;<br><br><span class="hljs-comment">//返回主机字节序的值</span><br><span class="hljs-function"><span class="hljs-keyword">uint16_t</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> net16bitvalue)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> net32bitvalue)</span></span>;<br></code></pre></td></tr></table></figure>

<p>因特网另一个重要的约定是<strong>位序</strong>，IPv4首部前32位的位序如下：</p>
<p><img src="%E4%BD%8D%E5%BA%8F.png" alt="1579584598760"></p>
<h2 id="3-5-字节操作函数"><a href="#3-5-字节操作函数" class="headerlink" title="3.5 字节操作函数"></a>3.5 字节操作函数</h2><p>操作多字节段的函数有<strong>两组</strong>，它们既不对数据作解释，也不假设数据是以空字节符结束的C字符串。</p>
<ul>
<li><p>第一组函数源于4.2BSD，名字以b（表示字节）开头</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;strings.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bzero</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bcopy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br><span class="hljs-comment">//若相等则返回0，否则为非0</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr2, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br></code></pre></td></tr></table></figure></li>
<li><p>第二组函数源于ANSI C标准，名字以men（表示内存）开头</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">//每个函数的最后一个参数都是长度参数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">size_t</span> len)</span></span>;<br><span class="hljs-comment">//memcpy函数的参数顺序与C的赋值语句顺序相同：dest = src</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br><span class="hljs-comment">//若相等则返回0，否则</span><br><span class="hljs-comment">//    看第一个不等字节：ptr1 &gt; ptr2，则返回值大于0，否则返回值小于0</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr2, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>当源字节串与目标字节串重叠时，bcopy能够正确处理，memcpy的操作结果却不可知，这种情况必须改用ANSI C的memmove函数。</p>
<p><strong>比较操作是假设两个不等字节均为无符号字符（unsigned char）的情况下完成的。</strong></p>
<h2 id="3-6-inet-aton、inet-addr和inet-ntoa函数"><a href="#3-6-inet-aton、inet-addr和inet-ntoa函数" class="headerlink" title="3.6 inet_aton、inet_addr和inet_ntoa函数"></a>3.6 inet_aton、inet_addr和inet_ntoa函数</h2><p><strong>功能介绍</strong>：在点分十进制数串和它长度为32位的网络字节序二进制值间转换<strong>IPv4地址</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">//若字符串有效，则返回1，否则返回0</span><br><span class="hljs-comment">//如果addrptr指针为空，那么该函数仍然对输入的字符串执行有效性检查，但是不存储任何结果。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_aton</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *strptr, struct in_addr *addrptr)</span></span>;<br><br><span class="hljs-comment">//若字符串有效，则返回32位二进制网络字节序的IPv4地址，否则返回INADDR_NONE</span><br><span class="hljs-comment">//NADDR_NONE常值通常是一个32位均为1的值，这意味着点分十进制数串255.255.255.255不能由该函数处理，因为其二进制值被用来指示函数失败。</span><br><span class="hljs-function"><span class="hljs-keyword">in_addr_t</span> <span class="hljs-title">inet_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *strptr)</span></span>;<br><br><span class="hljs-comment">//返回一个点分十进制数串的指针</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">inet_ntoa</span><span class="hljs-params">(struct in_addr inaddr)</span></span>;<br><br></code></pre></td></tr></table></figure>

<h2 id="3-7-inet-pton和inet-ntop函数"><a href="#3-7-inet-pton和inet-ntop函数" class="headerlink" title="3.7 inet_pton和inet_ntop函数"></a>3.7 inet_pton和inet_ntop函数</h2><p>这两个函数对于IPv4地址和IPv6地址都适用。函数名中p和n分别代表<strong>表达（presentation）</strong>和<strong>数值（numeric）</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">//函数执行成功返回1，表达的格式无效返回0，出错返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_pton</span><span class="hljs-params">(<span class="hljs-keyword">int</span> family, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *strptr, <span class="hljs-keyword">void</span> *addptr)</span></span>;<br><br><span class="hljs-comment">//函数执行成功返回指向结果的指针，出错返回NULL</span><br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">inet_ntop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> family, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *addptr, <span class="hljs-keyword">char</span> *strptr, <span class="hljs-keyword">size_t</span> len)</span></span>;<br><br><span class="hljs-comment">//family参数可以是AF_INET，也可以是AF_INET6，如果以不被支持的地址族作为family参数，两个函数就都返回一个错误，并将errno置为EAFNOSUPPORT</span><br></code></pre></td></tr></table></figure>

<h3 id="总结5个函数"><a href="#总结5个函数" class="headerlink" title="总结5个函数"></a>总结5个函数</h3><p><img src="3.7%E6%80%BB%E7%BB%93.png" alt="1579590914742"></p>
<h2 id="3-8-sock-ntop和相关函数"><a href="#3-8-sock-ntop和相关函数" class="headerlink" title="3.8 sock_ntop和相关函数"></a>3.8 sock_ntop和相关函数</h2><p>本书编写的协议无关性函数。函数名以sock_开头。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-comment">//成功返回非空指针，出错返回NULL</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">sock_ntop</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr * sockaddr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">//成功返回0，出错返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sock_bind_wild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> family)</span></span>;<br><br><span class="hljs-comment">//若地址为同一协议族且相同，则返回0，反则返回非0</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sock_cmp_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sockaddr1,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">const</span> struct sockaddr *sockaddr2, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">//若地址为同一协议族且端口相同，则返回0，反则返回非0</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sock_cmp_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sockaddr1,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">const</span> struct sockaddr *sockaddr2, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">//返回：若为IPv4或IPv6地址则为非负端口号，否则为-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sock_get_port</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sockaddr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">//成功返回非空指针，出错返回NULL</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">sock_ntop_host</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sockaddr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sock_set_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sockaddr, </span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">socklen_t</span> addrlen, <span class="hljs-keyword">void</span> *ptr)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sock_set_port</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sockaddr,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">socklen_t</span> addrlen, <span class="hljs-keyword">int</span> port)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sock_set_wild</span><span class="hljs-params">(sturct sockaddr *sockaddr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure>

<h2 id="3-9-readn、writen和readline函数"><a href="#3-9-readn、writen和readline函数" class="headerlink" title="3.9 readn、writen和readline函数"></a>3.9 readn、writen和readline函数</h2><p>字节流套接字上的read和write函数所表现的行为不同于通常文件的I/O。字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少，然而这不是出错状态。原因在于：内核中用于套接字的缓冲区可能已经达到极限。此时需要的是调用者再次调用read或write函数，输入或输出剩余的字节。</p>
<p>这个现象在read一个字节流套接字时很常见，但是在write一个字节流时只能在该套接字为非阻塞的前提下才出现。</p>
<p>为了预防万一，不让返回的字节计数值不足，编写了三个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">readn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> filedes, <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">written</span><span class="hljs-params">(<span class="hljs-keyword">int</span> filedes, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">readline</span><span class="hljs-params">(<span class="hljs-keyword">int</span> filedes, <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> maxlen)</span></span>;<br></code></pre></td></tr></table></figure>


	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>