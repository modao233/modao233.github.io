<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/算法与数据结构/algorithm/ji-dao-suan-fa-ti/>几道算法题</a></h1><div class=post-meta-inline><span class=post-date> 2020-07-31 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/algorithm/>#Algorithm</a></span><div class=post-content><h3 id=ti-mu-miao-shu>题目描述</h3><p>时间限制：C/C++ 1秒，其他语言2秒<p>空间限制：C/C++ 256M，其他语言512M<p>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第n次落地时，共经过多少米？第n次反弹多高？（n<=10）<p><strong>输入描述:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>一行，一个整数n (1<=n<=10)。
</span></code></pre><p><strong>输出描述:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>输出两个浮点数ans1,ans2。ans1为第n次落地时，共经过的距离；ans2为第n次反弹的高度。答案应与标准答案误差小于1e-5。两个数间以空格相间。
</span></code></pre><p><strong>输入例子1:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>1
</span></code></pre><p><strong>输出例子1:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>100.000000 50.000000
</span></code></pre><p><strong>输入例子2:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>10
</span></code></pre><p><strong>输出例子2:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>299.609375 0.097656
</span></code></pre><h3 id=si-lu-miao-shu>思路描述</h3><ul><li>输入的n比较小，不用做太多考虑；输出结果的格式是小数点后保留6位；输出以空格分隔<li>每一次落地都包含一次反弹，ans1记录第n次落地时经过的距离，则不算最后一次反弹<li>ans2为第n次反弹后的高度，每次落地后更新其数值即可</ul><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iomanip</span><span>>
</span><span style=color:#b48ead;>using namespace</span><span> std;
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#bf616a;>argv</span><span>[]){
</span><span>    cout << fixed << </span><span style=color:#bf616a;>setprecision</span><span>(</span><span style=color:#d08770;>6</span><span>);
</span><span>    </span><span style=color:#b48ead;>int</span><span> n;
</span><span>    cin >> n;
</span><span>    </span><span style=color:#b48ead;>if</span><span>(n < </span><span style=color:#d08770;>1</span><span>)</span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>    </span><span style=color:#b48ead;>double</span><span> all = </span><span style=color:#d08770;>0</span><span>, end = </span><span style=color:#d08770;>100</span><span>;
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < n; i++){
</span><span>        all += end;
</span><span>        end /= </span><span style=color:#d08770;>2</span><span>;
</span><span>        all += end;
</span><span>    }
</span><span>    cout << all-end << ' ' << end;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=ti-mu-miao-shu-1>题目描述</h3><p>时间限制：C/C++ 1秒，其他语言2秒<p>空间限制：C/C++ 256M，其他语言512M<p>有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。<p><strong>输入描述:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>一行，一个正整数n（1<=n<=1000000）。
</span></code></pre><p><strong>输出描述:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>输出答案。
</span></code></pre><p><strong>输入例子1:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>5
</span></code></pre><p><strong>输出例子1:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>4
</span></code></pre><p><strong>例子说明1:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>出局的编号依次为3,1,5,2，最后留下的是4
</span></code></pre><h3 id=si-lu-miao-shu-1>思路描述</h3><p>典型的环形链表，处理约瑟夫环问题<ul><li><p>构建循环链表，使用双指针逐个剔除，运行超时</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>using namespace</span><span> std;
</span><span style=color:#b48ead;>struct </span><span>Node{
</span><span>    </span><span style=color:#b48ead;>int</span><span> n;
</span><span>    Node* next;
</span><span>    </span><span style=color:#8fa1b3;>Node</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>i</span><span>):</span><span style=color:#bf616a;>n</span><span>(i){}
</span><span>};
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(){
</span><span>    </span><span style=color:#b48ead;>int</span><span> n;
</span><span>    cin >> n;
</span><span>    </span><span style=color:#b48ead;>if</span><span>(n == </span><span style=color:#d08770;>1</span><span>)</span><span style=color:#b48ead;>return</span><span> n;
</span><span>    Node *head = </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>Node</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    Node *cur = head;
</span><span>    
</span><span>    </span><span style=color:#65737e;>//构建循环链表
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>2</span><span>; i <= n; i++){
</span><span>        cur-></span><span style=color:#bf616a;>next </span><span>= </span><span style=color:#b48ead;>new </span><span style=color:#bf616a;>Node</span><span>(i);
</span><span>        cur = cur-></span><span style=color:#bf616a;>next</span><span>;
</span><span>    }
</span><span>    cur-></span><span style=color:#bf616a;>next </span><span>= head;
</span><span>    
</span><span>    Node *pre = </span><span style=color:#d08770;>nullptr</span><span>;
</span><span>    cur = head;
</span><span>    </span><span style=color:#b48ead;>int</span><span> count = </span><span style=color:#d08770;>1</span><span>;
</span><span>    
</span><span>    </span><span style=color:#b48ead;>while</span><span>(cur != pre){
</span><span>        </span><span style=color:#b48ead;>if</span><span>(count % </span><span style=color:#d08770;>3 </span><span>== </span><span style=color:#d08770;>0</span><span>){
</span><span>            Node *temp = cur;
</span><span>            cur = temp -> </span><span style=color:#bf616a;>next</span><span>;
</span><span>            pre -> </span><span style=color:#bf616a;>next </span><span>= cur;
</span><span>            </span><span style=color:#b48ead;>delete</span><span> temp;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else</span><span>{
</span><span>            pre = cur;
</span><span>            cur = cur -> </span><span style=color:#bf616a;>next</span><span>;
</span><span>            count++;
</span><span>        }
</span><span>    }
</span><span>    cout << cur-></span><span style=color:#bf616a;>n</span><span>;
</span><span>    </span><span style=color:#b48ead;>delete</span><span> cur;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><li><p>数学公式（递推推导）</p> <p>将数组看成环形的，使用一个指针指向环的起始（帮助理解）</p> <p>推理过程：每退出一个人，将重新开始计数 ---> 可以看成每退出一个人，指针指向退出位置的后一个，也就是起始位置后移M（相对的最终保留者的位置相对就前移M）</p> <p>将推理过程反过来，则可以得出状态公式：$F(N) = (F(N-1) + M) % N$，<strong>N个人时的胜利者的位置是N-1个人时胜利者的位置后移M位</strong></p> <ul><li>F(N)表示N个人时，胜利者的位置<li>M表示每次相对偏移的个数<li>环形数组，防止溢出，最后需要整除N</ul> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>理解示例：
</span><span>问：假设，当有11个人时，胜利者的下标位置为6。那下一轮10个人时，胜利者的下标位置为多少？
</span><span>答：第一轮删掉编号为3的人后，之后的人都往前面移动了3位，胜利这也往前移动了3位，所以他的下标位置由6变成3
</span><span>问2：假设，当有10个人时，胜利者的下标位置为3。那下一轮11个人时，胜利者的下标位置为多少？
</span><span>答：这可以看错是上一个问题的逆过程，大家都往后移动3位，所以f(11)=f(10)+3。不过有可能数组会越界，所以最后模上当前人数的个数，f(11,3)=（f(10,3)+3）%11
</span></code></pre> <p><strong>因为求出的结果是数组中的下标，最终的编号还要加1</strong></p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>using namespace</span><span> std;
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(){
</span><span>    </span><span style=color:#b48ead;>int</span><span> n;
</span><span>    cin>>n;
</span><span>    </span><span style=color:#b48ead;>int</span><span> pos=</span><span style=color:#d08770;>0</span><span>;
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i=</span><span style=color:#d08770;>2</span><span>;i<=n;i++)
</span><span>    {
</span><span>        pos=(pos+</span><span style=color:#d08770;>3</span><span>)%i;
</span><span>    }
</span><span>    cout<&LTpos+</span><span style=color:#d08770;>1</span><span>;
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre></ul><h3 id=ti-mu-miao-shu-2>题目描述</h3><p>时间限制：C/C++ 1秒，其他语言2秒<p>空间限制：C/C++ 256M，其他语言512M<p>小陆每天要写一份工作日报，日报标题含有日期。几年后，他翻开以前的日报，想知道两份日报的日期是否同为星期几，请编程帮助他判断。<p><strong>输入描述:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>第一行一个正整数T(1<=T<=100)。表示有T个测试样例。
</span><span>接下来T行，每一行有6个正整数y1,m1,d1,y2,m2,d2,（以空格相间）。其中y1-m1-d1分别为第一个日期的年月日，y2-m2-d2分别为第二个日期的年月日。（满足1970<=y1,y2<=9999, 1<=m1,m2<=12, 1<=d1,d2<=31,且保证两个日期是合法的）。
</span></code></pre><p><strong>输出描述:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>输出T行，对应T个答案。对于每一行，如果两个日期在同一周，输出“True”；否则输出“False”（输出内容不含双引号）。
</span></code></pre><p><strong>输入例子1:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>2
</span><span>1970 1 2 2020 2 7
</span><span>2020 1 1 2020 1 2
</span></code></pre><p><strong>输出例子1:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>True
</span><span>False
</span></code></pre><p><strong>例子说明1:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>1970-01-2和2020-02-7同为星期五；
</span><span>2020-01-1为星期三，2020-01-2为星期四。
</span></code></pre><h3 id=si-lu-miao-shu-2>思路描述</h3><p>计算两个日期之间的天数，<p>我们以题目样例1970-01-2星期五为的前一天1970-01-1为基准，这也是题目给的日期范围<p>需要注意每个月的天数、闰年等情况。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdio.h</span><span>>
</span><span> 
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>CaculateWeekDay</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>y</span><span>,</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>m</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>d</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>if</span><span>(m==</span><span style=color:#d08770;>1</span><span>||m==</span><span style=color:#d08770;>2</span><span>) {
</span><span>        m+=</span><span style=color:#d08770;>12</span><span>;
</span><span>        y--;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>int</span><span> iWeek=(d+</span><span style=color:#d08770;>2</span><span>*m+</span><span style=color:#d08770;>3</span><span>*(m+</span><span style=color:#d08770;>1</span><span>)/</span><span style=color:#d08770;>5</span><span>+y+y/</span><span style=color:#d08770;>4</span><span>-y/</span><span style=color:#d08770;>100</span><span>+y/</span><span style=color:#d08770;>400</span><span>)%</span><span style=color:#d08770;>7</span><span>;
</span><span>      </span><span style=color:#b48ead;>return</span><span> iWeek + </span><span style=color:#d08770;>1</span><span>;
</span><span>} 
</span><span> 
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(){
</span><span>    </span><span style=color:#b48ead;>int</span><span> T;
</span><span>    </span><span style=color:#96b5b4;>scanf</span><span>("</span><span style=color:#d08770;>%d</span><span>", &T);
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < T; i++){
</span><span>        </span><span style=color:#b48ead;>int</span><span> y1, m1, d1, y2, m2, d2;
</span><span>        </span><span style=color:#96b5b4;>scanf</span><span>("</span><span style=color:#d08770;>%d %d %d %d %d %d</span><span>", &y1, &m1, &d1, &y2, &m2, &d2);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#bf616a;>CaculateWeekDay</span><span>(y1, m1, d1) == </span><span style=color:#bf616a;>CaculateWeekDay</span><span>(y2, m2, d2)){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>True</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>        }</span><span style=color:#b48ead;>else</span><span>{
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>False</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=ji-mu-la-er-sen-ji-suan-gong-shi>基姆拉尔森计算公式</h3><ol><li><p>用途：给你年月日，计算今天星期几</p><li><p>公式：Week = (d+2<em>m+3</em>(m+1)/5+y+y/4-y/100+y/400+1) mod 7；</p> <ol><li>d为几号<li>m为月份<li>y为年份</ol><li><p>注：把一月和二月看为是上一年的十三月和十四月！！</p><li><p>样例：</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>Date</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>y</span><span>,</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>m</span><span>,</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>d</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>if</span><span>(m==</span><span style=color:#d08770;>1</span><span>||m==</span><span style=color:#d08770;>2</span><span>){</span><span style=color:#65737e;>//一二月换算
</span><span>        m+=</span><span style=color:#d08770;>12</span><span>;
</span><span>        y--;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>int</span><span> week = (d + </span><span style=color:#d08770;>2</span><span>*m +</span><span style=color:#d08770;>3</span><span>*(m+</span><span style=color:#d08770;>1</span><span>)/</span><span style=color:#d08770;>5 </span><span>+ y + y/</span><span style=color:#d08770;>4 </span><span>- y/</span><span style=color:#d08770;>100 </span><span>+ y/</span><span style=color:#d08770;>400 </span><span>+ </span><span style=color:#d08770;>1</span><span>)%</span><span style=color:#d08770;>7</span><span>;
</span><span>    </span><span style=color:#b48ead;>return</span><span> week;</span><span style=color:#65737e;>//其中1~7表示周一到周日
</span><span>}
</span></code></pre></ol><h3 id=ti-mu-miao-shu-3>题目描述</h3><p>时间限制：C/C++ 1秒，其他语言2秒<p>空间限制：C/C++ 256M，其他语言512M<p>段誉身具凌波微波，动无常则，若危若安，一次能走一级台阶或者两级台阶，他要爬一段30级的山路，问有多少种走法？分析如何计算，然后编程解答。 进阶问题：当他轻功熟练度提升，一次最多可以走三级，那就结果有什么变化？后来走火入魔了，不能走一级，只能走二或三级，又有什么变化？<p><strong>输入描述:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>输入一个数n（1<=n<=30），代表段誉要爬一段n级的山路。
</span></code></pre><p><strong>输出描述:</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>输出三个整数a,b,c（以空格相间）。其中a为段誉一次能走一级或两级台阶的走法；b为段誉一次能走一级、二级或三级台阶的走法；c为段誉一次能走二级或三级台阶的走法。
</span></code></pre><p><strong>输入1</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>3
</span></code></pre><p><strong>输出1</strong><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>3 4 1
</span></code></pre><h3 id=si-lu-miao-shu-3>思路描述</h3><p>爬楼梯问题，动态规划，当前楼梯的可能情况由可以到当前楼梯的楼梯的可能情况决定。<p>状态方程：<ul><li>情况1：$a[n] = a[n-1] + a[n-2]$，a[1] = 1, a[2] = 1, <em>a[3] = 3</em><li>情况2：$b[n] = b[n-1] + b[n-2] + b[n-3]$，b[1] = 1, b[2] = 2, b[3] = 4;<li>情况3：$c[n] = c[n-2] + c[n-3]$，c[1] = 0, c[2] = 1, c[3] = 1</ul><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>using namespace</span><span> std;
</span><span style=color:#b48ead;>int</span><span> a[</span><span style=color:#d08770;>31</span><span>];
</span><span style=color:#b48ead;>int</span><span> b[</span><span style=color:#d08770;>31</span><span>];
</span><span style=color:#b48ead;>int</span><span> c[</span><span style=color:#d08770;>31</span><span>];
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(){
</span><span>    </span><span style=color:#b48ead;>int</span><span> n;
</span><span>    cin >> n;
</span><span>    b[</span><span style=color:#d08770;>1</span><span>] = a[</span><span style=color:#d08770;>1</span><span>] = </span><span style=color:#d08770;>1</span><span>;
</span><span>    b[</span><span style=color:#d08770;>2</span><span>] = a[</span><span style=color:#d08770;>2</span><span>] = </span><span style=color:#d08770;>2</span><span>;
</span><span>    a[</span><span style=color:#d08770;>3</span><span>] = </span><span style=color:#d08770;>3</span><span>;
</span><span>    b[</span><span style=color:#d08770;>3</span><span>] = </span><span style=color:#d08770;>4</span><span>;
</span><span>    c[</span><span style=color:#d08770;>1</span><span>] = </span><span style=color:#d08770;>0</span><span>;
</span><span>    c[</span><span style=color:#d08770;>2</span><span>] = </span><span style=color:#d08770;>1</span><span>;
</span><span>    c[</span><span style=color:#d08770;>3</span><span>] = </span><span style=color:#d08770;>1</span><span>;
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>4</span><span>; i <= n; i++){
</span><span>        a[i] = a[i-</span><span style=color:#d08770;>2</span><span>] + a[i-</span><span style=color:#d08770;>1</span><span>];
</span><span>        b[i] = b[i-</span><span style=color:#d08770;>3</span><span>] + b[i-</span><span style=color:#d08770;>2</span><span>] + b[i-</span><span style=color:#d08770;>1</span><span>];
</span><span>        c[i] = c[i-</span><span style=color:#d08770;>3</span><span>] + c[i-</span><span style=color:#d08770;>2</span><span>];
</span><span>    }
</span><span>    cout << a[n] << ' ' << b[n] << ' ' << c[n];
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><p><strong>第一题：</strong> 输入说明： 第一行输入n代表队伍中的人数 第二行输入队伍中每个人的身高（用空格隔开）<p>比如输入： 5 2 3 1 5 4 6 5 4 1 6 8 2<p>输出说明： 如果现在所在位置之前没有比自己身高高的，数值变为-1，如果现在所在位置之前有比自己身高高的，数值变为所在位置之前那个离自己最近的且比自己高的那个人的身高<p>上例的输入对应输出： 5 -1 -1 3 -1 5 6 -1 5 4 -1 -1 8<p>思路：使用一个数组存放身高，因为每个人都要和前面所有人比较，所以从最后一个人开始，使用二层循环，从后往前修改不影响前面数值的比较。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span>
</span><span style=color:#b48ead;>using</span><span> std::cin;
</span><span style=color:#b48ead;>using</span><span> std::cout;
</span><span style=color:#b48ead;>using</span><span> std::endl;
</span><span>
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]){
</span><span>    </span><span style=color:#b48ead;>int</span><span> n;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(cin >> n){
</span><span>        </span><span style=color:#b48ead;>int </span><span>*a = </span><span style=color:#b48ead;>new int</span><span>[n];
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < n; i++){
</span><span>            cin >> a[i];
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = n-</span><span style=color:#d08770;>1</span><span>; i >= </span><span style=color:#d08770;>0</span><span>; i--){
</span><span>            </span><span style=color:#b48ead;>int</span><span> k = -</span><span style=color:#d08770;>1</span><span>;
</span><span>            </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = i - </span><span style=color:#d08770;>1</span><span>; j >= </span><span style=color:#d08770;>0</span><span>; j--){
</span><span>                </span><span style=color:#b48ead;>if</span><span>(a[i] < a[j]){
</span><span>                    k = j;
</span><span>                    </span><span style=color:#b48ead;>break</span><span>;
</span><span>                }
</span><span>            }
</span><span>            </span><span style=color:#b48ead;>if</span><span>(k == -</span><span style=color:#d08770;>1</span><span>)a[i] = -</span><span style=color:#d08770;>1</span><span>;
</span><span>            </span><span style=color:#b48ead;>else</span><span> a[i] = a[k];
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < n; i++)cout << a[i] << ' ';
</span><span>        cout << endl;
</span><span>        </span><span style=color:#b48ead;>delete[]</span><span> a;
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>