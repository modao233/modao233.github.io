<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/网络编程/wang-luo-bian-cheng-iofu-yong/>网络编程-IO复用</a></h1><div class=post-meta-inline><span class=post-date> 2021-03-03 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/wang-luo-bian-cheng/>#网络编程</a></span><div class=post-content><p>网络编程-IO复用<h2 id=i-omo-xing>I/O模型</h2><p>Unix下可用的I/O模型有五种：<ul><li>阻塞式I/O<li>非阻塞式I/O<li>I/O复用（select和poll、epoll）<li>信号驱动式I/O（SIGIO）<li>异步I/O（POSIX的aio_系列函数）</ul><blockquote><p>详见Unix网络编程卷一第六章</blockquote><h2 id=i-ofu-yong>I/O复用</h2><p>select()和poll()在Unix系统中存在时间长，主要优势在于可移植性，主要缺点在于当同时检查大量的文件描述符时性能拓展性不佳。<p>epoll API的关键优势在于能让应用高效地检查大量的文件描述符，主要缺点是专属于Linux系统的API。<p><img alt=image-20210125175611142 src=./image-20210125175611142.png><h3 id=i-ofu-yong-select>I/O复用-select</h3><p>select()首次出现在BSD系统的套接字API中。<p>select()系统调用的用途：在一段指定的时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。<p>系统调用select()会一直阻塞，直到一个或多个文件描述符集合成为就绪态。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/select.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/time.h</span><span>>
</span><span>
</span><span style=color:#65737e;>//若有就绪描述符则返回其数目，若超时则返回0，若出错则返回-1
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>select</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>maxfdp1</span><span>, fd_set *</span><span style=color:#bf616a;>readset</span><span>, fd_set *</span><span style=color:#bf616a;>writeset</span><span>, 
</span><span>           fd_set *</span><span style=color:#bf616a;>exceptset</span><span>, </span><span style=color:#b48ead;>const struct</span><span> timeval *</span><span style=color:#bf616a;>timeout</span><span>);
</span></code></pre><p><strong>探究下fd_set的结构</strong><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>/*typesizes.h*/
</span><span style=color:#b48ead;>#define </span><span>__FD_SETSIZE		</span><span style=color:#d08770;>1024
</span><span>
</span><span style=color:#65737e;>/*select.h*/
</span><span style=color:#b48ead;>typedef long int </span><span>__fd_mask;
</span><span>
</span><span style=color:#65737e;>//long int类型共有多少bits
</span><span style=color:#b48ead;>#define </span><span>__NFDBITS	(</span><span style=color:#d08770;>8 </span><span>* (</span><span style=color:#b48ead;>int</span><span>) sizeof (__fd_mask))
</span><span>
</span><span style=color:#b48ead;>typedef struct
</span><span>{
</span><span>    </span><span style=color:#65737e;>//long int型数组，数组大小 = 描述符最大数 / long int的位数
</span><span>    </span><span style=color:#65737e;>//数组大小为 __FD_SETSIZE bits
</span><span>    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
</span><span>} fd_set;
</span></code></pre><p><strong>select()程序示例：</strong><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/types.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/socket.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>netinet/in.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>arpa/inet.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>assert.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdio.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>unistd.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>errno.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>fcntl.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdlib.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdarg.h</span><span>>
</span><span>
</span><span style=color:#b48ead;>static void </span><span style=color:#8fa1b3;>usageError</span><span>(</span><span style=color:#b48ead;>const char</span><span>* </span><span style=color:#bf616a;>progName</span><span>){
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>Usage: </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> {timeout | -} fd-num[rw]...</span><span style=color:#96b5b4;>\n</span><span>", progName);
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>    - means infinite timeout; </span><span style=color:#96b5b4;>\n</span><span>");
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>    r = monitor for read</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>    w = monitor for wirite</span><span style=color:#96b5b4;>\n\n</span><span>");
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>    e.g.: </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> - 0rw 1w</span><span style=color:#96b5b4;>\n</span><span>", progName);
</span><span>    </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>}
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>cmdLineErr</span><span>(</span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>format</span><span>, ...)
</span><span>{
</span><span>    va_list argList;
</span><span>
</span><span>    </span><span style=color:#96b5b4;>fflush</span><span>(stdout);           </span><span style=color:#65737e;>/* Flush any pending stdout */
</span><span>
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>Command-line usage error: </span><span>");
</span><span>    </span><span style=color:#96b5b4;>va_start</span><span>(argList, format);
</span><span>    </span><span style=color:#96b5b4;>vfprintf</span><span>(stderr, format, argList);
</span><span>    </span><span style=color:#96b5b4;>va_end</span><span>(argList);
</span><span>
</span><span>    </span><span style=color:#96b5b4;>fflush</span><span>(stderr);           </span><span style=color:#65737e;>/* In case stderr is not line-buffered */
</span><span>    </span><span style=color:#96b5b4;>exit</span><span>(EXIT_FAILURE);
</span><span>}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]){
</span><span>    fd_set readfds, writefds;
</span><span>    </span><span style=color:#b48ead;>int</span><span> ready, nfds, fd, numRead, j;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> timeval timeout;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> timeval *pto;
</span><span>    </span><span style=color:#b48ead;>char</span><span> buf[</span><span style=color:#d08770;>10</span><span>];
</span><span>
</span><span>    </span><span style=color:#b48ead;>if</span><span>(argc < </span><span style=color:#d08770;>2 </span><span>|| </span><span style=color:#96b5b4;>strcmp</span><span>(argv[</span><span style=color:#d08770;>1</span><span>], "</span><span style=color:#a3be8c;>--help</span><span>") == </span><span style=color:#d08770;>0</span><span>){
</span><span>        </span><span style=color:#bf616a;>usageError</span><span>(argv[</span><span style=color:#d08770;>0</span><span>]);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#96b5b4;>strcmp</span><span>(argv[</span><span style=color:#d08770;>1</span><span>], "</span><span style=color:#a3be8c;>-</span><span>") == </span><span style=color:#d08770;>0</span><span>){
</span><span>        pto = </span><span style=color:#d08770;>NULL</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>else</span><span>{
</span><span>        pto = &timeout;
</span><span>        timeout.</span><span style=color:#bf616a;>tv_sec </span><span>= </span><span style=color:#96b5b4;>strtol</span><span>(argv[</span><span style=color:#d08770;>1</span><span>], </span><span style=color:#d08770;>NULL</span><span>, </span><span style=color:#d08770;>0</span><span>);
</span><span>        timeout.</span><span style=color:#bf616a;>tv_usec </span><span>= </span><span style=color:#d08770;>0</span><span>;
</span><span>    }
</span><span>
</span><span>    nfds = </span><span style=color:#d08770;>0</span><span>;
</span><span>    </span><span style=color:#bf616a;>FD_ZERO</span><span>(&readfds);
</span><span>    </span><span style=color:#bf616a;>FD_ZERO</span><span>(&writefds);
</span><span>
</span><span>    </span><span style=color:#b48ead;>for</span><span>(j = </span><span style=color:#d08770;>2</span><span>; j < argc; j++){
</span><span>        numRead = </span><span style=color:#96b5b4;>sscanf</span><span>(argv[j], "</span><span style=color:#d08770;>%d%2[rw]</span><span>", &fd, buf);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(numRead != </span><span style=color:#d08770;>2</span><span>){
</span><span>            </span><span style=color:#bf616a;>usageError</span><span>(argv[</span><span style=color:#d08770;>0</span><span>]);
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>if</span><span>(fd >= FD_SETSIZE){
</span><span>            </span><span style=color:#bf616a;>cmdLineErr</span><span>("</span><span style=color:#a3be8c;>file descriptor exceeds limit (</span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;>)</span><span style=color:#96b5b4;>\n</span><span>", FD_SETSIZE);
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>if</span><span>(fd >= nfds){
</span><span>            nfds = fd + </span><span style=color:#d08770;>1</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#96b5b4;>strchr</span><span>(buf, '</span><span style=color:#a3be8c;>r</span><span>') != </span><span style=color:#d08770;>NULL</span><span>){
</span><span>            </span><span style=color:#bf616a;>FD_SET</span><span>(fd, &readfds);
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#96b5b4;>strchr</span><span>(buf, '</span><span style=color:#a3be8c;>w</span><span>') != </span><span style=color:#d08770;>NULL</span><span>){
</span><span>            </span><span style=color:#bf616a;>FD_SET</span><span>(fd, &writefds);
</span><span>        }
</span><span>    }
</span><span>    ready = </span><span style=color:#bf616a;>select</span><span>(nfds, &readfds, &writefds, </span><span style=color:#d08770;>NULL</span><span>, pto);
</span><span>    </span><span style=color:#b48ead;>if</span><span>(ready == -</span><span style=color:#d08770;>1</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>errExit(select)</span><span>");
</span><span>        </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    }
</span><span>    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>ready = </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", ready);
</span><span>    </span><span style=color:#b48ead;>for</span><span>(fd = </span><span style=color:#d08770;>0</span><span>; fd < nfds; fd++){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;>: </span><span style=color:#d08770;>%s%s</span><span style=color:#96b5b4;>\n</span><span>",fd, </span><span style=color:#bf616a;>FD_ISSET</span><span>(fd, &readfds) ? "</span><span style=color:#a3be8c;>r</span><span>" : "", 
</span><span>        </span><span style=color:#bf616a;>FD_ISSET</span><span>(fd, &writefds) ? "</span><span style=color:#a3be8c;>w</span><span>" : "");
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>if</span><span>(pto != </span><span style=color:#d08770;>NULL</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>timeout after select(): </span><span style=color:#d08770;>%ld</span><span style=color:#a3be8c;>.</span><span style=color:#d08770;>%03ld</span><span style=color:#96b5b4;>\n</span><span>",
</span><span>               (</span><span style=color:#b48ead;>long</span><span>) timeout.</span><span style=color:#bf616a;>tv_sec</span><span>, (</span><span style=color:#b48ead;>long</span><span>) timeout.</span><span style=color:#bf616a;>tv_usec </span><span>/ </span><span style=color:#d08770;>1000</span><span>);
</span><span>    }
</span><span>    </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span><span>}
</span></code></pre><p><strong>select处理正常数据和带外数据：</strong><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/types.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/socket.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>netinet/in.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>arpa/inet.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>assert.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdio.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>unistd.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>errno.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>fcntl.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdlib.h</span><span>>
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]){
</span><span>    </span><span style=color:#b48ead;>if</span><span>(argc <= </span><span style=color:#d08770;>2</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>usage: </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> ip_adress port_number</span><span style=color:#96b5b4;>\n</span><span>", </span><span style=color:#bf616a;>basename</span><span>(argv[</span><span style=color:#d08770;>0</span><span>]));
</span><span>        </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>1</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>const char</span><span>* ip = argv[</span><span style=color:#d08770;>1</span><span>];
</span><span>    </span><span style=color:#b48ead;>int</span><span> port = </span><span style=color:#96b5b4;>atoi</span><span>(argv[</span><span style=color:#d08770;>2</span><span>]);
</span><span>
</span><span>    </span><span style=color:#b48ead;>int</span><span> ret = </span><span style=color:#d08770;>0</span><span>;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr_in address;
</span><span>    </span><span style=color:#bf616a;>bzero</span><span>(&address, sizeof(address));
</span><span>    address.</span><span style=color:#bf616a;>sin_family </span><span>= AF_INET;
</span><span>    </span><span style=color:#bf616a;>inet_pton</span><span>(AF_INET, ip, &address.</span><span style=color:#bf616a;>sin_addr</span><span>);
</span><span>    address.</span><span style=color:#bf616a;>sin_port </span><span>= </span><span style=color:#bf616a;>htons</span><span>(port);
</span><span>
</span><span>    </span><span style=color:#b48ead;>int</span><span> listenfd = </span><span style=color:#bf616a;>socket</span><span>(PF_INET, SOCK_STREAM, </span><span style=color:#d08770;>0</span><span>);
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(listenfd >= </span><span style=color:#d08770;>0</span><span>);
</span><span>    ret = </span><span style=color:#bf616a;>bind</span><span>(listenfd, (</span><span style=color:#b48ead;>struct</span><span> sockaddr*)&address, sizeof(address));
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(ret != -</span><span style=color:#d08770;>1</span><span>);
</span><span>    ret = </span><span style=color:#bf616a;>listen</span><span>(listenfd, </span><span style=color:#d08770;>5</span><span>);
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(ret != -</span><span style=color:#d08770;>1</span><span>);
</span><span>
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr_in client_address;
</span><span>    socklen_t client_addrlength = sizeof(client_address);
</span><span>    </span><span style=color:#b48ead;>int</span><span> connfd = </span><span style=color:#bf616a;>accept</span><span>(listenfd, (</span><span style=color:#b48ead;>struct</span><span> sockaddr*)&client_address, &client_addrlength);
</span><span>    </span><span style=color:#b48ead;>if</span><span>(connfd < </span><span style=color:#d08770;>0</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error is: </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", errno);
</span><span>        </span><span style=color:#bf616a;>close</span><span>(listenfd);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#b48ead;>char</span><span> buf[</span><span style=color:#d08770;>1024</span><span>];
</span><span>    fd_set read_fds;
</span><span>    fd_set exception_fds;
</span><span>    </span><span style=color:#bf616a;>FD_ZERO</span><span>(&read_fds);
</span><span>    </span><span style=color:#bf616a;>FD_ZERO</span><span>(&exception_fds);
</span><span>
</span><span>    </span><span style=color:#b48ead;>while</span><span>(</span><span style=color:#d08770;>true</span><span>){
</span><span>        </span><span style=color:#96b5b4;>memset</span><span>(buf, '</span><span style=color:#96b5b4;>\0</span><span>', sizeof(buf));
</span><span>        </span><span style=color:#bf616a;>FD_SET</span><span>(connfd, &read_fds);
</span><span>        </span><span style=color:#bf616a;>FD_SET</span><span>(connfd, &exception_fds);
</span><span>        ret = </span><span style=color:#bf616a;>select</span><span>(connfd + </span><span style=color:#d08770;>1</span><span>, &read_fds, </span><span style=color:#d08770;>NULL</span><span>, &exception_fds, </span><span style=color:#d08770;>NULL</span><span>);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(ret < </span><span style=color:#d08770;>0</span><span>){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>selection failure</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>            </span><span style=color:#b48ead;>break</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#bf616a;>FD_ISSET</span><span>(connfd, &read_fds)){
</span><span>            ret = </span><span style=color:#bf616a;>recv</span><span>(connfd, buf, sizeof(buf)-</span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>0</span><span>);
</span><span>            </span><span style=color:#b48ead;>if</span><span>(ret <= </span><span style=color:#d08770;>0</span><span>){
</span><span>                </span><span style=color:#b48ead;>break</span><span>;
</span><span>            }
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>get </span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;> bytes of normal data: </span><span style=color:#d08770;>%s</span><span style=color:#96b5b4;>\n</span><span>", ret, buf);
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else if</span><span>(</span><span style=color:#bf616a;>FD_ISSET</span><span>(connfd, &exception_fds)){
</span><span>            ret = </span><span style=color:#bf616a;>recv</span><span>(connfd, buf, sizeof(buf)-</span><span style=color:#d08770;>1</span><span>, MSG_OOB);
</span><span>            </span><span style=color:#b48ead;>if</span><span>(ret <= </span><span style=color:#d08770;>0</span><span>){
</span><span>                </span><span style=color:#b48ead;>break</span><span>;
</span><span>            }
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>get </span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;> bytes of oob data: </span><span style=color:#d08770;>%s</span><span style=color:#96b5b4;>\n</span><span>", ret, buf);
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#bf616a;>close</span><span>(connfd);
</span><span>    </span><span style=color:#bf616a;>close</span><span>(listenfd);
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=i-ofu-yong-poll>I/O复用-poll</h3><p>poll函数起源于SVR3，最初局限于流设备，SVR4取消了这种限制，允许poll工作在任何描述符上。<p>poll提供的功能与select类似，不过在处理流设备时，它能够提供额外的信息。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>poll.h</span><span>>
</span><span>
</span><span style=color:#b48ead;>struct </span><span>pollfd{
</span><span>    </span><span style=color:#b48ead;>int</span><span>		fd;
</span><span>    </span><span style=color:#b48ead;>short</span><span>	events;	</span><span style=color:#65737e;>//指定要测试的条件
</span><span>    </span><span style=color:#b48ead;>short</span><span>	revents;</span><span style=color:#65737e;>//返回描述符的状态
</span><span>}
</span><span style=color:#65737e;>//若有就绪描述符返回其数目，超时返回0，出错返回-1
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>poll</span><span>(</span><span style=color:#b48ead;>struct</span><span> pollfd *</span><span style=color:#bf616a;>fdarray</span><span>, </span><span style=color:#b48ead;>unsigned long </span><span style=color:#bf616a;>nfds</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>timeout</span><span>);
</span></code></pre><blockquote><p>select()同poll()返回正整数的区别：如果一个文件描述符在返回的集合中出现了不止一次，系统调用select()会将同一个文件描述符计数多次。而系统调用poll()返回的是就绪态文件描述符个数，且一个文件描述符只会统计一次，就算在相应的revents字段中设定了多个位掩码也是如此。</blockquote><p><strong>poll示例程序：</strong><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>time.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>poll.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/types.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/socket.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>netinet/in.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>arpa/inet.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>assert.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdio.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>unistd.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>errno.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>fcntl.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdlib.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdarg.h</span><span>>
</span><span>
</span><span style=color:#b48ead;>static void </span><span style=color:#8fa1b3;>usageError</span><span>(</span><span style=color:#b48ead;>const char</span><span>* </span><span style=color:#bf616a;>progName</span><span>){
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>Usage: </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> {timeout | -} fd-num[rw]...</span><span style=color:#96b5b4;>\n</span><span>", progName);
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>    - means infinite timeout; </span><span style=color:#96b5b4;>\n</span><span>");
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>    r = monitor for read</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>    w = monitor for wirite</span><span style=color:#96b5b4;>\n\n</span><span>");
</span><span>    </span><span style=color:#96b5b4;>fprintf</span><span>(stderr, "</span><span style=color:#a3be8c;>    e.g.: </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> - 0rw 1w</span><span style=color:#96b5b4;>\n</span><span>", progName);
</span><span>    </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]){
</span><span>    </span><span style=color:#b48ead;>int</span><span> numPipes, j, ready, randPipe, numWrites;
</span><span>    </span><span style=color:#b48ead;>int </span><span>(*pfds)[</span><span style=color:#d08770;>2</span><span>];</span><span style=color:#65737e;>//指向数组的指针
</span><span>    </span><span style=color:#b48ead;>struct</span><span> pollfd *pollFd;
</span><span>
</span><span>    </span><span style=color:#b48ead;>if</span><span>(argc < </span><span style=color:#d08770;>2 </span><span>|| </span><span style=color:#96b5b4;>strcmp</span><span>(argv[</span><span style=color:#d08770;>1</span><span>], "</span><span style=color:#a3be8c;>--help</span><span>") == </span><span style=color:#d08770;>0</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> num-pipes [num-writes]</span><span style=color:#96b5b4;>\n</span><span>", argv[</span><span style=color:#d08770;>0</span><span>]);
</span><span>        </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    }
</span><span>
</span><span>    numPipes = </span><span style=color:#96b5b4;>strtol</span><span>(argv[</span><span style=color:#d08770;>1</span><span>], </span><span style=color:#d08770;>NULL</span><span>, </span><span style=color:#d08770;>10</span><span>);
</span><span>
</span><span>    pfds = (</span><span style=color:#b48ead;>int </span><span>(*)[</span><span style=color:#d08770;>2</span><span>])</span><span style=color:#96b5b4;>calloc</span><span>(numPipes, sizeof(</span><span style=color:#b48ead;>int </span><span>[</span><span style=color:#d08770;>2</span><span>]));
</span><span>    </span><span style=color:#b48ead;>if</span><span>(pfds == </span><span style=color:#d08770;>NULL</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error malloc</span><span>");
</span><span>        </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    }
</span><span>    pollFd = (pollfd*)</span><span style=color:#96b5b4;>calloc</span><span>(numPipes, sizeof(</span><span style=color:#b48ead;>struct</span><span> pollfd));
</span><span>    </span><span style=color:#b48ead;>if</span><span>(pollFd == </span><span style=color:#d08770;>NULL</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error malloc</span><span>");
</span><span>        </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#b48ead;>for</span><span>(j = </span><span style=color:#d08770;>0</span><span>; j < numPipes; j++){
</span><span>        </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#bf616a;>pipe</span><span>(pfds[j]) == -</span><span style=color:#d08770;>1</span><span>){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error pipe </span><span style=color:#d08770;>%d</span><span>", j);
</span><span>            </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    numWrites = (argc > </span><span style=color:#d08770;>2</span><span>) ? </span><span style=color:#96b5b4;>strtol</span><span>(argv[</span><span style=color:#d08770;>2</span><span>], </span><span style=color:#d08770;>NULL</span><span>, </span><span style=color:#d08770;>10</span><span>) : </span><span style=color:#d08770;>1</span><span>;
</span><span>    </span><span style=color:#bf616a;>srandom</span><span>((</span><span style=color:#b48ead;>int</span><span>)</span><span style=color:#96b5b4;>time</span><span>(</span><span style=color:#d08770;>NULL</span><span>));
</span><span>    </span><span style=color:#b48ead;>for</span><span>(j = </span><span style=color:#d08770;>0</span><span>; j < numWrites; j++){
</span><span>        randPipe = </span><span style=color:#bf616a;>random</span><span>() % numPipes;
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>Writing to fd: </span><span style=color:#d08770;>%3d</span><span style=color:#a3be8c;> (read fd: </span><span style=color:#d08770;>%3d</span><span style=color:#a3be8c;>)</span><span style=color:#96b5b4;>\n</span><span>",
</span><span>                pfds[randPipe][</span><span style=color:#d08770;>1</span><span>], pfds[randPipe][</span><span style=color:#d08770;>0</span><span>]);
</span><span>        </span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#bf616a;>write</span><span>(pfds[randPipe][</span><span style=color:#d08770;>1</span><span>], "</span><span style=color:#a3be8c;>a</span><span>", </span><span style=color:#d08770;>1</span><span>) == -</span><span style=color:#d08770;>1</span><span>){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>write </span><span style=color:#d08770;>%d</span><span>", pfds[randPipe][</span><span style=color:#d08770;>1</span><span>]);
</span><span>            </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#b48ead;>for</span><span>(j = </span><span style=color:#d08770;>0</span><span>; j < numPipes; j++){
</span><span>        pollFd[j].</span><span style=color:#bf616a;>fd </span><span>= pfds[j][</span><span style=color:#d08770;>0</span><span>];
</span><span>        pollFd[j].</span><span style=color:#bf616a;>events </span><span>= POLLIN;
</span><span>    }
</span><span>
</span><span>    ready = </span><span style=color:#bf616a;>poll</span><span>(pollFd, numPipes, -</span><span style=color:#d08770;>1</span><span>);
</span><span>    </span><span style=color:#b48ead;>if</span><span>(ready == -</span><span style=color:#d08770;>1</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>poll error</span><span>");
</span><span>        </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>poll() returned: </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", ready);
</span><span>
</span><span>    </span><span style=color:#b48ead;>for</span><span>(j = </span><span style=color:#d08770;>0</span><span>; j < numPipes; j++){
</span><span>        </span><span style=color:#b48ead;>if</span><span>(pollFd[j].</span><span style=color:#bf616a;>revents </span><span>& POLLIN){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>Readable: </span><span style=color:#d08770;>%d %3d</span><span style=color:#96b5b4;>\n</span><span>", j, pollFd[j].</span><span style=color:#bf616a;>fd</span><span>);
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h3 id=i-ofu-yong-epoll>I/O复用-epoll</h3><p>epoll API由三组系统调用组成;<ul><li><code>epoll_create()</code>创建一个epoll实例<li><code>epoll_ctl()</code>操作同epoll实例相关联的兴趣列表<li><code>epoll_wait()</code>返回与epoll相关联的就绪列表中的成员</ul><p>epoll实例：epoll API的核心数据结构，和一个打开的文件描述符相关联。这个文件描述符不用来做IO操作，相反它是内核数据结构的句柄，这些内核数据结构实现了两个目的：<ul><li>记录兴趣列表<li>维护就绪列表</ul><h4 id=epoll-create>epoll_create</h4><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/epoll.h</span><span>>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>epoll_create</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>size</span><span>);
</span></code></pre><p>参数size指定我们想要通过epoll实例来检查的描述符个数，不是上限，只是告知内核应该如何为内部数据结构划分初始大小。<p>函数返回epoll实例的文件描述符，该文件描述符不需要时需要close()。<p>当所有与epoll实例相关的文件描述符都被关闭时，实例被销毁，相关资源释放。（多个文件描述符可能引用到相同的epoll实例，这是由于调用了fork()或dup()这样的类似函数所致）。<blockquote><p>linux2.6.8版以来，size参数被忽略不用。<p>linux2.6.27以来，Linux支持一个新的系统调用epoll_create1()：<ul><li>去掉了无用的参数size<li>增加了一个可用来修改系统调用行为的flags参数 <ul><li>flag目前只支持一个标志：EPOLL_CLOEXEC，使内核在新的文件描述符上启动了执行即关闭（close-on-exec）标志（FD_CLOEXEC)</ul></ul></blockquote><h4 id=epoll-ctl>epoll_ctl</h4><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/epoll.h</span><span>>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>epoll_ctl</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>epfd</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>op</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd</span><span>, </span><span style=color:#b48ead;>struct</span><span> epoll *</span><span style=color:#bf616a;>ev</span><span>);
</span></code></pre><p>成功返回0，失败返回-1并设置errno。<p>参数fd：指明修改兴趣列表中哪一个文件描述符的设定<p>参数op：指定需要执行的操作<ul><li>EPOLL_CTL_ADD：添加<li>EPOLL_CTL_MOD：修改<li>EPOLL_CTL_DEL：删除</ul><p>参数ev：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>struct </span><span>epoll_event{
</span><span>    uint32_t	 events;</span><span style=color:#65737e;>//epoll事件，位掩码
</span><span>    epoll_data_t data;	</span><span style=color:#65737e;>//用户数据 
</span><span>}
</span></code></pre><p>events描述事件类型，其中epoll事件类型有以下几种<ul><li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）<li>EPOLLOUT：表示对应的文件描述符可以写<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）<li>EPOLLERR：表示对应的文件描述符发生错误<li>EPOLLHUP：表示对应的文件描述符被挂断；<li>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</ul><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>typedef union</span><span> epoll_data{
</span><span>    </span><span style=color:#b48ead;>void		</span><span>*ptr;
</span><span>    </span><span style=color:#b48ead;>int</span><span>			fd;
</span><span>    uint32_t	u32;
</span><span>    uint64_t	u64;
</span><span>}epoll_data_t;
</span></code></pre><ul><li>结构体epoll_event在的events字段是一个位掩码，指定待检查的描述符fd上感兴趣的事件集合<li>data字段是一个联合体，当描述符fd成为就绪态时，联合体的成员可用来指定传回给调用进程的信息 <ul><li>联合体成员不能一起使用，常用fd<li>想要将文件描述符和用户数据关联起来，以实现快速的数据访问，只能使用其它手段，比如放弃使用fd，而在ptr指向的用户数据中包含fd</ul></ul><blockquote><p><strong>max_user_watches上限</strong><p>每个注册到epoll实例上的文件描述符需要占用一小段不能被交换的内核内存空间，因此内核提供了一个接口用来定义每个用户可以注册到epoll实例上的文件描述符总数。<p>这个上限值可以通过max_user_watches来查看和修改，max_user_watches是专属于Linux系统的/proc/sys/fd/epoll目录下的一个文件。默认上限值根据可用系统内存计算得出。</blockquote><h4 id=epoll-wait>epoll_wait</h4><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/epoll.h</span><span>>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>epoll_wait</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>epfd</span><span>, </span><span style=color:#b48ead;>struct</span><span> epoll_event *</span><span style=color:#bf616a;>evlist</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>maxevents</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>timeout</span><span>);
</span></code></pre><p>成功返回就绪态的文件描述符的个数，失败返回-1并设置errno<p>参数evlist指向的结构体数组中返回的是有关就绪态文件描述符的信息。数组evlist的空间由调用者负责申请，所包含的元素个数在参数maxevents中指定。<p>在数组evlist中每个元素返回的都是单个就绪态文件描述符的信息：<ul><li>events字段返回在该描述符上已经发生的事件掩码<li>data字段返回的是适用epoll_ctl()注册监听事件时在ev.data中所指定的值。data字段是唯一可获知同这个事件相关的文件描述符号的途径，因此，在调用epoll_ctl()时要么将ev.data.fd设为文件描述符号，要么将ev.data.ptr设为指向包含文件描述符号的结构体</ul><p>参数timeout用来确定epoll_wait()的阻塞行为：<ul><li>timeout为-1，调用将一直阻塞，直到兴趣列表中的文件描述符上有事件发生，或者直到捕获到一个信号为止<li>timeout为0，执行一次非阻塞式的检查<li>timeout大于0，调用将阻塞至多timeout毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止</ul><p>在多线程程序中，可以在一个线程中使用epoll_ctl()将文件描述符添加到另一个线程中由epoll_wait()所监视的epoll实例的兴趣列表中去。这些对兴趣列表的修改将立刻得到处理，而epoll_wait()调用将返回有关新添加的文件描述符的就绪信息。<p>epoll事件：除了有一个额外的前缀E外，大多数位掩码的名称同poll中对应的事件掩码名称相同。例外情况：<ul><li>EPOLLET：epoll支持边缘触发<li>EPOLLONESHOT：只触发一次，触发完标记为非激活状态，需要使用EPOLL_CTL_MOD操作重新激活对这个文件描述符的检查</ul><p><img alt=image-20210126233317669 src=image-20210126233317669.png><h4 id=bu-tong-de-tong-zhi-mo-xing-ru-he-ying-xiang-wo-men-de-cheng-xu-she-ji>不同的通知模型如何影响我们的程序设计？</h4><p>水平触发<ul><li>确定文件描述符的I/O状态已经ready<li>已经ready，对这个文件描述符执行一些I/O操作（比如读取几个字节数据），然后继续监视它的IO状态<li>仍然有未读取的数据，还会继续触发通知，也就是说不用一次执行完所有的IO操作（比如一次读取缓冲区的全部内容）</ul><p>边缘触发：<ul><li>只有新的IO事件发生时，才会触发通知<li>直到下次IO事件发生，不会再触发通知</ul><blockquote><p>注：对于边缘触发，当触发通知时，我们并不知道有多少IO可用（例如有多少字节可以读），所以一般使用边缘触发通知方式要遵循如下规则：<ol><li>接收到事件通知后，程序应该尽可能多的执行IO（读写），因为仅仅通知这一次，不读取完毕，数据可能就丢失了<li>为了避免IO阻塞，每个被监视的文件描述符应该是非阻塞模式打开的，然后收到事件通知后，重复的执行IO直到返回错误信息</ol></blockquote><h4 id=cheng-xu-shi-li>程序示例</h4><p><strong>epoll程序示例：</strong><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/epoll.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>fcntl.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdio.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdlib.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>unistd.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>errno.h</span><span>>
</span><span>
</span><span>
</span><span style=color:#b48ead;>#define </span><span>MAX_BUF     </span><span style=color:#d08770;>1000
</span><span style=color:#b48ead;>#define </span><span>MAX_EVENTS  </span><span style=color:#d08770;>5
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]){
</span><span>    </span><span style=color:#b48ead;>int</span><span> epfd, ready, fd, s, j, numOpenFds;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> epoll_event ev;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> epoll_event evlist[MAX_EVENTS];
</span><span>    </span><span style=color:#b48ead;>char</span><span> buf[MAX_BUF];
</span><span>
</span><span>    </span><span style=color:#b48ead;>if</span><span>(argc < </span><span style=color:#d08770;>2 </span><span>|| </span><span style=color:#96b5b4;>strcmp</span><span>(argv[</span><span style=color:#d08770;>1</span><span>], "</span><span style=color:#a3be8c;>--help</span><span>")==</span><span style=color:#d08770;>0</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>usage: </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> file...</span><span style=color:#96b5b4;>\n</span><span>", argv[</span><span style=color:#d08770;>0</span><span>]);
</span><span>        </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    }
</span><span>
</span><span>    epfd = </span><span style=color:#bf616a;>epoll_create</span><span>(argc - </span><span style=color:#d08770;>1</span><span>);
</span><span>    </span><span style=color:#b48ead;>if</span><span>(epfd == -</span><span style=color:#d08770;>1</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error epoll_create</span><span>");
</span><span>        </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#b48ead;>for</span><span>(j = </span><span style=color:#d08770;>1</span><span>; j < argc; j++){
</span><span>        fd = </span><span style=color:#bf616a;>open</span><span>(argv[j], O_RDONLY);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(fd == -</span><span style=color:#d08770;>1</span><span>){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error open</span><span>");
</span><span>            </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>        }
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>Opened </span><span style=color:#96b5b4;>\"</span><span style=color:#d08770;>%s</span><span style=color:#96b5b4;>\"</span><span style=color:#a3be8c;> on fd </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", argv[j], fd);
</span><span>
</span><span>        ev.</span><span style=color:#bf616a;>events </span><span>= EPOLLIN;
</span><span>        ev.</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd </span><span>= fd;
</span><span>        </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#bf616a;>epoll_ctl</span><span>(epfd, EPOLL_CTL_ADD, fd, &ev) == -</span><span style=color:#d08770;>1</span><span>){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error epoll_ctl</span><span>");
</span><span>            </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    numOpenFds = argc - </span><span style=color:#d08770;>1</span><span>;
</span><span>
</span><span>    </span><span style=color:#b48ead;>while</span><span>(numOpenFds > </span><span style=color:#d08770;>0</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>About to epoll_wait()</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>        ready = </span><span style=color:#bf616a;>epoll_wait</span><span>(epfd, evlist, MAX_EVENTS, -</span><span style=color:#d08770;>1</span><span>);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(ready == -</span><span style=color:#d08770;>1</span><span>){
</span><span>            </span><span style=color:#b48ead;>if</span><span>(errno == EINTR)</span><span style=color:#b48ead;>continue</span><span>;
</span><span>            </span><span style=color:#b48ead;>else</span><span>{
</span><span>                </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error epoll_wait</span><span>");
</span><span>                </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>            }
</span><span>        }
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>Ready: </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", ready);
</span><span>
</span><span>        </span><span style=color:#b48ead;>for</span><span>(j = </span><span style=color:#d08770;>0</span><span>; j < ready; j++){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>  fd = </span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;>; events: </span><span style=color:#d08770;>%s%s%s</span><span style=color:#96b5b4;>\n</span><span>", evlist[j].</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd</span><span>,
</span><span>                (evlist[j].</span><span style=color:#bf616a;>events </span><span>& EPOLLIN)  ? "</span><span style=color:#a3be8c;>EPOLLIN </span><span>":"",
</span><span>                (evlist[j].</span><span style=color:#bf616a;>events </span><span>& EPOLLHUP) ? "</span><span style=color:#a3be8c;>EPOLLHUP</span><span>":"",
</span><span>                (evlist[j].</span><span style=color:#bf616a;>events </span><span>& EPOLLERR) ? "</span><span style=color:#a3be8c;>EPOLLERR</span><span>":"");
</span><span>            </span><span style=color:#b48ead;>if</span><span>(evlist[j].</span><span style=color:#bf616a;>events </span><span>& EPOLLIN){
</span><span>                s = </span><span style=color:#bf616a;>read</span><span>(evlist[j].</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd</span><span>, buf, MAX_BUF);
</span><span>                </span><span style=color:#b48ead;>if</span><span>(s == -</span><span style=color:#d08770;>1</span><span>){
</span><span>                    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error read</span><span>");
</span><span>                }
</span><span>                </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>    read </span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;> bytes : </span><span style=color:#d08770;>%.*s</span><span>",s,s,buf);
</span><span>            }
</span><span>            </span><span style=color:#b48ead;>else if</span><span>(evlist[j].</span><span style=color:#bf616a;>events </span><span>& (EPOLLHUP | EPOLLERR)){
</span><span>                </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>    closing fd </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", evlist[j].</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd</span><span>);
</span><span>                </span><span style=color:#b48ead;>if</span><span>(</span><span style=color:#bf616a;>close</span><span>(evlist[j].</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd</span><span>) == -</span><span style=color:#d08770;>1</span><span>){
</span><span>                    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>error close</span><span>");
</span><span>                    </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>                }
</span><span>                numOpenFds--;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>All file descriptors closed; bye</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>    </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span><span>}
</span></code></pre><p><strong>ET模式比LT模式触发事件的次数更少：</strong><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/types.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/socket.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>netinet/in.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>arpa/inet.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>assert.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdio.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>unistd.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>errno.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>fcntl.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdlib.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/epoll.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>pthread.h</span><span>>
</span><span>
</span><span style=color:#b48ead;>#define </span><span>MAX_EVENT_NUMBER </span><span style=color:#d08770;>1024
</span><span style=color:#b48ead;>#define </span><span>BUFFER_SIZE </span><span style=color:#d08770;>10
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>setnonblocking</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> old_option = </span><span style=color:#bf616a;>fcntl</span><span>(fd, F_GETFL);
</span><span>    </span><span style=color:#b48ead;>int</span><span> new_option = old_option | O_NONBLOCK;
</span><span>    </span><span style=color:#bf616a;>fcntl</span><span>(fd, F_SETFL, new_option);
</span><span>    </span><span style=color:#b48ead;>return</span><span> old_option;
</span><span>}
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>addfd</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>epollfd</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd</span><span>, </span><span style=color:#b48ead;>bool </span><span style=color:#bf616a;>enable_et</span><span>){
</span><span>    epoll_event event;
</span><span>    event.</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd </span><span>= fd;
</span><span>    event.</span><span style=color:#bf616a;>events </span><span>= EPOLLIN;
</span><span>    </span><span style=color:#b48ead;>if</span><span>(enable_et){
</span><span>        event.</span><span style=color:#bf616a;>events </span><span>|= EPOLLET;
</span><span>    }
</span><span>    </span><span style=color:#bf616a;>epoll_ctl</span><span>(epollfd, EPOLL_CTL_ADD, fd, &event);
</span><span>    </span><span style=color:#bf616a;>setnonblocking</span><span>(fd);
</span><span>}
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>lt</span><span>(epoll_event *</span><span style=color:#bf616a;>events</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>number</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>epollfd</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>listenfd</span><span>){
</span><span>    </span><span style=color:#b48ead;>char</span><span> buf[BUFFER_SIZE];
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < number; i++){
</span><span>        </span><span style=color:#b48ead;>int</span><span> sockfd = events[i].</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd</span><span>;
</span><span>        </span><span style=color:#b48ead;>if</span><span>(sockfd == listenfd){
</span><span>            </span><span style=color:#b48ead;>struct</span><span> sockaddr_in client_address;
</span><span>            socklen_t client_addrlength = sizeof(client_address);
</span><span>            </span><span style=color:#b48ead;>int</span><span> connfd = </span><span style=color:#bf616a;>accept</span><span>(listenfd, (</span><span style=color:#b48ead;>struct</span><span> sockaddr*)&client_address, &client_addrlength);
</span><span>            </span><span style=color:#bf616a;>addfd</span><span>(epollfd, connfd, </span><span style=color:#d08770;>false</span><span>);
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else if</span><span>(events[i].</span><span style=color:#bf616a;>events </span><span>& EPOLLIN){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>event trigger once</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>            </span><span style=color:#96b5b4;>memset</span><span>(buf, '</span><span style=color:#96b5b4;>\0</span><span>', BUFFER_SIZE);
</span><span>            </span><span style=color:#b48ead;>int</span><span> ret = </span><span style=color:#bf616a;>recv</span><span>(sockfd, buf, BUFFER_SIZE-</span><span style=color:#d08770;>1</span><span>,</span><span style=color:#d08770;>0</span><span>);
</span><span>            </span><span style=color:#b48ead;>if</span><span>(ret <= </span><span style=color:#d08770;>0</span><span>){
</span><span>                </span><span style=color:#bf616a;>close</span><span>(sockfd);
</span><span>                </span><span style=color:#b48ead;>continue</span><span>;
</span><span>            }
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>get </span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;> bytes of content: </span><span style=color:#d08770;>%s</span><span style=color:#96b5b4;>\n</span><span>", ret, buf);
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else</span><span>{
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>something else happened </span><span style=color:#96b5b4;>\n</span><span>");
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>et</span><span>(epoll_event* </span><span style=color:#bf616a;>events</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>number</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>epollfd</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>listenfd</span><span>){
</span><span>    </span><span style=color:#b48ead;>char</span><span> buf[BUFFER_SIZE];
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < number; i++){
</span><span>        </span><span style=color:#b48ead;>int</span><span> sockfd = events[i].</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd</span><span>;
</span><span>        </span><span style=color:#b48ead;>if</span><span>(sockfd == listenfd){
</span><span>            </span><span style=color:#b48ead;>struct</span><span> sockaddr_in client_address;
</span><span>            socklen_t client_addrlength = sizeof(client_address);
</span><span>            </span><span style=color:#b48ead;>int</span><span> connfd = </span><span style=color:#bf616a;>accept</span><span>(listenfd, (</span><span style=color:#b48ead;>struct</span><span> sockaddr*)&client_address, &client_addrlength);
</span><span>            </span><span style=color:#bf616a;>addfd</span><span>(epollfd, connfd, </span><span style=color:#d08770;>true</span><span>);
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else if</span><span>(events[i].</span><span style=color:#bf616a;>events </span><span>& EPOLLIN){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>event trigger once</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>            </span><span style=color:#b48ead;>while</span><span>(</span><span style=color:#d08770;>true</span><span>){
</span><span>                </span><span style=color:#96b5b4;>memset</span><span>(buf, '</span><span style=color:#96b5b4;>\0</span><span>',BUFFER_SIZE);
</span><span>                </span><span style=color:#b48ead;>int</span><span> ret = </span><span style=color:#bf616a;>recv</span><span>(sockfd, buf, BUFFER_SIZE-</span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>0</span><span>);
</span><span>                </span><span style=color:#b48ead;>if</span><span>(ret < </span><span style=color:#d08770;>0</span><span>){
</span><span>                    </span><span style=color:#b48ead;>if</span><span>((errno == EAGAIN) || (errno == EWOULDBLOCK)){
</span><span>                        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>read later</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>                        </span><span style=color:#b48ead;>break</span><span>;
</span><span>                    }
</span><span>                    </span><span style=color:#bf616a;>close</span><span>(sockfd);
</span><span>                    </span><span style=color:#b48ead;>break</span><span>;
</span><span>                }
</span><span>                </span><span style=color:#b48ead;>else if</span><span>(ret == </span><span style=color:#d08770;>0</span><span>){
</span><span>                    </span><span style=color:#bf616a;>close</span><span>(sockfd);
</span><span>                }
</span><span>                </span><span style=color:#b48ead;>else</span><span>{
</span><span>                    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>get </span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;> bytes of content: </span><span style=color:#d08770;>%s</span><span style=color:#96b5b4;>\n</span><span>",ret, buf);
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else</span><span>{
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>something else happend </span><span style=color:#96b5b4;>\n</span><span>");
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]){
</span><span>    </span><span style=color:#b48ead;>if</span><span>(argc <= </span><span style=color:#d08770;>2</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>usage: </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> ip_address port_number</span><span style=color:#96b5b4;>\n</span><span>", </span><span style=color:#bf616a;>basename</span><span>(argv[</span><span style=color:#d08770;>0</span><span>]));
</span><span>        </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>1</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>const char </span><span>*ip = argv[</span><span style=color:#d08770;>1</span><span>];
</span><span>    </span><span style=color:#b48ead;>int</span><span> port  = </span><span style=color:#96b5b4;>atoi</span><span>(argv[</span><span style=color:#d08770;>2</span><span>]);
</span><span>
</span><span>    </span><span style=color:#b48ead;>int</span><span> ret = </span><span style=color:#d08770;>0</span><span>;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr_in address;
</span><span>    </span><span style=color:#bf616a;>bzero</span><span>(&address, sizeof(address));
</span><span>    address.</span><span style=color:#bf616a;>sin_family </span><span>= AF_INET;
</span><span>    </span><span style=color:#bf616a;>inet_pton</span><span>(AF_INET, ip, &address.</span><span style=color:#bf616a;>sin_addr</span><span>);
</span><span>    address.</span><span style=color:#bf616a;>sin_port </span><span>= </span><span style=color:#bf616a;>htons</span><span>(port);
</span><span>
</span><span>    </span><span style=color:#b48ead;>int</span><span> listenfd = </span><span style=color:#bf616a;>socket</span><span>(PF_INET, SOCK_STREAM, </span><span style=color:#d08770;>0</span><span>);
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(listenfd >= </span><span style=color:#d08770;>0</span><span>);
</span><span>
</span><span>    ret = </span><span style=color:#bf616a;>bind</span><span>(listenfd, (</span><span style=color:#b48ead;>struct</span><span> sockaddr*)&address, sizeof(address));
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(ret != -</span><span style=color:#d08770;>1</span><span>);
</span><span>
</span><span>    ret = </span><span style=color:#bf616a;>listen</span><span>(listenfd, </span><span style=color:#d08770;>5</span><span>);
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(ret != -</span><span style=color:#d08770;>1</span><span>);
</span><span>
</span><span>    epoll_event events[MAX_EVENT_NUMBER];
</span><span>    </span><span style=color:#b48ead;>int</span><span> epollfd = </span><span style=color:#bf616a;>epoll_create</span><span>(</span><span style=color:#d08770;>5</span><span>);
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(epollfd != -</span><span style=color:#d08770;>1</span><span>);
</span><span>    </span><span style=color:#bf616a;>addfd</span><span>(epollfd, listenfd, </span><span style=color:#d08770;>true</span><span>);
</span><span>
</span><span>    </span><span style=color:#b48ead;>while</span><span>(</span><span style=color:#d08770;>true</span><span>){
</span><span>        </span><span style=color:#b48ead;>int</span><span> ret = </span><span style=color:#bf616a;>epoll_wait</span><span>(epollfd, events, MAX_EVENT_NUMBER, -</span><span style=color:#d08770;>1</span><span>);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(ret < </span><span style=color:#d08770;>0</span><span>){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>epoll failure</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>            </span><span style=color:#b48ead;>break</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#bf616a;>lt</span><span>(events, ret, epollfd, listenfd);
</span><span>        </span><span style=color:#65737e;>//et(events, ret, epollfd, listenfd);
</span><span>    }
</span><span>    </span><span style=color:#bf616a;>close</span><span>(listenfd);
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><p><strong>EPOLLONESHOT程序示例</strong><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/types.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/socket.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>netinet/in.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>arpa/inet.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>assert.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdio.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>unistd.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>errno.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>fcntl.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>stdlib.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/epoll.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>pthread.h</span><span>>
</span><span>
</span><span style=color:#b48ead;>#define </span><span>MAX_EVENT_NUMBER    </span><span style=color:#d08770;>1024
</span><span style=color:#b48ead;>#define </span><span>BUFFER_SIZE         </span><span style=color:#d08770;>1024
</span><span style=color:#b48ead;>struct </span><span>fds{
</span><span>    </span><span style=color:#b48ead;>int</span><span> epollfd;
</span><span>    </span><span style=color:#b48ead;>int</span><span> sockfd;
</span><span>};
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>setnonblocking</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> old_option = </span><span style=color:#bf616a;>fcntl</span><span>(fd, F_GETFL);
</span><span>    </span><span style=color:#b48ead;>int</span><span> new_option = old_option | O_NONBLOCK;
</span><span>    </span><span style=color:#bf616a;>fcntl</span><span>(fd, F_SETFL, new_option);
</span><span>    </span><span style=color:#b48ead;>return</span><span> old_option;
</span><span>}
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>addfd</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>epollfd</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd</span><span>, </span><span style=color:#b48ead;>bool </span><span style=color:#bf616a;>oneshot</span><span>){
</span><span>    epoll_event event;
</span><span>    event.</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd </span><span>= fd;
</span><span>    event.</span><span style=color:#bf616a;>events </span><span>= EPOLLIN | EPOLLET;
</span><span>    </span><span style=color:#b48ead;>if</span><span>(oneshot){
</span><span>        event.</span><span style=color:#bf616a;>events </span><span>|= EPOLLONESHOT;
</span><span>    }
</span><span>    </span><span style=color:#bf616a;>epoll_ctl</span><span>(epollfd, EPOLL_CTL_ADD, fd, &event);
</span><span>    </span><span style=color:#bf616a;>setnonblocking</span><span>(fd);
</span><span>}
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>reset_oneshot</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>epollfd</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd</span><span>){
</span><span>    epoll_event event;
</span><span>    event.</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd </span><span>= fd;
</span><span>    event.</span><span style=color:#bf616a;>events </span><span>= EPOLLIN | EPOLLET | EPOLLONESHOT;
</span><span>    </span><span style=color:#bf616a;>epoll_ctl</span><span>(epollfd, EPOLL_CTL_MOD, fd, &event);
</span><span>}
</span><span>
</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#8fa1b3;>worker</span><span>(</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>arg</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> sockfd = ((fds*)arg)->sockfd;
</span><span>    </span><span style=color:#b48ead;>int</span><span> epollfd = ((fds*)arg)->epollfd;
</span><span>    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>start new thread to receive data on fd: </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", sockfd);
</span><span>    </span><span style=color:#b48ead;>char</span><span> buf[BUFFER_SIZE];
</span><span>    </span><span style=color:#96b5b4;>memset</span><span>(buf, '</span><span style=color:#96b5b4;>\0</span><span>', BUFFER_SIZE);
</span><span>    </span><span style=color:#b48ead;>while</span><span>(</span><span style=color:#d08770;>1</span><span>){
</span><span>        </span><span style=color:#b48ead;>int</span><span> ret = </span><span style=color:#bf616a;>recv</span><span>(sockfd, buf, BUFFER_SIZE-</span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>0</span><span>);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(ret == </span><span style=color:#d08770;>0</span><span>){
</span><span>            </span><span style=color:#bf616a;>close</span><span>(sockfd);
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>foreiner closed the connection</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>            </span><span style=color:#b48ead;>break</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else if</span><span>(ret < </span><span style=color:#d08770;>0</span><span>){
</span><span>            </span><span style=color:#b48ead;>if</span><span>(errno == EAGAIN){
</span><span>                </span><span style=color:#bf616a;>reset_oneshot</span><span>(epollfd, sockfd);
</span><span>                </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>read later</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>                </span><span style=color:#b48ead;>break</span><span>;
</span><span>            }
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else</span><span>{
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>get content: </span><span style=color:#d08770;>%s</span><span style=color:#96b5b4;>\n</span><span>", buf);
</span><span>            </span><span style=color:#bf616a;>sleep</span><span>(</span><span style=color:#d08770;>5</span><span>);
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>end thread receving data on fd : </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", sockfd);
</span><span>}
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#bf616a;>argv</span><span>[]){
</span><span>    </span><span style=color:#b48ead;>if</span><span>(argc < </span><span style=color:#d08770;>2</span><span>){
</span><span>        </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>usage: </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> ip_address port_number</span><span style=color:#96b5b4;>\n</span><span>", </span><span style=color:#bf616a;>basename</span><span>(argv[</span><span style=color:#d08770;>0</span><span>]));
</span><span>        </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>1</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>const char</span><span>* ip = argv[</span><span style=color:#d08770;>1</span><span>];
</span><span>    </span><span style=color:#b48ead;>int</span><span> port = </span><span style=color:#96b5b4;>atoi</span><span>(argv[</span><span style=color:#d08770;>2</span><span>]);
</span><span>
</span><span>    </span><span style=color:#b48ead;>int</span><span> ret = </span><span style=color:#d08770;>0</span><span>;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr_in address;
</span><span>    </span><span style=color:#bf616a;>bzero</span><span>(&address, sizeof(address));
</span><span>    address.</span><span style=color:#bf616a;>sin_family </span><span>= AF_INET;
</span><span>    </span><span style=color:#bf616a;>inet_pton</span><span>(AF_INET, ip, &address.</span><span style=color:#bf616a;>sin_addr</span><span>);
</span><span>    address.</span><span style=color:#bf616a;>sin_port </span><span>= </span><span style=color:#bf616a;>htons</span><span>(port);
</span><span>
</span><span>    </span><span style=color:#b48ead;>int</span><span> listenfd = </span><span style=color:#bf616a;>socket</span><span>(PF_INET, SOCK_STREAM, </span><span style=color:#d08770;>0</span><span>);
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(listenfd >= </span><span style=color:#d08770;>0</span><span>);
</span><span>
</span><span>    ret = </span><span style=color:#bf616a;>bind</span><span>(listenfd, (</span><span style=color:#b48ead;>struct</span><span> sockaddr*)&address, sizeof(address));
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(ret != -</span><span style=color:#d08770;>1</span><span>);
</span><span>
</span><span>    ret = </span><span style=color:#bf616a;>listen</span><span>(listenfd, </span><span style=color:#d08770;>5</span><span>);
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(ret != -</span><span style=color:#d08770;>1</span><span>);
</span><span>
</span><span>    epoll_event events[MAX_EVENT_NUMBER];
</span><span>    </span><span style=color:#b48ead;>int</span><span> epollfd = </span><span style=color:#bf616a;>epoll_create</span><span>(</span><span style=color:#d08770;>5</span><span>);
</span><span>    </span><span style=color:#96b5b4;>assert</span><span>(epollfd != -</span><span style=color:#d08770;>1</span><span>);
</span><span>
</span><span>    </span><span style=color:#bf616a;>addfd</span><span>(epollfd, listenfd, </span><span style=color:#d08770;>false</span><span>);
</span><span>
</span><span>    </span><span style=color:#b48ead;>while</span><span>(</span><span style=color:#d08770;>1</span><span>){
</span><span>        </span><span style=color:#b48ead;>int</span><span> ret = </span><span style=color:#bf616a;>epoll_wait</span><span>(epollfd, events, MAX_EVENT_NUMBER, -</span><span style=color:#d08770;>1</span><span>);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(ret < </span><span style=color:#d08770;>0</span><span>){
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>epoll failure</span><span style=color:#96b5b4;>\n</span><span>");
</span><span>            </span><span style=color:#b48ead;>break</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < ret; i++){
</span><span>            </span><span style=color:#b48ead;>int</span><span> sockfd = events[i].</span><span style=color:#bf616a;>data</span><span>.</span><span style=color:#bf616a;>fd</span><span>;
</span><span>            </span><span style=color:#b48ead;>if</span><span>(sockfd == listenfd){
</span><span>                </span><span style=color:#b48ead;>struct</span><span> sockaddr_in client_address;
</span><span>                socklen_t client_addrlength = sizeof(client_address);
</span><span>                </span><span style=color:#b48ead;>int</span><span> connfd = </span><span style=color:#bf616a;>accept</span><span>(listenfd, (</span><span style=color:#b48ead;>struct</span><span> sockaddr*)&client_address, &client_addrlength);
</span><span>                </span><span style=color:#bf616a;>addfd</span><span>(epollfd, connfd, </span><span style=color:#d08770;>true</span><span>);
</span><span>            }
</span><span>            </span><span style=color:#b48ead;>else if</span><span>(events[i].</span><span style=color:#bf616a;>events </span><span>& EPOLLIN){
</span><span>                pthread_t thread;
</span><span>                fds fds_for_new_worker;
</span><span>                fds_for_new_worker.</span><span style=color:#bf616a;>epollfd </span><span>= epollfd;
</span><span>                fds_for_new_worker.</span><span style=color:#bf616a;>sockfd </span><span>= sockfd;
</span><span>                </span><span style=color:#bf616a;>pthread_create</span><span>(&thread, </span><span style=color:#d08770;>NULL</span><span>, worker, (</span><span style=color:#b48ead;>void</span><span>*)&fds_for_new_worker);
</span><span>            }
</span><span>            </span><span style=color:#b48ead;>else</span><span>{
</span><span>                </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>something else happened </span><span style=color:#96b5b4;>\n</span><span>");
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#bf616a;>close</span><span>(listenfd);
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>0</span><span>;
</span><span>}
</span></code></pre><h4 id=shen-ru-tan-jiu-epollde-yu-yi>深入探究epoll的语义</h4><p><img alt=image-20210129105701198 src=image-20210129105701198.png><p>当我们通过epoll_create创建一个<strong>epoll实例</strong>时，内核在内存中创建一个新的<strong>i-node</strong>，并打开<strong>文件描述</strong>，随后在调用epoll_create的进程中为打开的<strong>文件描述</strong>分配一个新的<strong>文件描述符</strong>。<p>同epoll实例的兴趣列表相关联的是打开的<strong>文件描述</strong>，而不是<strong>epoll文件描述符</strong>。<p>文件描述表示的是一个打开文件的上下文信息（大小、内容、编码等与文件有关的信息），这部分内容实际上由内核来管理的。<p>用户空间的应用程序通过open()等系统调用向内核请求，内核分配给用户空间一个文件描述符，用户空间的应用程序通过文件描述符操作文件。<p>一个文件描述可以对应多个文件描述符，当文件描述对应的文件描述符都关闭时，内核知道此时没有用户空间的程序需要使用文件描述了，则内核负责回收。<blockquote><p>将文件描述比喻为一个抽屉，通过open()获得的文件描述符比喻为抽屉把手（句柄），通过把手操作抽屉里的内容。</blockquote><p>文件描述实际上是内核中的一个数据结构，而用户空间中的文件描述符只不过是一个整数，epoll的兴趣列表实际关注的是内核中的数据结构。<p><strong>重新释意：</strong><p>epoll_ctl()的EPOLL_CTL_ADD操作：内核在兴趣列表中添加一个元素，这个元素同时记录了需要检查的<strong>文件描述符的数量</strong>以及对应的打开<strong>文件描述</strong>的引用。<p>epoll_wait()：调用的目的是让内核负责监视打开的<strong>文件描述</strong>。<ul><li>之前的观点：如果一个文件描述符是epoll兴趣列表的成员，当关闭它后会自动从列表中移除<li>改进的观点：一旦所有指向打开的文件描述的文件描述符都被关闭后，这个打开的文件描述将从epoll兴趣列表中移除</ul><h3 id=you-que-dian-fen-xi>优缺点分析</h3><p>select 的问题：<ul><li>监听的文件描述符有上限 FD_SETSIZE，一般是 1024。因为 <code>fd_set</code> 是个 bitmap，它为最多 <code>nfds</code> 个描述符都用一个 bit 去表示是否监听，即使相应位置的描述符不需要监听在 <code>fd_set</code> 里也有它的 bit 存在。<code>nfds</code> 用于创建这个 bitmap 所以 <code>fd_set</code> 是有限大小的。<li>在用户侧，select 返回后它并不是只返回处于 ready 状态的描述符，而是会返回传入的所有的描述符列表集合，包括 ready 的和非 ready 的描述符，用户侧需要去<strong>遍历所有</strong> readfds、writefds、exceptfds 去看哪个描述符是 ready 状态，再做接下来的处理。还要清理这个 ready 状态，做完 IO 操作后再塞给 select 准备执行下一轮 IO 操作<li>在 Kernel 侧，select 执行后每次都要<strong>陷入内核遍历三个描述符集合数组</strong>为文件描述符<strong>注册监听</strong>，即在描述符指向的 Socket 或文件等上面设置处理函数，从而在文件 ready 时能调用处理函数。等有文件描述符 ready 后，在 select 返回退出之前，kernel 还需要再次遍历描述符集合，将设置的这些处理函数拆除再返回<li>有<strong>惊群问题</strong>。假设一个文件描述符 123 被多个进程或线程注册在自己的 select 描述符集合内，当这个文件描述符 ready 后会将所有监听它的进程或线程全部唤醒<li>无法动态添加描述符，比如一个线程已经在执行 select 了，突然想写数据到某个新描述符上，就只能等前一个 select 返回后重新设置 FD_Set 重新执行 select</ul><p>select 也有个优点，就是跨平台更容易。实现这个接口的 OS 更多。<p>poll：<ul><li>相对于 select 来说，poll 解决了 fds 长度上限问题，解决了监听描述符无法复用问题<li>用户仍然需要在 poll 返回后遍历 fds 去找 ready 的描述符，也需要清理 ready 描述符对应的 revents<li>Kernel 也同样是每次 poll 调用需要去遍历 fds 注册监听，poll 返回时候拆除监听<li>仍然有与 select 一样的惊群问题，也有无法动态修改描述符的问题</ul><p>epoll 优点:<ul><li>监听的描述符没有上限；<li><code>epoll_wait</code> 每次只会返回 Ready 的描述符，不用完整遍历所有被监听的描述符；<li>监听的描述符被注册到 epoll 后会与 epoll 的描述符绑定，维护在内核，不主动通过 <code>epoll_ctl</code> 执行删除不会自动被清理，所以每次执行 <code>epoll_wait</code> 后用户侧不用重新配置监听，Kernel 侧在 <code>epoll_wait</code> 调用前后也不会反复注册和拆除描述符的监听；<li>可以通过 <code>epoll_ctl</code> 动态增减监听的描述符，即使有另一个线程已经在执行 <code>epoll_wait</code>；<li><code>epoll_ctl</code> 在注册监听的时候还能传递自定义的 <code>event_data</code>，一般是传描述符，但应用可以根据自己情况传别的；<li>即使没线程等在 <code>epoll_wait</code> 上，Kernel 因为知道所有被监听的描述符，所以在这些描述符 Ready 时候就能做处理，等下次有线程调用 <code>epoll_wait</code> 时候直接返回。这也帮助 epoll 去实现 IO Edge Trigger，即 IO Ready 时候 Kernel 就标记描述符为 Ready 之后在描述符被读空或写空前不再去监听它，后面详述；<li>多个不同的线程能同时调用 <code>epoll_wait</code> 等在同一个 epoll 描述符上，有描述符 Ready 后它们就去执行；</ul><p>epoll 缺点：<ul><li><code>epoll_ctl</code> 是个<strong>系统调用</strong>，每次修改监听事件，增加监听描述符时候都是一次系统调用，并且没有批量操作的方法。比如一口气要监听一万个描述符，要把一万个描述符从监听读改到监听写等就会很耗时，很低效；<li>对于服务器上大量连上又断开的连接处理效率低，即 <code>accept()</code> 执行后生成一个新的描述符需要执行 <code>epoll_ctl</code> 去注册新 Socket 的监听，之后 <code>epoll_wait</code> 又是一次系统调用，如果 Socket 立即断开了 <code>epoll_wait</code> 会立即返回，又需要再用 <code>epoll_ctl</code> 把它删掉；<li>依然有惊群问题，需要配合使用方式避免，后面详述；</ul><h2 id=select-poll-epoll>select/poll/epoll</h2><ul><li><p>调用函数</p> <ul><li>select和poll都是一个函数，epoll是一组函数</ul><li><p>文件描述符数量</p> <ul><li>select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐<li>poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目<li>epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效</ul><li><p>将文件描述符从用户传给内核</p> <ul><li>select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝<li>epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上</ul><li><p>内核判断就绪的文件描述符</p> <ul><li>select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生<li>epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。<li>epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list</ul><li><p>应用程序索引就绪文件描述符</p> <ul><li>select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历<li>epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可</ul><li><p>工作模式</p> <ul><li>select和poll都只能工作在相对低效的LT模式下<li>epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。</ul><li><p>应用场景</p> <ul><li>当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll<li>当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll<li>当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</ul></ul><h2 id=et-lt-epolloneshot>ET、LT、EPOLLONESHOT</h2><ul><li><p>LT水平触发模式</p> <ul><li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。<li>当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理</ul><li><p>ET边缘触发模式</p> <ul><li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件<li>必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain</ul><li><p>EPOLLONESHOT</p> <ul><li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket<li>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，**当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</ul></ul><h2 id=can-kao>参考</h2><ul><li><p>《Unix网络编程》</p><li><p>《Linux/Unix系统编程手册》</p><li><p>《Linux高性能服务器编程》</p><li><p><a href=https://zhuanlan.zhihu.com/p/127148459>深入学习理解 IO 多路复用</a></p><li><p><a href=https://medium.com/@copyconstruct/the-method-to-epolls-madness-d9d2d6378642>Medium: The method to epoll's madness</a></p><li><p><a href=https://article.itxueyuan.com/dX2X9r>20分钟了解Epoll + 聊天室实战</a></p></ul></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>