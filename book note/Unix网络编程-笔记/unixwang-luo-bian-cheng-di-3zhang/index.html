<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/Unix网络编程-笔记/unixwang-luo-bian-cheng-di-3zhang/">Unix网络编程-第3章 套接字编程简介</a></h1><div class=post-meta-inline><span class=post-date> 2019-12-09 </span></div><div class=post-content><p>Unix网络编程-第3章 套接字编程简介<h2 id=3-2-tao-jie-zi-de-di-zhi-jie-gou>3.2 套接字的地址结构</h2><p>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。每个协议族都定义自己的套接字地址结构，这些结构的名字均已<code>sockaddr_</code>开头，并以对应每个协议族的唯一后缀结尾。<h3 id=ipv4tao-jie-zi-di-zhi-jie-gou>IPv4套接字地址结构：</h3><pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>struct </span><span>in_addr{
</span><span>    in_addr_t          s_addr;
</span><span>};
</span><span style=color:#b48ead;>struct </span><span>sockaddr_in{
</span><span>    uint8_t            sin_len;
</span><span>    
</span><span>    </span><span style=color:#65737e;>//POSIX规范只需要这个结构中的三个字段
</span><span>    sa_family_t        sin_family;
</span><span>    in_port_t          sin_port;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> in_addr     sin_addr;
</span><span>    
</span><span>    </span><span style=color:#b48ead;>char</span><span>               sin_zero[</span><span style=color:#d08770;>8</span><span>];
</span><span>};
</span></code></pre><table><thead><tr><th>字段<th>数据类型<th>说明<tbody><tr><td>s_addr<td>in_addr_t<td>至少32位的无符号整数类型<tr><td>sin_port<td>in_port_t<td>至少16位的无符号整数类型<tr><td>sin_family<td>sa_family_t<td>任何无符号整数类型。在支持长度字段的实现中，通常是一个8位无符号整数，在不支持长度字段中，是一个16位的无符号整数</table><p>套接字地址结构仅在给定主机上使用：虽然结构中某些字段用在不同主机之间的通信，但是结构本身并不在主机之间传递。<p>为了让套接字函数能够处理来自任何协议族的套接字地址结构，套接字函数定义的参数中使用指向通用套接字地址结构的指针，使用时再进行类型强制转换<h3 id=tong-yong-tao-jie-zi-di-zhi-jie-gou>通用套接字地址结构：</h3><pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>struct </span><span>sockaddr{
</span><span>    uint8_t            sa_len;		</span><span style=color:#65737e;>//该字段只在一些Unix实现中有
</span><span>	    						  	</span><span style=color:#65737e;>//SuSv3标准不做要求，Linux实现也不存在该字段
</span><span>    sa_family_t        sa_family;
</span><span>    </span><span style=color:#b48ead;>char</span><span>               sa_date[</span><span style=color:#d08770;>14</span><span>];
</span><span>};
</span></code></pre><h3 id=ipv6tao-jie-zi-di-zhi-jie-gou>IPv6套接字地址结构：</h3><pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>struct </span><span>in6_addr{
</span><span>    uint8_t            s6_addr[</span><span style=color:#d08770;>16</span><span>];
</span><span>};
</span><span>
</span><span style=color:#65737e;>//如果系统支持套接字地址结构中的长度字段，则SIN6_LEN常值必须定义
</span><span style=color:#b48ead;>#define </span><span>SIN6_LEN
</span><span>
</span><span style=color:#b48ead;>struct </span><span>sockaddr_in6{
</span><span>    uint8_t            sin6_len;
</span><span>    sa_family_t        sin6_family;
</span><span>    in_port_t          sin6_port;
</span><span>    
</span><span>    uint32_t           sin6_flowinfo;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> in6_addr    sin6_addr;
</span><span>    
</span><span>    uint32_t           sin6_scope_id;
</span><span>}
</span></code></pre><h3 id=xin-de-tong-yong-tao-jie-zi-di-zhi-jie-gou>新的通用套接字地址结构</h3><pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>struct </span><span>sockaddr_storage{
</span><span>    uint8_t        ss_len;
</span><span>    sa_family_t    ss_family;
</span><span>}
</span></code></pre><p><strong>套接字地址结构比较：</strong><p><img alt=1579573720073 src=%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png><h2 id=3-3-zhi-jie-guo-can-shu>3.3 值-结果参数</h2><p>套接字的地址结构总是以引用形式传递给套接字函数的。<p>套接字的长度作为一个参数传递给套接字函数时，其传递方式取决于该结构的传递方向。<p>套接字地址结构可以在两个方向上传递：<ul><li><p>从进程到内核。函数：bind、connect、sendto。</p> <p>这些函数的一个参数是指向套接字地址结构的指针，另一个参数是该结构的整数大小。</p><li><p>从内核到进程。函数：accept、recvfrom、getsockname、getpeername。</p> <p>这些函数的一个参数是指向套接字地址结构的指针，另一个参数是指向表示该结构大小的整数变量的指针（这种类型的参数称为“值-结果”参数）。</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>值-结果传参：
</span><span>当函数被调用时，结构大小是一个值，它告诉内核该结构的大小，这样内核在写该结构时不至于越界。
</span><span>当函数返回时，结构大小又是一个结果，它告诉进程内核在该结构中究竟存储了多少信息。
</span></code></pre></ul><p>当套接字地址结构的长度使用值-结果参数时，如果套接字地址结构是固定长度则从内核返回的值总是那个长度，如果是可变长度，则返回值可能小于该结构的最大长度。<h2 id=3-4-zi-jie-pai-xu-han-shu>3.4 字节排序函数</h2><p>主机字节序：<ul><li>小端字节序：将低序字节存储在起始地址<li>大端字节序：将高序字节存储在起始地址</ul><p><img alt=1579582483045 src=%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F.png><p>最高有效位：MSB：most significant bit<p>最低有效位：LSB：least significant bit<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>术语“小端”和“大端”表示：多个字节值的哪一端（小端或大端）存储在该值的起始地址（低地址）。
</span></code></pre><p><strong>网络字节序：大端字节序</strong><p>网络协议必须指定一个<strong>网络字节序</strong>。由于历史原因和POSIX规范的规定，套接字地址结构中的某些字段必须按照网络字节序进行维护。<p>主机字节序和网络字节序之间相互转换使用以下4个函数：<ul><li>s视为一个16位的值，例如TCP或UDP的端口号<li>l视为一个32位的值，例如IPv4地址<li>主机字节序和网络字节序相同的系统中这四个函数定义为空宏</ul><pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#65737e;>//主机：host(h)
</span><span style=color:#65737e;>//网络：network(n)
</span><span style=color:#65737e;>//短整型：short(s)
</span><span style=color:#65737e;>//长整型：long(l)
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>netinet/in.h</span><span>>
</span><span>
</span><span style=color:#65737e;>//返回网络字节序的值
</span><span>uint16_t </span><span style=color:#8fa1b3;>htons</span><span>(uint16_t </span><span style=color:#bf616a;>host16bitvalue</span><span>);
</span><span>uint32_t </span><span style=color:#8fa1b3;>htonl</span><span>(uint32_t </span><span style=color:#bf616a;>host32bitvalue</span><span>);
</span><span>
</span><span style=color:#65737e;>//返回主机字节序的值
</span><span>uint16_t </span><span style=color:#8fa1b3;>ntohs</span><span>(uint16_t </span><span style=color:#bf616a;>net16bitvalue</span><span>);
</span><span>uint32_t </span><span style=color:#8fa1b3;>ntohl</span><span>(uint32_t </span><span style=color:#bf616a;>net32bitvalue</span><span>);
</span></code></pre><p>因特网另一个重要的约定是<strong>位序</strong>，IPv4首部前32位的位序如下：<p><img alt=1579584598760 src=%E4%BD%8D%E5%BA%8F.png><h2 id=3-5-zi-jie-cao-zuo-han-shu>3.5 字节操作函数</h2><p>操作多字节段的函数有<strong>两组</strong>，它们既不对数据作解释，也不假设数据是以空字节符结束的C字符串。<ul><li><p>第一组函数源于4.2BSD，名字以b（表示字节）开头</p> <pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>strings.h</span><span>>
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>bzero</span><span>(</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>dest</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>);
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>bcopy</span><span>(</span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>src</span><span>, </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>dest</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>);
</span><span style=color:#65737e;>//若相等则返回0，否则为非0
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>bcmp</span><span>(</span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>ptr1</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>ptr2</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>);
</span></code></pre><li><p>第二组函数源于ANSI C标准，名字以men（表示内存）开头</p> <pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string.h</span><span>>
</span><span>
</span><span style=color:#65737e;>//每个函数的最后一个参数都是长度参数
</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#8fa1b3;>memset</span><span>(</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>dest</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>c</span><span>, size_t </span><span style=color:#bf616a;>len</span><span>);
</span><span style=color:#65737e;>//memcpy函数的参数顺序与C的赋值语句顺序相同：dest = src
</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#8fa1b3;>memcpy</span><span>(</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>dest</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>src</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>);
</span><span style=color:#65737e;>//若相等则返回0，否则
</span><span style=color:#65737e;>//    看第一个不等字节：ptr1 > ptr2，则返回值大于0，否则返回值小于0
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>memcmp</span><span>(</span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>ptr1</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>ptr2</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>);
</span></code></pre></ul><p>当源字节串与目标字节串重叠时，bcopy能够正确处理，memcpy的操作结果却不可知，这种情况必须改用ANSI C的memmove函数。<p><strong>比较操作是假设两个不等字节均为无符号字符（unsigned char）的情况下完成的。</strong><h2 id=3-6-inet-aton-inet-addrhe-inet-ntoahan-shu>3.6 inet_aton、inet_addr和inet_ntoa函数</h2><p><strong>功能介绍</strong>：在点分十进制数串和它长度为32位的网络字节序二进制值间转换<strong>IPv4地址</strong>。<pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>arpa/inet.h</span><span>>
</span><span>
</span><span style=color:#65737e;>//若字符串有效，则返回1，否则返回0
</span><span style=color:#65737e;>//如果addrptr指针为空，那么该函数仍然对输入的字符串执行有效性检查，但是不存储任何结果。
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>inet_aton</span><span>(</span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>strptr</span><span>, </span><span style=color:#b48ead;>struct</span><span> in_addr *</span><span style=color:#bf616a;>addrptr</span><span>);
</span><span>
</span><span style=color:#65737e;>//若字符串有效，则返回32位二进制网络字节序的IPv4地址，否则返回INADDR_NONE
</span><span style=color:#65737e;>//NADDR_NONE常值通常是一个32位均为1的值，这意味着点分十进制数串255.255.255.255不能由该函数处理，因为其二进制值被用来指示函数失败。
</span><span>in_addr_t </span><span style=color:#8fa1b3;>inet_addr</span><span>(</span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>strptr</span><span>);
</span><span>
</span><span style=color:#65737e;>//返回一个点分十进制数串的指针
</span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#8fa1b3;>inet_ntoa</span><span>(</span><span style=color:#b48ead;>struct</span><span> in_addr </span><span style=color:#bf616a;>inaddr</span><span>);
</span><span>
</span></code></pre><h2 id=3-7-inet-ptonhe-inet-ntophan-shu>3.7 inet_pton和inet_ntop函数</h2><p>这两个函数对于IPv4地址和IPv6地址都适用。函数名中p和n分别代表<strong>表达（presentation）<strong>和</strong>数值（numeric）</strong>。<pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>arpa/inet.h</span><span>>
</span><span>
</span><span style=color:#65737e;>//函数执行成功返回1，表达的格式无效返回0，出错返回-1
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>inet_pton</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>family</span><span>, </span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>strptr</span><span>, </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>addptr</span><span>);
</span><span>
</span><span style=color:#65737e;>//函数执行成功返回指向结果的指针，出错返回NULL
</span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#8fa1b3;>inet_ntop</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>family</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>addptr</span><span>, </span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#bf616a;>strptr</span><span>, size_t </span><span style=color:#bf616a;>len</span><span>);
</span><span>
</span><span style=color:#65737e;>//family参数可以是AF_INET，也可以是AF_INET6，如果以不被支持的地址族作为family参数，两个函数就都返回一个错误，并将errno置为EAFNOSUPPORT
</span></code></pre><h3 id=zong-jie-5ge-han-shu>总结5个函数</h3><p><img alt=1579590914742 src=3.7%E6%80%BB%E7%BB%93.png><h2 id=3-8-sock-ntophe-xiang-guan-han-shu>3.8 sock_ntop和相关函数</h2><p>本书编写的协议无关性函数。函数名以sock_开头。<pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>#include </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#65737e;>//成功返回非空指针，出错返回NULL
</span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#8fa1b3;>sock_ntop</span><span>(</span><span style=color:#b48ead;>const struct</span><span> sockaddr * </span><span style=color:#bf616a;>sockaddr</span><span>, socklen_t </span><span style=color:#bf616a;>addrlen</span><span>);
</span><span>
</span><span style=color:#65737e;>//成功返回0，出错返回-1
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sock_bind_wild</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>family</span><span>);
</span><span>
</span><span style=color:#65737e;>//若地址为同一协议族且相同，则返回0，反则返回非0
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sock_cmp_addr</span><span>(</span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>sockaddr1</span><span>,
</span><span>                  </span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>sockaddr2</span><span>, socklen_t </span><span style=color:#bf616a;>addrlen</span><span>);
</span><span>
</span><span style=color:#65737e;>//若地址为同一协议族且端口相同，则返回0，反则返回非0
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sock_cmp_addr</span><span>(</span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>sockaddr1</span><span>,
</span><span>                  </span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>sockaddr2</span><span>, socklen_t </span><span style=color:#bf616a;>addrlen</span><span>);
</span><span>
</span><span style=color:#65737e;>//返回：若为IPv4或IPv6地址则为非负端口号，否则为-1
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sock_get_port</span><span>(</span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>sockaddr</span><span>, socklen_t </span><span style=color:#bf616a;>addrlen</span><span>);
</span><span>
</span><span style=color:#65737e;>//成功返回非空指针，出错返回NULL
</span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#8fa1b3;>sock_ntop_host</span><span>(</span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>sockaddr</span><span>, socklen_t </span><span style=color:#bf616a;>addrlen</span><span>);
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>sock_set_addr</span><span>(</span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>sockaddr</span><span>, 
</span><span>                   socklen_t </span><span style=color:#bf616a;>addrlen</span><span>, </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>ptr</span><span>);
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>sock_set_port</span><span>(</span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>sockaddr</span><span>,
</span><span>                   socklen_t </span><span style=color:#bf616a;>addrlen</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>port</span><span>);
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>sock_set_wild</span><span>(sturct sockaddr *</span><span style=color:#bf616a;>sockaddr</span><span>, socklen_t </span><span style=color:#bf616a;>addrlen</span><span>);
</span></code></pre><h2 id=3-9-readn-writenhe-readlinehan-shu>3.9 readn、writen和readline函数</h2><p>字节流套接字上的read和write函数所表现的行为不同于通常文件的I/O。字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少，然而这不是出错状态。原因在于：内核中用于套接字的缓冲区可能已经达到极限。此时需要的是调用者再次调用read或write函数，输入或输出剩余的字节。<p>这个现象在read一个字节流套接字时很常见，但是在write一个字节流时只能在该套接字为非阻塞的前提下才出现。<p>为了预防万一，不让返回的字节计数值不足，编写了三个函数。<pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#b48ead;>#include </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span>ssize_t </span><span style=color:#8fa1b3;>readn</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>filedes</span><span>, </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>buff</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>);
</span><span>ssize_t </span><span style=color:#8fa1b3;>written</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>filedes</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>buff</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>);
</span><span>ssize_t </span><span style=color:#8fa1b3;>readline</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>filedes</span><span>, </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>buff</span><span>, size_t </span><span style=color:#bf616a;>maxlen</span><span>);
</span></code></pre></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>