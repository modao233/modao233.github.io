<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/编程语言/Linux shell/shellbian-cheng-ji-chu/">shell编程基础</a></h1><div class=post-meta-inline><span class=post-date> 2020-11-19 </span></div><div class=post-content><p>原文：<ul><li><a href=https://my.oschina.net/FEEDFACF/blog/1789695>Shell入门看我吧</a><li><a href=https://blog.csdn.net/taiyang1987912/category_2514703.html>csdn专栏：shell基础，作者:乌托邦2号</a></ul><h2 id=1-yu-fa>1. 语法</h2><h3 id=1-1-bian-liang>1.1 变量</h3><p>变量是脚本语言的核心，shell脚本又是无类型的。变量本质上存储数据的一个或多个计算机内存地址，分为<ul><li>本地变量（用户当前shell生命期使用，随shell进程的消亡而无效，类似局部变量）<li>环境变量（适用于所有由登录进程所产生的子进程）<li>位置参数（向shell脚本传递参数，只读）</ul><h4 id=bian-liang-de-lei-xing>变量的类型</h4><p>shell是弱类型语言所以不需要使用类型限定，并且变量可以修改类型。<p>下面的例子定义了一个字符串类型的str变量，之后修改为数值类型<p>注意点：<strong>变量等号两边不能有空格出现</strong><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>modao@modao-hp:~$ str="abc"
</span><span>modao@modao-hp:~$ echo $str
</span><span>abc
</span><span>modao@modao-hp:~$ echo ${str}
</span><span>abc
</span><span>modao@modao-hp:~$ str=123
</span><span>modao@modao-hp:~$ echo $str
</span><span>123
</span><span>modao@modao-hp:~$ echo ${str}
</span><span>123
</span></code></pre><h5 id=wu-lei-xing-bian-liang>无类型变量</h5><ol><li><p>C中定义变量需要声明整型、浮点型、字符型等，而shell脚本变量却是无类型的。shell不支持浮点型<strong>只支持整型和字符型</strong>，同时字符型还具有一个整型值（判断标准：变量中只包含数字是数值型其他是字符串）。</p><li><p>位置参数：从命令行向shell脚本传递参数，$0表示脚本的名字，$1代表第一个参数，以此类推。<strong>从​${10}开始参数号需要用花括号括起来。</strong></p> <p>特殊的位置参数：</p> <table><thead><tr><th>变量名<th>作用<tbody><tr><td>$0<td>当前脚本的名字<tr><td>$n<td>传递给脚本或者函数的参数，n表示第几个参数<tr><td>$#<td>传递给脚本或函数的参数个数<tr><td>$*<td>传递给脚本或函数的所有参数<tr><td>$@<td>传递给脚本或者函数的所有参数<tr><td>$$<td>当前shell脚本进程的PID<tr><td>$?<td>函数返回值，或者上个命令的退出状态</table> <blockquote><p>$* 和 $@ 的区别<p>相同：$* 和 $@ 都表示传递给函数或脚本的所有参数不被双引号(" ")包含时，都以"$1" "$2" … "$n" 的形式输出所有参数。 区别：当它们被双引号(" ")包含时，"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数。</blockquote><li><p>内部变量：指能够对bash shell脚本行为产生影响的变量，属于环境变量的范畴。</p> <table><thead><tr><th>变量名<th>作用<tbody><tr><td>$BASH<td>BASH记录了shell的路径，通常是/bin/bash。内部变量SHELL是通过BASH的值确定当前Shell的类型<tr><td>$BASH_ENV<td>BASH的启动文件<tr><td>$BASH_VERSINFO<td>是一个包含6个元素的数组，这些元素用于表示bash的版本信息。<br>BASH_VERSINFO[0]表示bash shell的主版本号，BASH_VERSINFO[1]表示shell的次版本号，BASH_VERSINFO[2]表示shell的补丁级别，BASH_VERSINFO[3]表示shell的编译版本，BASH_VERSINFO[4]表示shell的发行状态，BASH_VERSINFO[5]表示shell的硬件架构。<tr><td>$BASH_VERSION<td>linux系统的bash shell版本包含主次版本、补丁级别、编译版本和发行状态，即BASH_VERSINFO数组取值为0~4。<tr><td>$EDITOR<td>脚本所调用的默认编辑器<tr><td>$EUID<td>当前有效的用户ID<tr><td>$FUNCNAME<td>当前函数名<tr><td>$GROUPS<td>当前用户所属组，linux的一个用户可同时包含在多个组内，GROUPS是一个数组记录了当前用户所属的所有群组号。管理用户组的文件是/etc/group，格式：群组名：加密后的组口令：群组号：组成员，组成员（组成员列表）。<tr><td>$HOME<td>当前用户家目录<tr><td>$HOSTTYPE<br>$MACHTYPE<td>都用于记录系统的硬件架构，它们与BASH_VERSINFO[5]等值<tr><td>$LINENO<td>当前行号<tr><td>$OSTYPE<td>记录操作系统类型，linux系统中，$OSTYPE=linux。<tr><td>$PATH<td>PATH路径<tr><td>$PPID<td>当前shell进程的父进程ID<tr><td>$PWD<td>当前工作目录<tr><td>$SECONDS<td>当前脚本运行秒数<tr><td>$TMOUT<td>不为0时，超过指定的秒将退出shell<tr><td>$UID<td>当前用户ID<tr><td>$DIRSTACK<td>它显示目录栈的栈顶值。linux目录栈用于存放工作目录，便于程序员手动控制目录的切换，bash shell定义了两个系统命令pushd（将某目录压入目录栈并将当前工作目录切换到入栈的目录）和popd（将栈顶目录弹出并将当前工作目录切换到栈顶目录）来维护目录栈。<br>DIRSTACK记录栈顶目录值，初值为空。linux还有一个命令dirs用于显示目录栈的所有内容。<tr><td>$GLOBIGNORE<td>它是由冒号分隔的模式列表，表示通配时忽略的文件名集合。一旦GLOBIGNORE非空，shell会将通配得到的结果中符合GLOBIGNORE模式中的目录去掉。例如ls a*列出当前目录以a开头的文件，设置GLOBIGNORE=“ar*”，再次执行ls a*将剔除以ar开头的文件。<tr><td>$HOSTNAME<td>HOSTNAME记录了主机名，linux主机名是网络配置时必须要设置的参数，可在/etc/sysconfig/network文件中设置主机名。/etc/hosts文件用于设定IP地址和主机名之间的对应关系，可快速从主机名查找IP地址。<tr><td>$REPLY<td>REPLY变量与read和select命令有关。read用于读取标准输入（stdin）的变量值，read variable将标准输入存储到variable变量中，而select将读到的标准输入存储到REPLY变量中。<tr><td>$SECONDS<td>SECONDS记录脚本从开始执行到结束所耗费的时间（单位为秒）。调试性能时比较有用。<tr><td>$SHELLOPTS<td>它记录了处于开状态的shell选项列表，它是一个只读变量。Shell选项用于改变Shell的行为，Shell选项有开和关两种状态，set命令用于打开或关闭选项。set -o optionname（打开名为optionname选项），set +o optionname（关闭名为optionname选项）。比如打开interactive（交互模式运行）可以使用set -o interactive或set -i等价。Shell选项有很多。<tr><td>$SHLVL<td>记录Shell嵌套的层次，启动第一个shell时，$SHLVL=1，若在这个Shell中执行脚本，脚本中的SHLVL为2，脚本中再执行子脚本，SHLVL就会递增。<tr><td>$TMOUT<td>用于设置Shell的过期时间，TMOUT不为0时，shell会在TMOUT秒后将自动注销，TMOUT放在脚本中可以规定脚本的执行时间。</table> <p>select脚本：</p> <pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>#!/bin/bash
</span><span># "</span><span style=color:#a3be8c;>#?</span><span>"提示符由shell提示符变量PS3进行设置（#?是其默认值）。
</span><span># 修改export PS3="</span><span style=color:#a3be8c;>your choice:</span><span>"。
</span><span># REPLY变量值为用户选择的序号，var变量为REPLY序号所对应的字符串。 
</span><span>echo "</span><span style=color:#a3be8c;>Pls. choose your profession?</span><span>"
</span><span>select var in "</span><span style=color:#a3be8c;>Worker</span><span>" "</span><span style=color:#a3be8c;>Doctor</span><span>" "</span><span style=color:#a3be8c;>Teacher</span><span>" "</span><span style=color:#a3be8c;>Student</span><span>" "</span><span style=color:#a3be8c;>Other</span><span>"
</span><span style=color:#b48ead;>do
</span><span>   echo "</span><span style=color:#a3be8c;>The </span><span style=background-color:#bf616a;color:#2b303b;>\$</span><span style=color:#a3be8c;>REPLY is $REPLY.</span><span>"  
</span><span>   echo "</span><span style=color:#a3be8c;>Your preofession is $var.</span><span>"
</span><span style=color:#b48ead;>break
</span><span>done
</span></code></pre></ol><h5 id=you-lei-xing-bian-liang>有类型变量</h5><p>Shell变量一般是无类型的，bash shell提供了declare和typeset两个命令用于指定变量的类型（它们完全等价）。<p><code>declare [选项] 变量名</code>，有6个选项。<table><thead><tr><th>选项名<th>意义<tbody><tr><td>-r<td>将变量设置为只读属性<tr><td>-i<td>将变量定义为整形数<tr><td>-a<td>将变量定义为数组<tr><td>-f<td>显示此脚本前定义过的所有函数名及其内容<tr><td>-F<td>仅显示此脚本前定义过的所有函数名<tr><td>-x<td>将变量声明为环境变量</table><p>declare命令-r选项将变量设置成只读属性，与readonly命令一样，变量值不允许修改。<p>declare命令-x选项将变量声明为环境变量，相当于export，但declare -x允许声明环境变量同时给变量赋值，而export不支持。<p>declare -i将变量定义为整型数，不能再按字符串形式处理改变量（和let命令进行算术运算一样，expr命令可以替换let命令）。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span style=color:#bf616a;>variable1</span><span>=</span><span style=color:#a3be8c;>2009
</span><span style=color:#bf616a;>variable2</span><span>=$</span><span style=color:#bf616a;>variable1</span><span style=color:#a3be8c;>+1
</span><span style=color:#96b5b4;>echo  </span><span>"</span><span style=color:#a3be8c;>variable2=</span><span>$</span><span style=color:#bf616a;>variable2</span><span>"
</span><span style=color:#96b5b4;>let</span><span> variable3=$</span><span style=color:#bf616a;>variable1</span><span>+</span><span style=color:#d08770;>1
</span><span style=color:#96b5b4;>echo  </span><span>"</span><span style=color:#a3be8c;>variable3=</span><span>$</span><span style=color:#bf616a;>variable3</span><span>"
</span><span style=color:#b48ead;>declare </span><span style=color:#bf616a;>-i variable4
</span><span style=color:#bf616a;>variable4</span><span>=$</span><span style=color:#bf616a;>variable1</span><span style=color:#a3be8c;>+1
</span><span style=color:#96b5b4;>echo  </span><span>"</span><span style=color:#a3be8c;>variable4=</span><span>$</span><span style=color:#bf616a;>variable4</span><span>"
</span></code></pre><h4 id=bian-liang-fu-zhi>变量赋值</h4><ul><li><p>变量赋值规则：</p> <ul><li>等号两边不能有空格<li>若value值包括空格必须用双引号<li>变量名只能由字母、数字、下画线组成，且不能以数字开头</ul><li><p>unset命令清除变量的值</p><li><p>变量赋值模式</p> <table><thead><tr><th>模式<th>意义<tbody><tr><td>variable=value<td>将value的值赋给变量variable<tr><td>variable+value<td>对已赋值的variable，重设其值<tr><td>variable?value 或 variable:?value<td>对未赋值的variable，显示系统错误信息<tr><td>variable:=value<td>对未赋值的variable，将value值赋给它<tr><td>variable:-value<td>对未赋值的variable，将value值赋给它，<br>但value值不存储到variable对应的地址空间</table><li><p>readonly将变量设置为只读，只读变量不能再次进行赋值操作</p> <pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>modao@modao-hp:~$</span><span> color=red
</span><span style=color:#bf616a;>modao@modao-hp:~$</span><span> readonly color
</span><span style=color:#bf616a;>modao@modao-hp:~$</span><span> color=blue
</span><span style=color:#bf616a;>-bash:</span><span> color: readonly variable
</span></code></pre></ul><h4 id=bian-liang-shi-yong>变量使用</h4><ul><li>可以用变量的值给变量赋值 <ul><li>在变量名称前面加上<code>$</code>符号，如<code>str1=$str2</code><li>把变量名放在<code>${}</code>中使用，如<code>str1=${str2}</code></ul><li>可以把命令执行结果作为右值赋值给变量 <ul><li>将命令放在<code>$()</code>括号中使用<li>将命令放在上引号中使用</ul></ul><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>modao@modao-hp:~$ dir1=$(pwd)
</span><span>modao@modao-hp:~$ echo $dir1
</span><span>/home/modao
</span><span>modao@modao-hp:~$ dir2=`pwd`
</span><span>modao@modao-hp:~$ echo $dir2
</span><span>/home/modao
</span></code></pre><h4 id=jian-jie-bian-liang-yin-yong>间接变量引用</h4><p>该引用不是将变量引起来，而是理解为：如果第一个变量的值是第二个变量的名字，从第一个变量的名字引用第二个变量的值就称为间接变量引用。<p>bash shell提供了两种格式实现间接变量引用：<ul><li><code>eval tempvar=\$$variable</code>，其中eval是关键字，用<code>\$$</code>形式得到variable的间接引用<li>``tempvar=${!variable}<code>，用</code>${!...}`得到variable的间接引用</ul><p>使用间接变量引用实现数据库表格的查找：<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>S01_name</span><span>="</span><span style=color:#a3be8c;>Li Hao</span><span>"
</span><span style=color:#bf616a;>S02_name</span><span>="</span><span style=color:#a3be8c;>Zhang Ju</span><span>"
</span><span style=color:#bf616a;>S03_name</span><span>="</span><span style=color:#a3be8c;>Zhu Lin</span><span>"
</span><span> 
</span><span style=color:#bf616a;>PS3</span><span>='</span><span style=color:#a3be8c;>Pls. select the number of student:</span><span>'
</span><span style=color:#bf616a;>select</span><span> stunum in "</span><span style=color:#a3be8c;>S01</span><span>" "</span><span style=color:#a3be8c;>S02</span><span>" "</span><span style=color:#a3be8c;>S03</span><span>"
</span><span style=color:#b48ead;>do
</span><span>  </span><span style=color:#bf616a;>name</span><span>=$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>stunum</span><span style=color:#a3be8c;>}_name </span><span style=color:#65737e;>#name变量的值是S01_name，S01_name是另一个变量的名字
</span><span> 					</span><span style=color:#65737e;>#从变量name得到变量S01_name的值，即为间接变量引用
</span><span>  </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>NAME:</span><span>$</span><span style=color:#a3be8c;>{</span><span>!</span><span style=color:#bf616a;>name</span><span style=color:#a3be8c;>}</span><span>"
</span><span>  </span><span style=color:#b48ead;>break
</span><span style=color:#b48ead;>done
</span></code></pre><h4 id=yin-yong>引用</h4><p>引用指将字符串用引用符号引起来，以防止特殊字符被shell脚本重解释为其他意义。<p>shell中定义了四种引用符号。<ol><li><p>双引号：美圆符号($)、反引号(`)和反斜线(\)仍被解释为特殊意义，其它字符均解释为字面意义，利用双引号引用变量能防止字符串分割，而保留变量中的空格。因此双引号的引用方式称为<strong>部分引用</strong>。</p><li><p>单引号：除单引号本身之外都解释为字面意义，不再具备引用变量的功能，单引号的引用方式称为<strong>全引用</strong>。</p><li><p>反引号：反引号进行命令替换（将命令的标准输出作为值赋给某个变量），等价于$()，同时$()形式的命令替换是可以嵌套的。</p> <pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;># 当前工作目录
</span><span>`</span><span style=color:#bf616a;>pwd</span><span>`
</span><span>$</span><span style=color:#bf616a;>(pwd)
</span></code></pre> <blockquote><p>反引号与$()在处理双反斜线时存在区别<ul><li><p>反引号将反斜线符号处理为空格</p><li><p>$()符号将其处理为单斜线符。</p></ul></blockquote><li><p>反斜线：表示转义，将屏蔽下一个字符的特殊意义，而以字面意义解析它。转义符除了屏蔽特殊字符的特殊意义外，加上一些字母能够表达特殊的含义（转义字符）。</p></ol><h3 id=1-2-da-yin>1.2 打印</h3><p>因为shell没有单步调试和其他功能强大的IDE，所以打印功能就经常使用到，此外打印功能还可以当做函数的返回值，比return作为函数的返回值功能更强大<p>shell 使用echo打印，内容默认输出到控制台中，echo可以打印字符串、变量、以及字符串中嵌入变量的混合内容<p>[更多内容见：echo详解]<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>modao@modao-hp:~$ str="abcd"
</span><span>modao@modao-hp:~$ echo $str
</span><span>abcd
</span><span>modao@modao-hp:~$ echo "the str = $str"
</span><span>the str = abcd
</span></code></pre><h3 id=1-3-yun-suan>1.3 运算</h3><h4 id=shi-yong-exprzhi-xing-suan-zhu-yun-suan>使用expr执行算术运算</h4><p>expr一般用于<strong>整数值计算和字符串</strong>的操作。<p>若expr的操作符是元字符（不是普通字符），需要用转义符将操作符的特殊含义屏蔽，进行数学运算，如<code>expr 2014 \* 2</code><p>expr中操作符的两端必须有空格，否则不会执行数学运算，如<code>expr 2014 - 2008</code><p>注意：*乘法运算符号需要转义<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/20140909091436484><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>modao@modao-hp:~$ ans=$(expr 3 + 8)
</span><span>modao@modao-hp:~$ echo $ans
</span><span>11
</span><span>modao@modao-hp:~$ ans=$(expr 3 - 8)
</span><span>modao@modao-hp:~$ echo $ans
</span><span>-5
</span><span>modao@modao-hp:~$ ans=$(expr 3 \* 8)
</span><span>modao@modao-hp:~$ echo $ans
</span><span>24
</span><span>modao@modao-hp:~$ ans=$(expr 24 / 8)
</span><span>modao@modao-hp:~$ echo $ans
</span><span>3
</span></code></pre><h4 id=shi-yong-zhi-xing-suan-zhu>使用[]执行算术</h4><p>[]执行算术比expr简单多了，并且*乘法运算符号不需要转义<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>modao@modao-hp:~$ ans=$[3 + 8]
</span><span>modao@modao-hp:~$ echo $ans
</span><span>11
</span><span>modao@modao-hp:~$ ans=$[3 - 8]
</span><span>modao@modao-hp:~$ echo $ans
</span><span>-5
</span><span>modao@modao-hp:~$ ans=$[3 * 8]
</span><span>modao@modao-hp:~$ echo $ans
</span><span>24
</span><span>modao@modao-hp:~$ ans=$[24 / 8]
</span><span>modao@modao-hp:~$ echo $ans
</span><span>3
</span></code></pre><h4 id=shuang-yuan-gua-hao-zhi-xing-suan-zhu-yun-shu>双圆括号执行算术运输</h4><p>双圆括号即((...))格式。result=$((var1*var2));var1和var2执行乘法运算。<p><strong>双圆括号可以使shell实现C语言风格的变量操作。</strong> 双圆括号实现五种C语言风格的运算：<ul><li>自增自减是shell算术运算符中未曾定义过的，是C语言中的相关内容<li>a = 2014，C语言允许赋值两端有空格但shell不允许<li>双圆括号还可以实现更加复杂的C语言的运算如逻辑判断、三元操作等。</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span>((a = </span><span style=color:#d08770;>2014</span><span>))
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The initial value of a is:</span><span>$</span><span style=color:#bf616a;>a</span><span>"
</span><span>((a++))
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>After a++,the value of a is:</span><span>$</span><span style=color:#bf616a;>a</span><span>"
</span><span>((++a))
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>After ++a,the value of a is:</span><span>$</span><span style=color:#bf616a;>a</span><span>"
</span><span>((a--))
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>After a--,the value of a is:</span><span>$</span><span style=color:#bf616a;>a</span><span>"
</span><span>((--a))
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>After --a,the value of a is:</span><span>$</span><span style=color:#bf616a;>a</span><span>"
</span></code></pre><h4 id=bcyun-suan-qi>bc运算器</h4><p>bash 不支持浮点运算，如果需要进行浮点运算，需要借助bc,awk 处理<p>bc是一种<strong>内建的运算器</strong>，是bash shell中最常用的浮点数运算工具，包括整型数和浮点数、数组变量、表达式、复杂程序结构和函数。<p>bc运算器支持的数学运算符号如下表：<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/20140909092840734><p>bc运算器定义了内建变量scale用于设定除法运算的精度（默认scale=0）。<p><img alt=image-20210320145626875 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20210320145626875.png><p>scale设为4后，除法结果小数点后保留4位。bc -q可以使bc运算器不输出版本信息。<p>在shell中用bc运算器进行浮点数运算需要使用命令替换的方式。脚本中调用bc运算器一般格式：<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>variable=`echo "options; expression" | bc`
</span></code></pre><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>var1</span><span>=</span><span style=color:#a3be8c;>20
</span><span style=color:#bf616a;>var2</span><span>=</span><span style=color:#a3be8c;>3.14159
</span><span style=color:#bf616a;>var3</span><span>=`</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>scale=5; </span><span>$</span><span style=color:#bf616a;>var1</span><span style=color:#a3be8c;> ^ 2</span><span>" | </span><span style=color:#bf616a;>bc</span><span>`
</span><span style=color:#bf616a;>var4</span><span>=`</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>scale=5; </span><span>$</span><span style=color:#bf616a;>var3</span><span style=color:#a3be8c;> * </span><span>$</span><span style=color:#bf616a;>var2</span><span>" | </span><span style=color:#bf616a;>bc</span><span>`
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The area of this circle is:</span><span>$</span><span style=color:#bf616a;>var4</span><span>"
</span></code></pre><p>bc运算器的指数运算计算var1变量的平方，scale=5输出结果的小数点后精确到第5位。<h3 id=1-4-kong-zhi>1.4 控制</h3><h4 id=shu-zhi-bi-jiao>数值比较</h4><p>控制使用<code>if/else/fi</code>语法，典型的数值比较如下<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>modao@modao-hp:~$ if [[ 3 > 7 ]];then echo "yes"; else echo "no"; fi
</span><span>no
</span><span>modao@modao-hp:~$ if [ 3 > 7 ];then echo "yes"; else echo "no"; fi
</span><span>yes
</span><span>modao@modao-hp:~$ if [[ 3 -gt 7 ]];then echo "yes"; else echo "no"; fi
</span><span>no
</span><span>modao@modao-hp:~$ if [ 3 -gt 7 ];then echo "yes"; else echo "no"; fi
</span><span>no
</span></code></pre><blockquote><p><a href=https://www.cnblogs.com/z977690557/p/10688856.html>shell if条件判断中：双中括号与单中括号的区别</a><p>单中括号的情况：当使用<code>if [ $1 = 1 ]</code>时，如果变量“参数”的值为空，那么就if语句就变成了<code>if [ = 1 ]</code>，这不是一个合法的条件。为了避免出现这种情况，必须给变量加上引号<code>if [ "$1" == "1" ]</code>，这样即使是空变量也提供了合法的测试条件<code>if [ " " == "1" ]</code><p>关于双中括号：<ul><li>双方括号提供了字符串比较的高级特性<li>括号中可以定义一些正则表达式来匹配字符串<li>注意不是所有的shell都支持双方括号！</ul><p>单中括号是比较基本的变量计算及数值比较的方法，一般情况下已经足够使用；双中括号是扩展的数值比较方法，里面的数值计算也相对来说复杂些。<p>引申：<ol><li>单括号和双括号的区别<li>单引号和双引号的区别</ol></blockquote><h4 id=zheng-shu-bi-jiao-yun-suan-fu>整数比较运算符</h4><table><thead><tr><th>比较符<th>描述<tbody><tr><td>n1 -eq n2<td>检查n1是否与n2相等<tr><td>n1 -ge n2<td>检查n1是否大于或等于n2<tr><td>n1 -gt n2<td>检查n1是否大于n2<tr><td>n1 -le n2<td>检查n1是否小于或等于n2<tr><td>n1 -lt n2<td>检查n1是否小于n2<tr><td>n1 -ne n2<td>检查n1是否不等于n2</table><h4 id=zi-fu-chuan-yun-suan-fu>字符串运算符</h4><p>Shell编程是严格区分大小写的，并注意空格的问题，运算符左右的空格不能少。<table><thead><tr><th>比较符<th>描述<tbody><tr><td>str1 = str2<td>检查str1是否和str2相同<tr><td>str1 != str2<td>检查str1是否和str2不同<tr><td>str1 < str2<td>检查str1是否比str2小<tr><td>str1 > str2<td>检查str1是否比str2大<tr><td>-n str1<br>str1<td>检查str1的长度是否非0<tr><td>-z str1<td>检查str1的长度是否为0</table><h4 id=wen-jian-cao-zuo-fu>文件操作符</h4><table><thead><tr><th>比较符<th>描述<tbody><tr><td>-d file<td>检查file是否存在并是一个目录<tr><td>-e file<td>检查file是否存在<tr><td>-f file<td>检查file是否存在并是一个文件<tr><td>-r file<td>检查file是否存在并可读<tr><td>-s file<td>检查file是否存在并非空<tr><td>-w file<td>检查file是否存在并可写<tr><td>-x file<td>检查file是否存在并可执行<tr><td>-L file<td>测试file是否符合化链接<tr><td>-O file<td>检查file是否存在并属当前用户所有<tr><td>-G file<td>检查file是否存在并且默认组与当前用户相同<tr><td>file1 -nt file2<td>检查file1是否比file2新<tr><td>file1 -ot file2<td>检查file1是否比file2旧</table><h4 id=luo-ji-yun-suan-fu>逻辑运算符</h4><table><thead><tr><th>逻辑操作符<th>描述<tbody><tr><td>! expression<td>如果expression为假，测试结果为真<tr><td>expression1 -a expression2<td>如果expression1和expression2同时为真，则测试结果为真<tr><td>expression1 -o expression2<td>如果expression1和expression2中有一个为真，则测试结果为真</table><p>用于测试多个条件是否为真或为假，也可使用逻辑非测试单个表达式。<p>表达式：expression1 -a expression1 -aexpression1（并不是所有的运算符都会被执行，只有表达式expression1为真，才会测试expression2为真。只有expression1和expression2都为真才会接着测试expression3是否为真）<p>表达式：expression1 -aexpression1 -aexpression1（只要expression1为真，就不用去测试表达式expression2和expression3。只有expression1为假时才会去判断表达式expression2和expression3。同样，只有expression2和expression3同时为假时才会去测试expression3）<h4 id=suan-zhu-yun-suan-fu>算术运算符</h4><table><thead><tr><th>运算符<th>描述<tbody><tr><td>+<td>加运算<tr><td>-<td>减运算<tr><td>*<td>乘运算<tr><td>/<td>除运算<tr><td>%<td>取余运算<tr><td>**<td>幂运算</table><p>使用let命令来执行算术运算，除法和取余运算过程中要注意除数不能为0，使用算术运算符无法对字符串、文件、浮点型数进行计算（浮点型操作，需要用到专门的函数）。<p>算术运算符与赋值运算符"="联用，称为<strong>算术复合赋值运算符</strong>：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>。<p><strong>自增自减运算符</strong><p>自增自减运算符包括前置自增、前置自减、后置自增和后置自减。自增自减操作符的操作元只能是变量，不能是常数或表达式，且该变量值必须为整数型。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/sh
</span><span> 
</span><span> </span><span style=color:#bf616a;>num1</span><span>=</span><span style=color:#a3be8c;>5
</span><span> 
</span><span> </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>a=5+(++num1) </span><span>"
</span><span> </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>a=</span><span>$</span><span style=color:#bf616a;>a</span><span>"
</span><span> 
</span><span> </span><span style=color:#bf616a;>num2</span><span>=</span><span style=color:#a3be8c;>5
</span><span> 
</span><span> </span><span style=color:#96b5b4;>let  </span><span>"</span><span style=color:#a3be8c;>b=5+(num2++) </span><span>"
</span><span> </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>b=</span><span>$</span><span style=color:#bf616a;>b</span><span>"
</span></code></pre><p><strong>数字常量</strong><p>脚本或命令默认将数字以十进制的方式进行处理，当使用0作为前缀时表示八进制，当使用0x进行标记时表示十六进制，同时还可使用num#这种形式标记进制数。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/sh
</span><span> 
</span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>num1=40</span><span>"
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>num1=</span><span>$</span><span style=color:#bf616a;>num1</span><span>"
</span><span> 
</span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>num2=040</span><span>"
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>num2=</span><span>$</span><span style=color:#bf616a;>num2</span><span>"
</span><span> 
</span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>num3=0x40</span><span>"
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>num3=</span><span>$</span><span style=color:#bf616a;>num3</span><span>"
</span></code></pre><h4 id=wei-yun-suan-fu>位运算符</h4><p>用于<strong>整数间的运算</strong><p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/20140828143826259><p>位运算符同样可以同赋值运算符联用，组成<strong>复合赋值运算符</strong>。<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/20140828143844246><h4 id=ce-shi-ming-ling-test>测试命令test</h4><p>Linux中shell的测试命令，用于测试某种条件或某几种条件是否真实存在。<p>测试命令是判断语句和循环语句中条件测试的工具，对判断和运算符的比较测试有很大的帮助。<p>测试条件为真，返回一个0值；为假，返回一个非0整数值。<p>测试命令有两种方式<ul><li><code>test expression</code><li><code>[ expression ]</code>，其中<code>[</code>是启动测试命令，<code>]</code>要与之配对，而且"["和"]"前后的空格必不可少，此方式常作为流程控制语句的判断条件。</ul><h4 id=tui-chu-zhuang-tai>退出状态</h4><p>Linux系统，每当命令执行完成后，系统返回一个退出状态。<ul><li>若退出状态值为0，表示命令运行成功<li>反之若退出状态值不为0，则表示命令运行失败<li>最后一次执行命令的退出状态值被保存在内置变量<code>$?</code>中。</ul><table><thead><tr><th>状态值<th>含义<tbody><tr><td>0<td>表示运行成功，程序执行没有遇到任何问题<tr><td>1~125<td>表示运行失败，脚本命令、系统命令错误或参数传递错误<tr><td>126<td>找到了改命令但无法执行<tr><td>127<td>未找到要运行的命令<tr><td>>128<td>命令被系统强行结束</table><p>exit命令格式：<code>exit status</code>（status在0～255之间），返回该状态值时伴随脚本的退出，参数被保存在shell变量<code>$?</code>中<h4 id=iftiao-jian-pan-duan>if条件判断</h4><p>if、then、else语句用于判断给定的条件是否满足，并根据测试条件的真假来选择相应的操作。if/else仅仅用于两分支判断，多分支的选择时需要用到if/else语句嵌套、if/elif/else和case多分支选择判断结构。<p><strong>if结构</strong><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/sh
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Please input a integer:</span><span>"
</span><span style=color:#96b5b4;>read</span><span> integer1
</span><span> 
</span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>integer1</span><span>" </span><span style=color:#bf616a;>-lt</span><span> 15 </span><span style=color:#96b5b4;>]
</span><span>  </span><span style=color:#b48ead;>then </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The integer lower than 15.</span><span>"
</span><span style=color:#b48ead;>fi
</span></code></pre><p>注意：测试条件后如果没有";"则then语句要换行。<p><strong>if/else结构</strong><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/sh
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Please input the file which you want to delete:</span><span>"
</span><span style=color:#96b5b4;>read</span><span> file
</span><span> 
</span><span style=color:#b48ead;>if </span><span style=color:#bf616a;>rm -f </span><span>"$</span><span style=color:#bf616a;>file</span><span>"
</span><span style=color:#b48ead;>then
</span><span>  </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Delete the file </span><span>$</span><span style=color:#bf616a;>file</span><span style=color:#a3be8c;>  sucessfully!</span><span>"
</span><span style=color:#b48ead;>else
</span><span>  </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Delete the file </span><span>$</span><span style=color:#bf616a;>file</span><span style=color:#a3be8c;> failed!</span><span>"
</span><span style=color:#b48ead;>fi
</span></code></pre><p><strong>if/else语句嵌套</strong><p>可同时判断三个或三个以上条件，但要注意if与else配对关系，else语句总是与它上面最近的未配对的if配对。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span style=color:#65737e;>#提示用户输入分数（0-100）
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Please Input a integer(0-100): </span><span>"
</span><span style=color:#96b5b4;>read</span><span> score
</span><span> 
</span><span style=color:#65737e;>#判断学生的分数类别
</span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-lt</span><span> 0 </span><span style=color:#bf616a;>-o </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-gt</span><span> 100 </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>then
</span><span>   </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The score what you input is not integer or the score is not in (0-100).</span><span>"
</span><span style=color:#b48ead;>else
</span><span>     </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 90 </span><span style=color:#96b5b4;>]
</span><span>     </span><span style=color:#b48ead;>then
</span><span>         </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is A!</span><span>"
</span><span>     </span><span style=color:#b48ead;>else
</span><span>          </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 80 </span><span style=color:#96b5b4;>]
</span><span>          </span><span style=color:#b48ead;>then
</span><span>              </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is B!</span><span>"
</span><span>          </span><span style=color:#b48ead;>else
</span><span>               </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 70 </span><span style=color:#96b5b4;>]
</span><span>              </span><span style=color:#b48ead;>then
</span><span>                   </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is C!</span><span>"
</span><span>              </span><span style=color:#b48ead;>else
</span><span>                   </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 60 </span><span style=color:#96b5b4;>]
</span><span>                   </span><span style=color:#b48ead;>then
</span><span>                        </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is D!</span><span>"
</span><span>                   </span><span style=color:#b48ead;>else
</span><span>                        </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is E!</span><span>"
</span><span>                   </span><span style=color:#b48ead;>fi
</span><span>              </span><span style=color:#b48ead;>fi
</span><span>         </span><span style=color:#b48ead;>fi
</span><span>    </span><span style=color:#b48ead;>fi
</span><span style=color:#b48ead;>fi
</span></code></pre><p><strong>if/elif/else结构</strong><p>if/else嵌套在编程中很容易漏掉then或fi产生错误，而且可读性很差，因此引入if/elif/else结构针对某一事件的多种情况进行处理，fi只出现一次，可读性也提高了。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash  
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Please Input a integer(0-100): </span><span>"
</span><span style=color:#96b5b4;>read</span><span> score
</span><span> 
</span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-lt</span><span> 0 </span><span style=color:#bf616a;>-o </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-gt</span><span> 100 </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>then
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The score what you input is not integer or the score is not in (0-100).</span><span>"
</span><span style=color:#b48ead;>elif </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 90 </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>then
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is A!</span><span>"
</span><span style=color:#b48ead;>elif </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 80 </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>then
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is B!</span><span>"
</span><span style=color:#b48ead;>elif </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 70 </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>then
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is C!</span><span>"
</span><span style=color:#b48ead;>elif </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>score</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 60 </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>then
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is D!</span><span>"
</span><span style=color:#b48ead;>else
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The grade is E!</span><span>"
</span><span style=color:#b48ead;>fi
</span></code></pre><p><strong>case结构</strong><p>case结构变量值依次比较，遇到双分号则跳到esac后的语句执行，没有匹配则脚本将执行默认值<code>*)</code>后的命令，直到<code>;;</code>为止。<p>case的匹配值必须是常量或正则表达式。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span>  
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Please Input a score_type(A-E): </span><span>"
</span><span style=color:#96b5b4;>read</span><span> score_type
</span><span> 
</span><span style=color:#b48ead;>case </span><span>"$</span><span style=color:#bf616a;>score_type</span><span>" </span><span style=color:#b48ead;>in
</span><span>A</span><span style=color:#b48ead;>)
</span><span>     </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The range of score is from 90 to 100 !</span><span>";;
</span><span>B</span><span style=color:#b48ead;>)
</span><span>     </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The range of score is from 80 to 89 !</span><span>";;
</span><span>C</span><span style=color:#b48ead;>)
</span><span>     </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The range of score is from 70 to 79 !</span><span>";;
</span><span>D</span><span style=color:#b48ead;>)
</span><span>     </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The range of score is from 60 to 69 !</span><span>";;
</span><span>E</span><span style=color:#b48ead;>)
</span><span>     </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>The range of score is from 0 to 59 !</span><span>";;
</span><span>*</span><span style=color:#b48ead;>)
</span><span>     </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>What you input is wrong !</span><span>";;
</span><span style=color:#b48ead;>esac
</span></code></pre><h3 id=1-5-xun-huan>1.5 循环</h3><p>三种常用的循环语句：for、while和until。while循环和for循环属于“当型循环”，而until属于“直到型循环”。<p>循环控制符：break和continue控制流程转向。<h4 id=forxun-huan>for循环</h4><p><strong>列表for循环</strong><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#b48ead;>for</span><span> varible1 </span><span style=color:#b48ead;>in </span><span>{1..5}
</span><span style=color:#65737e;>#for varible1 in 1 2 3 4 5
</span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Hello, Welcome </span><span>$</span><span style=color:#bf616a;>varible1</span><span style=color:#a3be8c;> times </span><span>"
</span><span style=color:#b48ead;>done
</span></code></pre><ul><li>按规定的步数进行跳跃的方式实现列表for循环</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span style=color:#bf616a;>sum</span><span>=</span><span style=color:#a3be8c;>0
</span><span> 
</span><span style=color:#b48ead;>for</span><span> i </span><span style=color:#b48ead;>in </span><span>{1..100..2}
</span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>sum+=i</span><span>"
</span><span style=color:#b48ead;>done
</span><span>    
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>sum=</span><span>$</span><span style=color:#bf616a;>sum</span><span>"
</span></code></pre><ul><li>for循环对字符串进行操作</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#b48ead;>for</span><span> file </span><span style=color:#b48ead;>in </span><span>$( </span><span style=color:#bf616a;>ls </span><span>)
</span><span style=color:#65737e;># 也可一使用for file in *
</span><span style=color:#65737e;># 通配符*产生文件名扩展，匹配当前目录下的所有文件。
</span><span style=color:#65737e;>#for file in *
</span><span style=color:#b48ead;>do
</span><span>   </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>file: </span><span>$</span><span style=color:#bf616a;>file</span><span>"
</span><span style=color:#b48ead;>done
</span></code></pre><ul><li>for通过命令行来传递脚本中for循环列表参数</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span style=color:#65737e;># $#表示参数的个数，$@表示参数列表，$*则把所有的参数当作一个字符串显示。
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>number of arguments is </span><span>$</span><span style=color:#bf616a;>#</span><span>"
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>What you input is: </span><span>"
</span><span style=color:#b48ead;>for</span><span> argument </span><span style=color:#b48ead;>in </span><span>"$</span><span style=color:#bf616a;>@</span><span>"
</span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"$</span><span style=color:#bf616a;>argument</span><span>"
</span><span style=color:#b48ead;>done
</span></code></pre><p><strong>不带列表for循环</strong><p>由用户制定参数和参数的个数，与上述的for循环列表参数功能相同。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>number of arguments is </span><span>$</span><span style=color:#bf616a;>#</span><span>"
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>What you input is: </span><span>"
</span><span style=color:#b48ead;>for</span><span> argument
</span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"$</span><span style=color:#bf616a;>argument</span><span>"
</span><span style=color:#b48ead;>done
</span></code></pre><p><strong>C语言格式的for循环</strong><p>也被称为计次循环<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>num=0
</span><span>for (( i = 0; i < 10; i++ )); do
</span><span>	num=$[$num + $i]
</span><span>done
</span><span>echo "result = ${num}"
</span><span>## output：result = 45
</span></code></pre><p><strong>for in 循环处理文件</strong><p>data文件内容如下：<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>echo "=======循环for in======="
</span><span>
</span><span>file="data"
</span><span>IFS_OLD=$IFS
</span><span>IFS=$'\n'
</span><span>for line in $(cat $file)
</span><span>do
</span><span>	echo "${line}"
</span><span>done
</span><span>IFS=${IFS_OLD}
</span><span>
</span><span># 输出：=======循环for in=======
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown fox jumps over the lazy dog.
</span></code></pre><h4 id=while-xun-huan>while 循环</h4><p>while表示条件满足执行循环<ul><li>计数器控制的while循环</ul><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#!/bin/bash
</span><span>sum=0
</span><span>i=1
</span><span>while(( i <= 100 ))
</span><span>do
</span><span>    let "sum+=i"
</span><span>    let "i += 2"   
</span><span>done
</span><span> 
</span><span>echo "sum=$sum"
</span></code></pre><ul><li>结束标记控制的while循环</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Please input the num(1-10) </span><span>"
</span><span style=color:#96b5b4;>read</span><span> num
</span><span> 
</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>[[ </span><span>"$</span><span style=color:#bf616a;>num</span><span>" != 4 </span><span style=color:#96b5b4;>]]
</span><span style=color:#b48ead;>do 
</span><span>   </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>num</span><span>" </span><span style=color:#bf616a;>-lt</span><span> 4 </span><span style=color:#96b5b4;>]
</span><span>   </span><span style=color:#b48ead;>then
</span><span>        </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Too small. Try again!</span><span>"
</span><span>        </span><span style=color:#96b5b4;>read</span><span> num
</span><span>   </span><span style=color:#b48ead;>elif </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>num</span><span>" </span><span style=color:#bf616a;>-gt</span><span> 4 </span><span style=color:#96b5b4;>]
</span><span>   </span><span style=color:#b48ead;>then
</span><span>         </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>To high. Try again</span><span>" 
</span><span>         </span><span style=color:#96b5b4;>read</span><span> num
</span><span>   </span><span style=color:#b48ead;>else
</span><span>       </span><span style=color:#96b5b4;>exit</span><span> 0
</span><span>    </span><span style=color:#b48ead;>fi
</span><span style=color:#b48ead;>done 
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Congratulation, you are right! </span><span>"
</span></code></pre><ul><li>标志控制的while循环</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;># 使用用户输入的标志值来控制循环的结束（避免不知道循环结束标志的条件）。
</span><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Please input the num </span><span>"
</span><span style=color:#96b5b4;>read</span><span> num
</span><span> 
</span><span style=color:#bf616a;>sum</span><span>=</span><span style=color:#a3be8c;>0
</span><span style=color:#bf616a;>i</span><span>=</span><span style=color:#a3be8c;>1
</span><span> 
</span><span style=color:#bf616a;>signal</span><span>=</span><span style=color:#a3be8c;>0
</span><span> 
</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>[[ </span><span>"$</span><span style=color:#bf616a;>signal</span><span>" </span><span style=color:#bf616a;>-ne</span><span> 1 </span><span style=color:#96b5b4;>]]
</span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>i</span><span>" </span><span style=color:#bf616a;>-eq </span><span>"$</span><span style=color:#bf616a;>num</span><span>" </span><span style=color:#96b5b4;>]
</span><span>    </span><span style=color:#b48ead;>then 
</span><span>       </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>signal=1</span><span>"
</span><span>       </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>sum+=i</span><span>"
</span><span>       </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>1+2+...+</span><span>$</span><span style=color:#bf616a;>num</span><span style=color:#a3be8c;>=</span><span>$</span><span style=color:#bf616a;>sum</span><span>"
</span><span>    </span><span style=color:#b48ead;>else
</span><span>       </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>sum=sum+i</span><span>"
</span><span>       </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>i++</span><span>"
</span><span>    </span><span style=color:#b48ead;>fi
</span><span style=color:#b48ead;>done
</span></code></pre><p>控制的while循环求1～n的累加和，循环变量值小于100执行else累加同时循环变量加1，直到循环变量值等于100将标志值设置为1，并输出。<p>控制的while循环与结束标记控制的while循环的区别是用户无法确定无法确定结束标志，只能程序运行后确定结束标志。两者也可以相互转化。<ul><li>命令行控制的while循环</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>number of arguments is </span><span>$</span><span style=color:#bf616a;>#</span><span>"
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>What you input is: </span><span>"
</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>[[ </span><span>"$</span><span style=color:#bf616a;>*</span><span>" != "" </span><span style=color:#96b5b4;>]]
</span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"$</span><span style=color:#bf616a;>1</span><span>"
</span><span>    </span><span style=color:#96b5b4;>shift
</span><span style=color:#b48ead;>done
</span></code></pre><h4 id=until-xun-huan>until 循环</h4><p>until和<code>while</code>相反，表示条件不满足执行循环<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>j=1
</span><span>line=""
</span><span>until [[ j -eq 10 ]]; do
</span><span>	if [[ j -le i ]]; then
</span><span>		result=$(expr $i \* $j)
</span><span>		resultStr="$j X $i = $result"
</span><span>		line=${line}${resultStr}"\t"
</span><span>	fi
</span><span>	j=$(expr $j + 1)
</span><span>done
</span><span>echo -e ${line}
</span></code></pre><h4 id=xun-huan-qian-tao>循环嵌套</h4><p>一个循环体内又包含另一个完整的循环结构，在外部循环的每次执行过程中都会触发内部循环，for、while、until可以相互嵌套。<ul><li>嵌套循环实现九九乘法表</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#b48ead;>for </span><span>(( i = </span><span style=color:#d08770;>1</span><span>; i <=</span><span style=color:#d08770;>9</span><span>; i++ ))
</span><span style=color:#b48ead;>do
</span><span>    
</span><span>    </span><span style=color:#b48ead;>for </span><span>(( j=</span><span style=color:#d08770;>1</span><span>; j <= i; j++ ))
</span><span>    </span><span style=color:#b48ead;>do
</span><span>        </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>temp = i * j</span><span>"     
</span><span>        </span><span style=color:#96b5b4;>echo </span><span style=color:#bf616a;>-n </span><span>"$</span><span style=color:#bf616a;>i</span><span style=color:#a3be8c;>*</span><span>$</span><span style=color:#bf616a;>j</span><span style=color:#a3be8c;>=</span><span>$</span><span style=color:#bf616a;>temp  </span><span>"
</span><span>     </span><span style=color:#b48ead;>done 
</span><span>     
</span><span>     </span><span style=color:#96b5b4;>echo </span><span>""   </span><span style=color:#65737e;>#output newline
</span><span style=color:#b48ead;>done
</span></code></pre><ul><li>for循环嵌套实现*图案排列</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#b48ead;>for </span><span>((i=</span><span style=color:#d08770;>1</span><span>; i <= </span><span style=color:#d08770;>9</span><span>; i++))
</span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#bf616a;>j</span><span>=</span><span style=color:#a3be8c;>9</span><span>;
</span><span>    </span><span style=color:#b48ead;>while </span><span>((j > i))
</span><span>    </span><span style=color:#b48ead;>do
</span><span>        </span><span style=color:#96b5b4;>echo </span><span style=color:#bf616a;>-n </span><span>" "
</span><span>        </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>j--</span><span>"
</span><span>    </span><span style=color:#b48ead;>done
</span><span>    </span><span style=color:#bf616a;>k</span><span>=</span><span style=color:#a3be8c;>1
</span><span>    </span><span style=color:#b48ead;>while </span><span>((k <= i))
</span><span>    </span><span style=color:#b48ead;>do
</span><span>        </span><span style=color:#96b5b4;>echo </span><span style=color:#bf616a;>-n </span><span>"</span><span style=color:#a3be8c;>*</span><span>"
</span><span>        </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>k++</span><span>"
</span><span>    </span><span style=color:#b48ead;>done
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>""
</span><span style=color:#b48ead;>done
</span></code></pre><h4 id=xun-huan-kong-zhi-fu-breakhe-continue>循环控制符break和continue</h4><ul><li>break</ul><p>在for、while和until循环中break可强行退出循环，break语句仅能退出当前的循环，如果是两层循环嵌套，则需要在外层循环中使用break。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>sum</span><span>=</span><span style=color:#a3be8c;>0
</span><span style=color:#b48ead;>for </span><span>(( i=</span><span style=color:#d08770;>1</span><span>; i <= </span><span style=color:#d08770;>100</span><span>; i++))
</span><span style=color:#b48ead;>do 
</span><span>    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>sum+=i</span><span>"
</span><span> 
</span><span>    </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>sum</span><span>" </span><span style=color:#bf616a;>-gt</span><span> 1000 </span><span style=color:#96b5b4;>]
</span><span>    </span><span style=color:#b48ead;>then
</span><span>        </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>1+2+...+</span><span>$</span><span style=color:#bf616a;>i</span><span style=color:#a3be8c;>=</span><span>$</span><span style=color:#bf616a;>sum</span><span>"
</span><span>        </span><span style=color:#b48ead;>break
</span><span>    </span><span style=color:#b48ead;>fi
</span><span style=color:#b48ead;>done
</span></code></pre><ul><li>continue</ul><p>在for、while和until中用于让脚本跳过其后面的语句，执行下一次循环。continue用于显示100内能被7整除的数。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>m</span><span>=</span><span style=color:#a3be8c;>1
</span><span style=color:#b48ead;>for </span><span>(( i=</span><span style=color:#d08770;>1</span><span>; i < </span><span style=color:#d08770;>100</span><span>; i++ ))
</span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>temp1=i%7</span><span>"         </span><span style=color:#65737e;>#被7整除
</span><span> 
</span><span>    </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>temp1</span><span>" </span><span style=color:#bf616a;>-ne</span><span> 0 </span><span style=color:#96b5b4;>]
</span><span>    </span><span style=color:#b48ead;>then
</span><span>        </span><span style=color:#b48ead;>continue
</span><span>    </span><span style=color:#b48ead;>fi
</span><span>    
</span><span>    </span><span style=color:#96b5b4;>echo </span><span style=color:#bf616a;>-n </span><span>"$</span><span style=color:#bf616a;>i  </span><span>"
</span><span>    
</span><span>    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>temp2=m%7</span><span>"          </span><span style=color:#65737e;>#7个数字换一行
</span><span>    
</span><span>    </span><span style=color:#b48ead;>if  </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>temp2</span><span>" </span><span style=color:#bf616a;>-eq</span><span> 0 </span><span style=color:#96b5b4;>]
</span><span>    </span><span style=color:#b48ead;>then
</span><span>        </span><span style=color:#96b5b4;>echo </span><span>""
</span><span>    </span><span style=color:#b48ead;>fi
</span><span>    
</span><span>    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>m++</span><span>"
</span><span style=color:#b48ead;>done
</span></code></pre><h4 id=selectjie-gou>select结构</h4><p>select结构从技术角度看不能算是循环结构，只是相似而已，它是bash的扩展结构用于交互式菜单显示，功能类似于case结构比case的交互性要好。<ul><li>select带参数列表</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>What is your favourite color? </span><span>"
</span><span style=color:#bf616a;>select</span><span> color in "</span><span style=color:#a3be8c;>red</span><span>" "</span><span style=color:#a3be8c;>blue</span><span>" "</span><span style=color:#a3be8c;>green</span><span>" "</span><span style=color:#a3be8c;>white</span><span>" "</span><span style=color:#a3be8c;>black</span><span>"
</span><span style=color:#b48ead;>do 
</span><span>    </span><span style=color:#b48ead;>break
</span><span style=color:#b48ead;>done
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>You have selected </span><span>$</span><span style=color:#bf616a;>color</span><span>"
</span></code></pre><ul><li>select不带参数列表</ul><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>What is your favourite color? </span><span>"
</span><span> 
</span><span style=color:#bf616a;>select</span><span> color
</span><span style=color:#b48ead;>do 
</span><span>    </span><span style=color:#b48ead;>break
</span><span style=color:#b48ead;>done
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>You have selected </span><span>$</span><span style=color:#bf616a;>color</span><span>"
</span></code></pre><h3 id=1-6-rong-qi>1.6 容器</h3><h4 id=shu-zu-ding-yi>数组定义</h4><p>数组（Array）是一个由若干同类型变量组成的集合，数组均由连续的存储单元组成，最低地址对应于数组的第一个元素，最高地址对应于最后一个元素。<p>数组的定义如下<code>declare -a array_name</code><blockquote><p>osx系统因为bash的版本太低，只能定义索引数组<p>在bash版本高于4.1的版本可以使用<code>declare -A array_name</code>定义关联数组</blockquote><p>以下的代码片定义一个数组，用于保存配置文件中的内容，然后使用for循环遍历数组内容输出到控制台。<ul><li><code>a[$n]=$line</code>把内容保存到数组<li><code>${a[@]}</code> 获取数组的所有元素，打印时只打印被赋值的元素而不打印未赋值的元素<li><code>${#a[@]}</code> 获取数组的元素个数<li><code>temp=${a[i]}</code>读取数组第i个元素</ul><blockquote><p><code>"${a[@]}"</code>将数组的所有元素分行打印，而<code>"${a[*]}"</code>只能将数组的所有元素打印在一行内且中间以IFS分隔。<p>不用引号时<code>${a[@]}</code>和<code>${a[*]}</code>是等价的，使用引号时，@和*只是打印数组的方式存在差异。</blockquote><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;># 可以用圆括号将一组值赋给数组
</span><span style=color:#bf616a;>city</span><span>=(Nanjing Beijing Melbourne NewYork)
</span><span>
</span><span style=color:#65737e;># 可以按照任意顺序指定任意元素对数组赋值
</span><span style=color:#bf616a;>city</span><span>=([2]=Nanjing [10]=Atlanta [1]=Massachusetts [5]=Marseilles)
</span><span>
</span><span style=color:#65737e;># Shell中允许数组空缺元素，即可以不连续地给数组赋值
</span><span style=color:#65737e;># 指定所赋元素的标号，并以此标号为起点继续赋值
</span><span style=color:#bf616a;>city</span><span>=(Nanjing [10]=Atlanta Massachusetts Marseilles)
</span><span>
</span><span style=color:#65737e;># 用引号包含空格的字符串
</span><span style=color:#bf616a;>city[</span><span style=color:#d08770;>1</span><span style=color:#bf616a;>]</span><span>="</span><span style=color:#a3be8c;>Hong Kong</span><span>"       
</span></code></pre><h4 id=shu-zu-yong-fa>数组用法</h4><p>数组的字符串操作与字符串操作的符号和意义完全一致，数组字符串操作特殊之处在于所有的操作都是针对所有的数组元素逐个进行的。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#数组的字符串操作
</span><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>city</span><span>=(Nanjing Atlanta Massachusetts MaseillesMas)
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Extracting Substring</span><span>"  </span><span style=color:#65737e;>#抽取字串
</span><span style=color:#96b5b4;>echo </span><span>${</span><span style=color:#bf616a;>city[*]</span><span>:</span><span style=color:#d08770;>0</span><span>}            </span><span style=color:#65737e;>#抽取整个数组  Nanjing Atlanta Massachusetts Marseilles
</span><span style=color:#96b5b4;>echo </span><span>${</span><span style=color:#bf616a;>city[*]</span><span>:</span><span style=color:#d08770;>1</span><span>}            </span><span style=color:#65737e;>#抽取从第1个元素到结束的数组  Atlanta Massachusetts Marseilles
</span><span style=color:#96b5b4;>echo </span><span>${</span><span style=color:#bf616a;>city[*]</span><span>:</span><span style=color:#d08770;>3</span><span>}            </span><span style=color:#65737e;>#抽取从第3个元素到结束的数组  Marseilles
</span><span style=color:#96b5b4;>echo </span><span>${</span><span style=color:#bf616a;>city[*]</span><span>:</span><span style=color:#d08770;>0</span><span>:</span><span style=color:#d08770;>2</span><span>}          </span><span style=color:#65737e;>#抽取从第0个元素开始的两个元素  Nanjing Atlanta
</span><span style=color:#96b5b4;>echo
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Removing Substring</span><span>"    </span><span style=color:#65737e;>#删除字串
</span><span style=color:#96b5b4;>echo </span><span>${</span><span style=color:#bf616a;>city[*]</span><span>#M*a}          </span><span style=color:#65737e;>#删除匹配M*a的最短字串  Nanjing Atlanta ssachusetts rseilles
</span><span style=color:#96b5b4;>echo </span><span>${</span><span style=color:#bf616a;>city[*]</span><span>##M*a}         </span><span style=color:#65737e;>#删除匹配M*a的最长字串  Nanjing Atlanta chusetts rseilles
</span><span style=color:#96b5b4;>echo
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Replcing Substring</span><span>"    </span><span style=color:#65737e;>#替换子串功能
</span><span style=color:#96b5b4;>echo </span><span>${</span><span style=color:#bf616a;>city[*]</span><span>/M*s/Year}     </span><span style=color:#65737e;>#替换第1次与M*a匹配的子串  Nanjing Atlanta Year Year
</span><span style=color:#96b5b4;>echo </span><span>${</span><span style=color:#bf616a;>city[*]</span><span>/</span><span style=color:#bf616a;>/</span><span>Mas/Year}    </span><span style=color:#65737e;>#替换所有与Mas匹配的子串   Nanjing Atlanta Yearsachusetts YeareillesYear
</span><span>                             </span><span style=color:#65737e;>#替换的正则为最长匹配
</span></code></pre><p>数组可以存放read命令所读入的用户输入参数，<code>declare -a city</code>（并不是必须的）将city申明为数组，用<code>read -a city</code>命令将输入存储到city数组之中，输入以空格分开。<ul><li><p><code>unset city[0]</code>命令清空一个元素</p><li><p><code>unset city</code>清空整个数组。</p><li><p><code>${#city[@]}</code>获取数组的长度。</p></ul><p>shell数组的一种重要操作：数组连接。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>city</span><span>=(Beijing Nanjing Shanghai)
</span><span style=color:#bf616a;>person</span><span>=(Cai [5]=Wu Tang)             </span><span style=color:#65737e;>#数组不连续地赋值
</span><span> 
</span><span style=color:#b48ead;>declare </span><span style=color:#bf616a;>-a combine                   </span><span style=color:#65737e;>#声明combine数组
</span><span style=color:#bf616a;>combine</span><span>=(${</span><span style=color:#bf616a;>city[@]</span><span>} ${</span><span style=color:#bf616a;>person[@]</span><span>})    </span><span style=color:#65737e;>#combine是数组city和person的连接，连接操作将不连续的元素按序存放到combine数组中
</span><span> 
</span><span style=color:#bf616a;>element_count</span><span>=$</span><span style=color:#a3be8c;>{</span><span>#</span><span style=color:#bf616a;>combine[@]</span><span style=color:#a3be8c;>}         </span><span style=color:#65737e;>#while循环输出combine数组
</span><span style=color:#bf616a;>index</span><span>=</span><span style=color:#a3be8c;>0
</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>index</span><span>" </span><span style=color:#bf616a;>-lt </span><span>"$</span><span style=color:#bf616a;>element_count</span><span>" </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>do
</span><span>   </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Element[</span><span>$</span><span style=color:#bf616a;>index</span><span style=color:#a3be8c;>]=</span><span>$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>combine[</span><span>$</span><span style=color:#bf616a;>index]</span><span style=color:#a3be8c;>}</span><span>"  </span><span style=color:#65737e;>#数组标号与值的对应关系
</span><span>   </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>index=</span><span>$</span><span style=color:#bf616a;>index</span><span style=color:#a3be8c;>+1</span><span>"
</span><span style=color:#b48ead;>done
</span><span style=color:#65737e;>###################
</span><span style=color:#96b5b4;>echo
</span><span style=color:#96b5b4;>unset</span><span> combine                                 </span><span style=color:#65737e;>#清空combine数组
</span><span style=color:#bf616a;>combine[</span><span style=color:#d08770;>0</span><span style=color:#bf616a;>]</span><span>=$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>city[@]</span><span style=color:#a3be8c;>}                         </span><span style=color:#65737e;>#将city数组赋给combine[0]的一个元素
</span><span style=color:#bf616a;>combine[</span><span style=color:#d08770;>1</span><span style=color:#bf616a;>]</span><span>=$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>person[@]</span><span style=color:#a3be8c;>}                       </span><span style=color:#65737e;>#将person数组赋给combine[1]的一个元素
</span><span style=color:#bf616a;>element_count</span><span>=$</span><span style=color:#a3be8c;>{</span><span>#</span><span style=color:#bf616a;>combine[@]</span><span style=color:#a3be8c;>}
</span><span style=color:#bf616a;>index</span><span>=</span><span style=color:#a3be8c;>0
</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>index</span><span>" </span><span style=color:#bf616a;>-lt </span><span>"$</span><span style=color:#bf616a;>element_count</span><span>" </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>do
</span><span>   </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Element[</span><span>$</span><span style=color:#bf616a;>index</span><span style=color:#a3be8c;>]=</span><span>$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>combine[</span><span>$</span><span style=color:#bf616a;>index]</span><span style=color:#a3be8c;>}</span><span>"
</span><span>   </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>index=</span><span>$</span><span style=color:#bf616a;>index</span><span style=color:#a3be8c;>+1</span><span>"
</span><span style=color:#b48ead;>done
</span><span style=color:#65737e;>###################
</span><span style=color:#96b5b4;>echo
</span><span style=color:#b48ead;>declare </span><span style=color:#bf616a;>-a subcombine</span><span>=$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>combine[</span><span style=color:#d08770;>1</span><span style=color:#bf616a;>]</span><span style=color:#a3be8c;>}          </span><span style=color:#65737e;>#声明数组时赋值
</span><span style=color:#bf616a;>element_count</span><span>=$</span><span style=color:#a3be8c;>{</span><span>#</span><span style=color:#bf616a;>subcombine[@]</span><span style=color:#a3be8c;>}
</span><span style=color:#bf616a;>index</span><span>=</span><span style=color:#a3be8c;>0
</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>index</span><span>" </span><span style=color:#bf616a;>-lt </span><span>"$</span><span style=color:#bf616a;>element_count</span><span>" </span><span style=color:#96b5b4;>]
</span><span style=color:#b48ead;>do
</span><span>   </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Element[</span><span>$</span><span style=color:#bf616a;>index</span><span style=color:#a3be8c;>]=</span><span>$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>subcombine[</span><span>$</span><span style=color:#bf616a;>index]</span><span style=color:#a3be8c;>}</span><span>"
</span><span>   </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>index=</span><span>$</span><span style=color:#bf616a;>index</span><span style=color:#a3be8c;>+1</span><span>"
</span><span style=color:#b48ead;>done
</span></code></pre><p>数组实现简单的数据结构<p>数据结构是指相互之间存在一种或多种特定关系的数据元素的集合，它直接影响到程序的运行速度和存储效率。Shell不直接支持如堆栈、队列、链表等数据结构，但可以很容易实现线性数据结构。对于树形、图等复杂的数据结构，shell理论上可以实现，但难度较大。<p>利用数组实现堆栈操作：push函数将字符串压入堆栈，pop函数能弹出栈顶元素，status函数打印当前堆栈的状态信息。<p>其中shift命令完成两个功能：<ol><li>所有位置参数左移1位，即$2移动到$1的位置，$3移动到$2的位置，依次类推（$0不变）<li><code>$#</code>变量值减1。</ol><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>MAXTOP</span><span>=</span><span style=color:#a3be8c;>50               </span><span style=color:#65737e;>#堆栈能存放元素的最大值
</span><span> 
</span><span style=color:#bf616a;>TOP</span><span>=$</span><span style=color:#bf616a;>MAXTOP             </span><span style=color:#65737e;>#栈顶指针，初始值是$MAXTOP
</span><span> 
</span><span style=color:#bf616a;>TEMP</span><span>=
</span><span style=color:#b48ead;>declare </span><span style=color:#bf616a;>-a STACK        </span><span style=color:#65737e;>#全局数组STACK
</span><span> 
</span><span style=color:#8fa1b3;>push</span><span>()                  </span><span style=color:#65737e;>#push进栈操作，可同时将多个元素压入堆栈
</span><span>{
</span><span>    </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span style=color:#bf616a;>-z </span><span>"$</span><span style=color:#bf616a;>1</span><span>" </span><span style=color:#96b5b4;>]      </span><span style=color:#65737e;>#无参数，返回
</span><span>    </span><span style=color:#b48ead;>then
</span><span>    	 </span><span style=color:#b48ead;>return
</span><span>    </span><span style=color:#b48ead;>fi
</span><span> 
</span><span>    </span><span style=color:#65737e;>#for ((i=1; i<=$#; i++))
</span><span>    </span><span style=color:#b48ead;>until </span><span style=color:#96b5b4;>[ </span><span>$</span><span style=color:#bf616a;># -eq</span><span> 0 </span><span style=color:#96b5b4;>]   </span><span style=color:#65737e;>#until循环将push函数的所有参数都压入堆栈
</span><span>    </span><span style=color:#b48ead;>do
</span><span>        </span><span style=color:#96b5b4;>let</span><span> TOP=TOP-</span><span style=color:#d08770;>1    </span><span style=color:#65737e;>#栈顶指针减1
</span><span> 
</span><span>        </span><span style=color:#bf616a;>STACK[</span><span>$</span><span style=color:#bf616a;>TOP]</span><span>=$</span><span style=color:#bf616a;>1
</span><span>        </span><span style=color:#96b5b4;>shift            </span><span style=color:#65737e;>#脚本参数除$0外左移1位，$#参数总个数减1
</span><span>    </span><span style=color:#b48ead;>done
</span><span> 
</span><span>    </span><span style=color:#b48ead;>return
</span><span>}
</span><span> 
</span><span style=color:#8fa1b3;>pop</span><span>()                     </span><span style=color:#65737e;>#pop出栈操作，执行pop函数使栈顶元素出栈
</span><span>{
</span><span>    </span><span style=color:#bf616a;>TEMP</span><span>=
</span><span> 
</span><span>    </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>TOP</span><span>" </span><span style=color:#bf616a;>-eq </span><span>"$</span><span style=color:#bf616a;>MAXTOP</span><span>" </span><span style=color:#96b5b4;>]   </span><span style=color:#65737e;>#若堆栈为空，返回
</span><span>    </span><span style=color:#b48ead;>then
</span><span>     </span><span style=color:#b48ead;>return
</span><span>    </span><span style=color:#b48ead;>fi
</span><span> 
</span><span>    </span><span style=color:#bf616a;>TEMP</span><span>=$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>STACK[</span><span>$</span><span style=color:#bf616a;>TOP]</span><span style=color:#a3be8c;>}           </span><span style=color:#65737e;>#栈顶元素出栈
</span><span>    </span><span style=color:#96b5b4;>unset</span><span> STACK</span><span style=color:#b48ead;>[</span><span>$</span><span style=color:#bf616a;>TOP</span><span style=color:#b48ead;>]         
</span><span>    </span><span style=color:#96b5b4;>let</span><span> TOP=TOP+</span><span style=color:#d08770;>1                 </span><span style=color:#65737e;>#栈顶指针加1
</span><span>    </span><span style=color:#b48ead;>return
</span><span>}
</span><span> 
</span><span style=color:#8fa1b3;>status</span><span>()                          </span><span style=color:#65737e;>#显示当前堆栈内的元素，以及TOP指针和TEMP变量
</span><span>{
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>==========STACK==========</span><span>"
</span><span>    </span><span style=color:#b48ead;>for</span><span> i </span><span style=color:#b48ead;>in </span><span>${</span><span style=color:#bf616a;>STACK[@]</span><span>}                                
</span><span>    </span><span style=color:#b48ead;>do
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>$</span><span style=color:#bf616a;>i
</span><span>    </span><span style=color:#b48ead;>done
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Stack Pointer=</span><span>$</span><span style=color:#bf616a;>TOP</span><span>"
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Just popped </span><span style=color:#96b5b4;>\"</span><span>"$</span><span style=color:#bf616a;>TEMP</span><span>"</span><span style=color:#96b5b4;>\"</span><span style=color:#a3be8c;> off the stack</span><span>"
</span><span>    </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>==========================</span><span>"
</span><span>}
</span><span> 
</span><span style=color:#bf616a;>push</span><span> one              </span><span style=color:#65737e;>#1个元素入栈
</span><span style=color:#bf616a;>status                </span><span style=color:#65737e;>#显示状态
</span><span style=color:#bf616a;>push</span><span> two three four   </span><span style=color:#65737e;>#3个元素入栈
</span><span style=color:#bf616a;>status
</span><span> 
</span><span style=color:#bf616a;>pop                   </span><span style=color:#65737e;>#出栈
</span><span style=color:#bf616a;>pop
</span><span style=color:#bf616a;>status
</span><span style=color:#bf616a;>push</span><span> five six
</span><span style=color:#bf616a;>status
</span></code></pre><p>利用一维数组模拟实现二维数组，二维数组仍存储在一维数组中，只是通过行号和列号计算出数组的索引而已。可以采用该方法使shell脚本语言用于定义二维数组和矩阵。<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#创建一个二维数组，并以逐行打印及旋转45度打印的两种方式将它打印出来
</span><span style=color:#65737e;>#!/bin/bash
</span><span>
</span><span style=color:#65737e;>#定义行数、列数，及数组名
</span><span style=color:#bf616a;>ROW</span><span>=</span><span style=color:#a3be8c;>5
</span><span style=color:#bf616a;>COL</span><span>=</span><span style=color:#a3be8c;>5
</span><span style=color:#b48ead;>declare </span><span style=color:#bf616a;>-a MATRIX      </span><span style=color:#65737e;>#申明MATRIX数组
</span><span>
</span><span style=color:#8fa1b3;>load_alpha </span><span>()
</span><span>{
</span><span>		</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>rc</span><span>=</span><span style=color:#a3be8c;>0
</span><span>		</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>index
</span><span>		
</span><span>		</span><span style=color:#65737e;>#for循环将A-Y这25个字符存储到MATRIX数组
</span><span>		</span><span style=color:#b48ead;>for</span><span> i </span><span style=color:#b48ead;>in</span><span> A B C D E F G H I J K L M N O P Q R S T U V W X Y
</span><span>		</span><span style=color:#b48ead;>do
</span><span>				</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>row</span><span>=`</span><span style=color:#bf616a;>expr </span><span>$</span><span style=color:#bf616a;>rc</span><span> / $</span><span style=color:#bf616a;>COL</span><span>`
</span><span>				</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>column</span><span>=`</span><span style=color:#bf616a;>expr </span><span>$</span><span style=color:#bf616a;>rc </span><span>% $</span><span style=color:#bf616a;>ROW</span><span>`
</span><span>				</span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>index = </span><span>$</span><span style=color:#bf616a;>row</span><span style=color:#a3be8c;> * </span><span>$</span><span style=color:#bf616a;>ROW</span><span style=color:#a3be8c;> + </span><span>$</span><span style=color:#bf616a;>column</span><span>"
</span><span>				</span><span style=color:#bf616a;>MATRIX[</span><span>$</span><span style=color:#bf616a;>index]</span><span>=$</span><span style=color:#bf616a;>i
</span><span>				</span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>rc += 1</span><span>"
</span><span>		</span><span style=color:#b48ead;>done  
</span><span>}
</span><span>  
</span><span style=color:#8fa1b3;>print_alpha </span><span>()
</span><span>{
</span><span>		</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>row</span><span>=</span><span style=color:#a3be8c;>0
</span><span>		</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>index
</span><span>		
</span><span>		</span><span style=color:#65737e;>#逐行打印MATRIX数组
</span><span>		</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>row</span><span>" </span><span style=color:#bf616a;>-lt </span><span>"$</span><span style=color:#bf616a;>ROW</span><span>" </span><span style=color:#96b5b4;>] 
</span><span>		</span><span style=color:#b48ead;>do                           
</span><span>				</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>column</span><span>=</span><span style=color:#a3be8c;>0
</span><span>				</span><span style=color:#96b5b4;>echo </span><span style=color:#bf616a;>-n </span><span>"       " 
</span><span>				</span><span style=color:#b48ead;>while </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>column</span><span>" </span><span style=color:#bf616a;>-lt </span><span>"$</span><span style=color:#bf616a;>COL</span><span>" </span><span style=color:#96b5b4;>]
</span><span>				</span><span style=color:#b48ead;>do
</span><span>						</span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>index = </span><span>$</span><span style=color:#bf616a;>row</span><span style=color:#a3be8c;> * </span><span>$</span><span style=color:#bf616a;>ROW</span><span style=color:#a3be8c;> + </span><span>$</span><span style=color:#bf616a;>column</span><span>"
</span><span>						</span><span style=color:#96b5b4;>echo </span><span style=color:#bf616a;>-n </span><span>"$</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>MATRIX[index]</span><span style=color:#a3be8c;>} </span><span>" 
</span><span>						</span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>column += 1</span><span>"
</span><span>				</span><span style=color:#b48ead;>done
</span><span>				</span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>row += 1</span><span>"
</span><span>				</span><span style=color:#96b5b4;>echo
</span><span>		</span><span style=color:#b48ead;>done
</span><span>	  </span><span style=color:#96b5b4;>echo
</span><span>}
</span><span>  
</span><span style=color:#8fa1b3;>filter </span><span>()     </span><span style=color:#65737e;># 过滤掉负的数组下标. 
</span><span>{
</span><span>		</span><span style=color:#96b5b4;>echo </span><span style=color:#bf616a;>-n </span><span>"  "  </span><span style=color:#65737e;># 产生倾斜. 
</span><span>		              </span><span style=color:#65737e;># 解释一下, 这是怎么做到的. 
</span><span>		
</span><span>		</span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[[ </span><span>"$</span><span style=color:#bf616a;>1</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 0 &&  "$</span><span style=color:#bf616a;>1</span><span>" </span><span style=color:#bf616a;>-lt </span><span>"$</span><span style=color:#bf616a;>ROW</span><span>" && "$</span><span style=color:#bf616a;>2</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 0 && "$</span><span style=color:#bf616a;>2</span><span>" </span><span style=color:#bf616a;>-lt </span><span>"$</span><span style=color:#bf616a;>COL</span><span>" </span><span style=color:#96b5b4;>]]
</span><span>		</span><span style=color:#b48ead;>then
</span><span>		    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>index = </span><span>$</span><span style=color:#bf616a;>1</span><span style=color:#a3be8c;> * </span><span>$</span><span style=color:#bf616a;>ROW</span><span style=color:#a3be8c;> + </span><span>$</span><span style=color:#bf616a;>2</span><span>"
</span><span>		    </span><span style=color:#65737e;># 现在, 按照旋转方向进行打印. 
</span><span>		    </span><span style=color:#96b5b4;>echo </span><span style=color:#bf616a;>-n </span><span>" $</span><span style=color:#a3be8c;>{</span><span style=color:#bf616a;>MATRIX[index]</span><span style=color:#a3be8c;>}</span><span>"
</span><span>		    </span><span style=color:#65737e;># alpha[$row][$column]
</span><span>		</span><span style=color:#b48ead;>fi    
</span><span>}
</span><span> 
</span><span style=color:#8fa1b3;>rotate </span><span>()  </span><span style=color:#65737e;># 将数组旋转45度 --
</span><span>{          </span><span style=color:#65737e;>#+ 从左下角进行"平衡". 
</span><span>		</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>row
</span><span>		</span><span style=color:#b48ead;>local </span><span style=color:#bf616a;>column
</span><span>		
</span><span>		</span><span style=color:#b48ead;>for </span><span>(( row = ROW; row > -ROW; row-- ))
</span><span>		  </span><span style=color:#b48ead;>do  
</span><span>		  </span><span style=color:#b48ead;>for </span><span>(( column = </span><span style=color:#d08770;>0</span><span>; column < COL; column++ ))
</span><span>		  </span><span style=color:#b48ead;>do
</span><span>				  </span><span style=color:#b48ead;>if </span><span style=color:#96b5b4;>[ </span><span>"$</span><span style=color:#bf616a;>row</span><span>" </span><span style=color:#bf616a;>-ge</span><span> 0 </span><span style=color:#96b5b4;>]
</span><span>				  </span><span style=color:#b48ead;>then
</span><span>				    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>t1 = </span><span>$</span><span style=color:#bf616a;>column</span><span style=color:#a3be8c;> - </span><span>$</span><span style=color:#bf616a;>row</span><span>"
</span><span>				    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>t2 = </span><span>$</span><span style=color:#bf616a;>column</span><span>"
</span><span>				  </span><span style=color:#b48ead;>else
</span><span>				    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>t1 = </span><span>$</span><span style=color:#bf616a;>column</span><span>"
</span><span>				    </span><span style=color:#96b5b4;>let </span><span>"</span><span style=color:#a3be8c;>t2 = </span><span>$</span><span style=color:#bf616a;>column</span><span style=color:#a3be8c;> + </span><span>$</span><span style=color:#bf616a;>row</span><span>"
</span><span>				  </span><span style=color:#b48ead;>fi  
</span><span>				  </span><span style=color:#bf616a;>filter </span><span>$</span><span style=color:#bf616a;>t1 </span><span>$</span><span style=color:#bf616a;>t2   </span><span style=color:#65737e;># 将负的数组下标过滤出来
</span><span>		 </span><span style=color:#b48ead;>done
</span><span>	 
</span><span>		</span><span style=color:#96b5b4;>echo</span><span>; </span><span style=color:#96b5b4;>echo
</span><span>		</span><span style=color:#b48ead;>done 
</span><span>}
</span><span> 
</span><span> </span><span style=color:#65737e;>#下面利用上述函数创建二维数组，逐行和旋转45°打印数组
</span><span> </span><span style=color:#bf616a;>load_alpha     </span><span style=color:#65737e;># 加载数组
</span><span> </span><span style=color:#bf616a;>print_alpha    </span><span style=color:#65737e;># 打印数组
</span><span> </span><span style=color:#bf616a;>rotate         </span><span style=color:#65737e;># 逆时针旋转45°打印
</span></code></pre><h3 id=1-7-fang-fa>1.7 方法</h3><p>方法的定义有两种方式<ul><li>function func1 { #这里定义方法体 }<li>func2() { #这里定义方法体 }</ul><p>方法返回值的处理有三种方式<ul><li>return 最大返回256，表示结果码，有特殊含义，并且只能返回数值<li>echo 返回<li>保存在全局变量中</ul><p>方法的参数<ul><li>参数的传递添加在方法之后，多个使用空格分割<li>参数的获取 <ul><li>使用<code>$1</code>、<code>$2</code>以此类推<li>特别地<code>$0</code>表示文件名<li><code>$#</code>表示参数的个数</ul></ul><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>echo "=======方法======="
</span><span>
</span><span>function func1 {
</span><span>	echo "func1 invoked"
</span><span>	# 最大的返回值为256，超过了256取模的结果，280%256=24,最终返回24
</span><span>	return 280;
</span><span>}
</span><span>
</span><span>func2() {
</span><span>	echo "return value"
</span><span>}
</span><span>
</span><span># 检测文件夹存在的方法，结果保存在全局变量`CheckInputDestDirRecursiveReturnValue`中
</span><span># 参数一：检测的文件夹路径
</span><span># 参数二：提示消息字符串
</span><span># 使用方式如下，去掉注释
</span><span># # 导入工具脚本
</span><span># . ./FileUtil.sh
</span><span># # 检测class_search_dir
</span><span># checkDirCore $class_search_dir "指定类的查找目录不存在"
</span><span># class_search_dir=${CheckInputDestDirRecursiveReturnValue}
</span><span>checkDirCore() {
</span><span>	to_process_dir=$1
</span><span>	message=$2
</span><span>	echo "scriptName=${0} paramsCount=${#}"
</span><span>	# 需处理源码目录检查
</span><span>	if [[ -d $to_process_dir ]]; then
</span><span>		echo "目录存在 $to_process_dir"
</span><span>		CheckInputDestDirRecursiveReturnValue=$to_process_dir
</span><span>		return 1
</span><span>	else
</span><span>		echo "${message} ${to_process_dir}"
</span><span>		checkInputDestDirRecursive ${to_process_dir}
</span><span>	fi
</span><span>}
</span><span>
</span><span>echo `func1`
</span><span>echo `func2`
</span><span>
</span><span>func1
</span><span>retValue=$?
</span><span>echo "func1 retValue=$retValue"
</span><span>
</span><span>retValue=`func2`
</span><span>echo "func2 retValue=$retValue"
</span><span>
</span><span>checkDirCore $(pwd) "指定类的查找目录不存在"
</span><span>dir=${CheckInputDestDirRecursiveReturnValue}
</span><span>echo "dir = ${dir}"
</span><span>
</span><span># 输出：
</span><span>=======方法=======
</span><span>func1 invoked
</span><span>return value
</span><span>func1 invoked
</span><span>func1 retValue=24
</span><span>func2 retValue=return value
</span><span>scriptName=./syntax.sh paramsCount=2
</span><span>目录存在 /Users/aron/git-repo/ShellLearning/helloshell
</span><span>dir = /Users/aron/git-repo/ShellLearning/helloshell
</span></code></pre><h3 id=1-8-bie-ming>1.8 别名</h3><p>linux定义别名基本格式为<code>alias name='original-command'</code>（等号两边不能有空格），如alias ipconfig=ifconfig。<p>删除已经设置的别名，使用内建命令<code>unalias</code>：<ul><li><code>unalias -a</code>表示删除所有已设置的别名<li><code>unalias alias-name</code>表示仅删除alias-name别名。</ul><p><strong>要在脚本中使用别名功能，必须在脚本使用<code>shopt -s expand_aliases</code>命令打开 expand_aliases（表示别名可以被扩展）选项，未打开，alias建立别名的命令不会执行。</strong><p><strong>在诸如if/then结构、循环和函数等混合型结构中不能使用alias命令设置别名，但可以执行在混合型结构之外所设置的别名。</strong><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#96b5b4;>shopt</span><span> -s expand_aliases   </span><span style=color:#65737e;>#打开expand_aliases选项
</span><span style=color:#96b5b4;>alias </span><span style=color:#8fa1b3;>detail</span><span>="</span><span style=color:#a3be8c;>ls -l</span><span>"
</span><span style=color:#bf616a;>detail</span><span> /root/in*          </span><span style=color:#65737e;>#别名支持通配符*
</span><span style=color:#96b5b4;>echo
</span><span style=color:#bf616a;>directory</span><span>=</span><span style=color:#a3be8c;>/root/
</span><span style=color:#bf616a;>prefix</span><span>=</span><span style=color:#a3be8c;>in</span><span>*
</span><span style=color:#96b5b4;>alias </span><span style=color:#8fa1b3;>vardetail</span><span>="</span><span style=color:#a3be8c;>ls -l </span><span>$</span><span style=color:#bf616a;>directory</span><span>$</span><span style=color:#bf616a;>prefix</span><span>"   </span><span style=color:#65737e;>#双引号和单引号在处理空格时是等价的，
</span><span>                                            </span><span style=color:#65737e;>#但设置vardetail引用了变量，此处只能使用双引号
</span><span style=color:#bf616a;>vardetail
</span><span> 
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Deleting all aliases:</span><span>"
</span><span style=color:#96b5b4;>unalias </span><span style=color:#bf616a;>-a                </span><span style=color:#65737e;>#删除所有的别名
</span><span style=color:#bf616a;>detail
</span><span style=color:#bf616a;>vardetail
</span></code></pre><h3 id=1-9-lie-biao>1.9 列表</h3><p>shell中列表是由一串命令用与运算（&&）和或运算（||）连接而成，分别称为与列表和或列表。<ul><li><p>与列表的格式为：命令1 && 命令2 && 命令3 &&... && 命令n，从左到右依次执行命名，直到某命令返回FALSE时（退出状态为非0）与列表执行终止。</p><li><p>或列表的格式为：命令1 || 命令2 || 命令3 ||... ||命令n，从左到右依次执行命名，但是当某命令返回TRUE时（退出状态为0）或列表执行终止。</p></ul><p>在使用与或列表嵌套时需要利用圆括号区分逻辑运算的优先级。<p><strong>与列表</strong>控制输入参数个数和返回状态码：<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>MAXARGS</span><span>=</span><span style=color:#a3be8c;>3
</span><span style=color:#bf616a;>ERROR</span><span>=</span><span style=color:#a3be8c;>68
</span><span style=color:#bf616a;>test </span><span>$</span><span style=color:#bf616a;># -ne </span><span>$</span><span style=color:#bf616a;>MAXARGS  </span><span>&& </span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Usage: `</span><span style=color:#bf616a;>basename </span><span>$</span><span style=color:#bf616a;>0</span><span style=color:#a3be8c;>` </span><span>$</span><span style=color:#bf616a;>MAXARGS</span><span style=color:#a3be8c;> arguments</span><span>" && </span><span style=color:#96b5b4;>exit </span><span>$</span><span style=color:#bf616a;>ERROR
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Less than </span><span>$</span><span style=color:#bf616a;>MAXARGS</span><span style=color:#a3be8c;> arguments are passed to this script.</span><span>"
</span><span style=color:#96b5b4;>exit</span><span> 0
</span></code></pre><p><strong>或列表</strong>控制输入参数个数和返回状态码<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#65737e;>#!/bin/bash
</span><span> 
</span><span style=color:#bf616a;>MAXARGS</span><span>=</span><span style=color:#a3be8c;>3
</span><span style=color:#bf616a;>ERROR</span><span>=</span><span style=color:#a3be8c;>68
</span><span style=color:#bf616a;>test </span><span>$</span><span style=color:#bf616a;># -eq </span><span>$</span><span style=color:#bf616a;>MAXARGS  </span><span>|| (</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Usage: `</span><span style=color:#bf616a;>basename </span><span>$</span><span style=color:#bf616a;>0</span><span style=color:#a3be8c;>` </span><span>$</span><span style=color:#bf616a;>MAXARGS</span><span style=color:#a3be8c;> arguments</span><span>" && </span><span style=color:#bf616a;>false</span><span>) || </span><span style=color:#96b5b4;>exit </span><span>$</span><span style=color:#bf616a;>ERROR
</span><span style=color:#96b5b4;>echo </span><span>"</span><span style=color:#a3be8c;>Correct arguments are passed to this script.</span><span>"
</span><span style=color:#96b5b4;>exit</span><span> 0
</span></code></pre><p><strong>由于echo命令总是返回TRUE，要将echo和false进行与运算从而返回FALSE值</strong><h3 id=1-10-zi-fu-chuan>1.10 字符串</h3><p>expr引出通用求值表达式，可以实现算术操作、比较操作、字符串操作和逻辑操作等功能。<p>字符串长度：<ul><li><code>expr length &string</code><li><code>${#string}</code><li>若string包括空格，<code>&string</code>需用双引号引起来（expr length后面只能跟一个参数，string有空格会当作多个参数处理）。</ul><p>子串匹配索引：<ul><li><code>expr index $string $substring</code><li>在字符串<code>$string</code>上匹配<code>$substring</code>中字符（即子串非有序）第一次出现的位置，匹配不到，expr index返回0。</ul><p>子串匹配的长度：<ul><li><code>expr match $string $substring</code><li>在string的开头匹配substring字符串，返回匹配到的substring字符串的长度，<strong>若string开头匹配不到则返回0</strong>，其中substring可以是字符串也可以是正则表达式。</ul><p>抽取子串：<ul><li>#{...} <ul><li><code>#{string:position}</code>从名称为<code>$string</code>的字符串的第<code>$position</code>个位置开始抽取子串，从0开始标号。<li><code>#{string:position:length}</code>增加<code>$length</code>变量，表示从<code>$string</code>字符串的第<code>$position</code>个位置开始抽取长度为<code>$length</code>的子串。<li>从string右边开始计数抽取子串 <ul><li><code>#{string: -position}</code>，冒号与横杠间有一个空格<li><code>#{string:(position)}</code></ul></ul><li>expr <ul><li><code>expr substr $string $position $length</code>：从1开始进行标号<li>使用正则表达式抽取子串的命令，但只能抽取string开头处或结尾处的子串 <ul><li>抽取字符串开头处的子串 <ul><li><code>expr match $string '$substring'</code><li><code>expr $string : '$substring'</code>，冒号前后都有一个空格。</ul><li>抽取字符串结尾处的子串 <ul><li><code>expr match $string '.*$substring'</code><li><code>expr $string : '.*$substring'</code><li><code>.*</code>表示任意字符的任意重复</ul></ul></ul></ul><p>删除子串：<p>删除字串是指将原字符串中符合条件的子串删除，命令只有${...}格式。substring并非是正则表达式而是通配符。<ul><li><p>从string开头处删除子串</p> <ul><li><code>${string#substring}</code>，删除开头处与substring匹配的最短子串。<li><code>${string##substring}</code>，删除开头处与substring匹配的最长子串。</ul><li><p>从string结尾处开始删除</p> <ul><li><code>${string%substring}</code>，删除结尾处与substring匹配的最短子串。<li><code>${string%%substring}</code>，删除结尾处与substring匹配的最长子串。</ul></ul><p>替换子串：<p>替换子串命令都是${...}，可以在任意处、开头处、结尾处替换满足条件的子串。其中的substring都不是正则表达式而是通配符。<ul><li>任意处替换 <ul><li><code>${string/substring/replacement}</code>，仅替换第一次与substring相匹配的子串。<li><code>${string//substring/replacement}</code>，替换所有与substring相匹配的子串。</ul><li>开头处替换：<code>${string/#substring/replacement}</code><li>结尾处替换：<code>${string/%substring/replacement}</code></ul><h3 id=1-11-i-ozhong-ding-xiang>1.11 I/O重定向</h3><p>I/O重定向用于捕获一个文件、命令、程序或脚本甚至代码块的输出，然后把捕获到的输出作为输入发送给另外一个文件、命令、程序或脚本等。<p>I/O重定向最常用的方法是管道（管道符"|"）。<h4 id=guan-dao>管道</h4><p>管道技术是Linux间的一种通信技术，利用先进先出排队模型来指挥进程间的通信（可当作连接两个实体的一个单向连接器）。Linux管道可用于应用程序之间、linux命令之间、应用程序与命令间的通讯。shell编程指利用管道进行Linux命令之间的通信。<p>管道通信的格式：<code>command1 | command2 | command3 |  ... |  commandn</code>，command1执行后如果没有管道则输出结果直接显示在shell上，当shell遇到管道符"|"后会将command1的输出发送到command2作为command2的输入。<p>例：ls -l | grep vi | wc -l，在三个命令之间建立两根管道，第一个命令ls -l的输出作为grep vi 的输入，第二个命令在管道输入下执行后的输出作为第三个命令wc -l的输入，第三个命令在管道输入下执行命令将结果输出到shell。<p>这是一个~~半双工通信~~，因通信是单向的，则两个命令之间的具体工作是由linux内核来完成的。<h4 id=i-ozhong-ding-xiang>I/O重定向</h4><p>I/O重定向是一个过程，这个过程捕捉一个文件、命令、程序或脚本，甚至代码块的输出，然后把捕捉到的输出作为输入发送给另外一个文件、命令、程序或脚本。<p>文件描述符是从0开始到9的结束的整数，指明了与进程相关的特定数据流的源。当Linux系统启动一个进程（该进程可能用于执行shell命令）时，将自动为该进程打开三个文件：标准输入（文件标识符为0）、标准输出（1标识）和标准错误输出（2标识），若要打开其他的输入或输出文件则从整数3开始标识。默认情况下，标准输入与键盘输入相关联，标准输出与标准错误输出与显示器相关联。<p>Shell从标准输入读取输入数据，将输出送到标准输出，如果该命令在执行过程中发生错误，则将错误信息输出到标准错误输出。<p>I/O重定向符号分为：基本I/O重定向符号和高级I/O重定向符号（与exec命令有关）。<p>基本I/O重定向符号和意义<table><thead><tr><th>序号 （举例）<th>符号<th>意义<tbody><tr><td>1<td>cmd1 md2<td>管道符，将cmd1的标准输出作为cmd2的标准输入<tr><td>2<td>> filename<td>将标准输出写到文件filename中<tr><td>3<td>< filename<td>将文件filename的内容读入到标准输出中去<tr><td>4<td>>> filename<td>将标准输出写到文件filename中，若filename存在则把内容追加到filename那么后面，<tr><td>5<td>>| filename<td>即使noclobber选项开启，仍然强制将标准输出写到filename中，即把filename内容覆盖掉<tr><td>6<td>n>|filename<td>即使noclobber选项开启，仍然强制将FD为n的输出写到filename中，即把filename内容覆盖掉<tr><td>7<td>n> filename<td>将FD为n的输出写到filename文件中<tr><td>8<td>n< filename<td>将文件filename中内容读入到FD n中<tr><td>9<td>n>> filename<td>将FD为n的输出文件写到filename中，，若filename存在则把内容追加到filename那么后面，<tr><td>10<td><< delimiter<td>此处文档（Here——document）</table><p>高级I/O重定向符号和意义<table><thead><tr><th>符号<th>意义<tbody><tr><td>n>&m<td>将FD为m的输出复制到FD为n的文件中<tr><td>n<&m<td>将FD为m的输入复制到FD为n的文件中<tr><td>n>&-<td>关闭FD为n的输出<tr><td>n<&-<td>关闭FD为n的输入<tr><td>&>file<td>将标准输入和标准错误输出到重定向到文件</table><h4 id=execming-ling>exec命令</h4><p>exec命令可以通过文件描述符打开或关闭文件，也可将文件重定向到标准输入及将标准输出重定向到文件。<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#使用exec将stdin重定向到文件
</span><span>#!/bin/bash         
</span><span> 
</span><span>exec 8<&0           #FD 8是FD 0的副本，用于恢复标准输入
</span><span>exec < file         #将标准输入重定向到file       
</span><span>read a              #读取file的第一行
</span><span>read b              #读取file的第二行
</span><span> 
</span><span>echo "----------------"
</span><span>echo $a             #标准输出
</span><span>echo $b             #标准输出
</span><span> 
</span><span>echo "close FD 8:"
</span><span>#exec 0<&8 8<&-     #将FD 8复制到FD 0，恢复FD 0，并关闭FD 8，其他进程可以重复使用FD 8
</span><span>echo -n "Enter Data:"
</span><span>read c              #read从标准输入读取数据
</span><span>echo $c
</span></code></pre><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#exec将标准输出从定向到文件
</span><span>#!/bin/bash
</span><span>exec 8>&1                 #FD 8是FD 1的副本，用于恢复FD 1
</span><span>exec > log                #将标准输出重定向到log，>符号等价于1>符号
</span><span>echo "Output of date command："
</span><span>date                      #date和df命令
</span><span>echo "Output of df command："
</span><span>df
</span><span> 
</span><span>exec 1>&8 8>&-            #FD 8复制到FD 0，FD 0恢复为标准输出，并关闭FD 8   
</span><span>echo "--------------------------------"
</span><span>cat log                   #查看log文件           
</span></code></pre><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span># &>file将stdout和stderr重定向到文件
</span><span>#!/bin/bash
</span><span>exec 8>&1 9>&2      #FD 1复制到FD 8，FD 2复制到FD 9
</span><span>exec &> log         #&>符号将stdout和stderr重定向到文件log
</span><span> 
</span><span>ls z*               #错误写入文件log
</span><span>date                #输出写入文件log
</span><span>exec 1>&8 2>&9 8<&- 9<&-      #恢复关闭操作
</span><span>echo "-----------------"
</span><span>echo "Close FD 8 and 9:"
</span><span>ls z*
</span><span>date
</span></code></pre><h4 id=dai-ma-kuai-zhong-ding-xiang>代码块重定向</h4><p>代码块重定向是指在代码块内将标准输入或标准输出重定向到文件，而在代码块之外还是保留默认状态。可以重定向的代码块可以是while、until、for等循环结构、可以是if/then测试结构、还可以是函数。代码块输入重定向符号是<，输出重定向符号是>。<p>while循环的重定向：<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#while循环的重定向
</span><span>#!/bin/bash
</span><span> 
</span><span>ls /etc > log                    #将ls /etc的结果写到log文件中
</span><span> 
</span><span>while [ "$filename" != "rc.d" ]  #搜索log文件中第一次与rc.d匹配的行，并输出行数
</span><span>do                               #不匹配时，执行while循环体
</span><span>  read filename                  
</span><span>  let "count +=1"
</span><span>done < log                       #将while代码块的标准输入重定向到log文件
</span><span> 
</span><span>echo "$count times read"         #测试循环体外的标准输入是否被重定向
</span><span>echo -n "-----Input Data:-----"
</span><span>read test                        #最终是从标准输入获取数据
</span><span>echo $test
</span></code></pre><p>for循环的重定向：<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#for循环的重定向
</span><span>#!/bin/bash
</span><span> 
</span><span>ls /etc > log                  #将ls /etc的结果写到log文件中
</span><span> 
</span><span>maxline=$(wc -l < log)         #计算log文件的最大行数，赋给maxline          
</span><span> 
</span><span> 
</span><span>for filename in `seq $maxline` #seq命令产生循环参数，相当于for filename in 1,2,...,maxline
</span><span>do
</span><span> read filename                 #按行读取log文件数据
</span><span> 
</span><span> if [ "$filename" = "rc.d" ]   #if指定跳出循环的条件
</span><span> then
</span><span>   break
</span><span> else
</span><span>   let "count +=1"             #不匹配，计数器count加1
</span><span> fi
</span><span>done < log                     #for代码块中将标准输入重定向到log文件
</span><span> 
</span><span>echo "$count：times read"
</span><span> 
</span><span>echo -n "-----Input Data:-----" #测试for外标准输入是否被重定向
</span><span>read test
</span><span>echo $test
</span></code></pre><p>if/then结构的重定向，命令格式是（重定向符号要放在fi关键字后面）：<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#if/then结构的输出重定向
</span><span>#!/bin/bash
</span><span>if [ -z "$1" ]                          #如果位置参数$1为空
</span><span>then
</span><span> echo "Positional Parameter is NULL"    #将该语句重定向输入到log文件
</span><span>fi > log                                #if/then代码块输出重定向到log文件
</span><span> 
</span><span>echo "------Normal Stdout --------"     #代码块外的标准输出是否被重定向
</span></code></pre><p>代码块重定向在一定程度上增强了shell脚本处理文本文件的灵活性，它可以让一段代码很方便地处理一个文件（只要该文件输入重定向到该代码块）<h3 id=1-12-han-shu>1.12 函数</h3><p>Linux Shell编程中也会使用到函数，函数可以把大的命令集合分解成若干较小的任务，也避免重复编写相同的代码。在Shell中，所有的函数定义都是平行的，即不允许在函数体内再定义其他的函数，但允许函数之间相互调用。函数又涉及到很多基本使用：函数参数调用、函数返回值、局部变量及全局变量、函数间的相互调用和函数递归调用。<h4 id=ding-yi>定义</h4><p>函数是一串命令的集合，如果脚本中有重复代码时可以考虑使用函数。<p>函数定义要求：<ul><li><p>shell中函数的返回值只能是8位整形，范围为0~255</p><li><p>函数名在脚本中的唯一，可以在函数名前加上fuction关键字也可省略</p><li><p>函数体中的命令集合必须含有至少一条命令（函数不允许空命令，与C不同）</p><li><p>shell中不需要申明就可直接定义函数，但在调用函数前需对它进行定义。</p></ul><p>shell脚本中循环调用函数的例子：<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#function2.sh
</span><span>#!/bin/bash
</span><span> 
</span><span>output()
</span><span>{
</span><span>     for(( num1 = 1; num1 <= 5; num1++ ))
</span><span>     do
</span><span>         echo -n "$num1 "
</span><span>     done 
</span><span>}
</span><span> 
</span><span>let "num2=1"
</span><span>while [ "$num2" -le 5 ]
</span><span>do
</span><span>    output
</span><span>    echo ""
</span><span>    let "num2=num2 + 1"
</span><span>done
</span></code></pre><p>判断当前目录下存在多少个文件和子目录：<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#显示当前目录下文件和目录数
</span><span>#function3.sh
</span><span>#!/bin/bash
</span><span> 
</span><span>directory()
</span><span>{
</span><span>    let "filenum = 0"
</span><span>    let "dirnum = 0"
</span><span>    
</span><span>    ls
</span><span>    echo ""                 #echo换行
</span><span>    
</span><span>    for file in $( ls )     #for循环判断当前子目录和文件
</span><span>    do
</span><span>        if [ -d $file ]     #判断为子目录
</span><span>        then
</span><span>            let "dirnum = dirnum + 1"
</span><span>        else                #判断为文件
</span><span>           let "filenum = filenum + 1"
</span><span>        fi
</span><span>    done
</span><span> 
</span><span>    echo "The number of directory is $dirnum"
</span><span>    echo "The number of file is $filenum"
</span><span>}
</span><span> 
</span><span>directory                  #在脚本中调用函数
</span></code></pre><h4 id=can-shu>参数</h4><p>shell中，向函数传递的参数仍然是以<strong>位置参数</strong>的方式来传递的，而不能传递数组等其他形式变量（与c不同）。<p>利用函数参数的传递实现两数的四则运算：<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#用于实现两数加、减、乘和除四则运算
</span><span>#!/bin/bash
</span><span> 
</span><span>count()
</span><span>{
</span><span>    if [ $# -ne 3 ]             #3个参数，一个运算符两个数值
</span><span>    then 
</span><span>        echo "The  number of arguments is not 3! "
</span><span>    fi
</span><span>    
</span><span>    let "s = 0"
</span><span>    case $2 in
</span><span>    +)                          #加法
</span><span>        let "s = $1 + $3"
</span><span>        echo "$1 + $3 = $s";;
</span><span>    -)                          #减法
</span><span>        let "s = $1 - $3"
</span><span>        echo "$1 - $3 = $s";;
</span><span>    \*)                         #乘法
</span><span>       let "s = $1 * $3"
</span><span>       echo "$1 * $3 = $s";;
</span><span>     \/)                        #除法-取余,浮点数运算使用bc
</span><span>        let "s = $1 / $3"
</span><span>        echo "$1 / $3 = $s";;
</span><span>    *)                          #其他
</span><span>        echo "What you input is wrong!";;
</span><span>    esac
</span><span>}
</span><span> 
</span><span>echo "Please type your word: ( e.g. 1 + 1 )"
</span><span>read a b c 
</span><span>count $a $b $c
</span></code></pre><h4 id=fan-hui-zhi>返回值</h4><p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码，生成退出状态码有以下3种不同的方法：<ul><li><p><strong>默认退出状态码：<strong>默认情况下，函数的退出状态码是</strong>函数中最后一条命令返回的退出状态码</strong>。在函数执行结束后，可以用标准变量<code>$?</code>来确定函数的退出状态码。 <strong>注意</strong>：由于函数的默认退出状态码取决于函数体中最后一条命令的退出状态码，因此你无法知道函数中其他命令中是否成功运行，所以这种方法很危险。</p><li><p>**使用<code>return</code>命令：**使用<code>return</code>命令来退出函数并返回特定的退出状态码，它允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。 <strong>注意</strong>：①函数一结束就取返回值，否则可能会丢失返回值。②退出状态码的范围是0~255，超出则会取余。</p><li><p>使用函数输出：</p> <p>正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中。</p></ul><p>有时需要函数执行完成后返回特定的值来完成脚本的后续操作。函数通过return返回退出状态，0表示true无错误，非0表示false有错误（与C不同）。<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#根据用户输入显示星期
</span><span>#!/bin/bash
</span><span> 
</span><span>show_week()
</span><span>{
</span><span>     echo -n "What you input is: "
</span><span>     echo "$1"
</span><span> 
</span><span>    case $1 in 
</span><span>    0)
</span><span>        echo "Today is Sunday. "
</span><span>        return 0;;
</span><span>    1)
</span><span>        echo "Today is Monday. "
</span><span>        return 0;;
</span><span>    2)
</span><span>        echo "Today is Tuesday. "
</span><span>        return 0;;
</span><span>    3)
</span><span>        echo "Today is Wednesday. "
</span><span>        return 0;;
</span><span>    4)
</span><span>        echo "Today is Thursday. "
</span><span>        return 0;;
</span><span>    5)
</span><span>        echo "Today is Friday. "
</span><span>        return 0;;
</span><span>    6)
</span><span>        echo "Today is Saturday. "
</span><span>        return 0;;
</span><span>    *)
</span><span>        return 1;;
</span><span>    esac
</span><span>}
</span><span> 
</span><span>#if show_week "$1"          #返回0表示函数输入的命令行参数是正确的
</span><span>#也可以通过$?来获取函数执行的返回值
</span><span>show_week "$1"
</span><span>if [ $? -eq 0 ]
</span><span>then
</span><span>    echo "What you input is right! "
</span><span>else 
</span><span>    echo "What you input is wrong! "
</span><span>fi
</span><span>exit 0
</span></code></pre><h4 id=diao-yong>调用</h4><p>shell脚本中可以同时放置多个函数，函数之间允许相互调用，而且允许一个函数调用多个函数。<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#用于显示一个不多于5位的正整数的位数，并按顺序显示各个数位的值
</span><span>#!/bin/bash
</span><span> 
</span><span>count_of_int()
</span><span>{
</span><span>    if [ $1 -gt 9999 ]
</span><span>    then
</span><span>        let "place=5"         #5位数
</span><span>    elif [ $1 -gt 999 ]
</span><span>    then
</span><span>        let "place=4"
</span><span>    elif [ $1 -gt 99 ]
</span><span>    then
</span><span>        let "place=3"
</span><span>    elif [ $1 -gt 9 ]
</span><span>    then
</span><span>       let "place=2"
</span><span>    else
</span><span>        let "place=1"         #1位数
</span><span>    fi
</span><span>    
</span><span>    echo "The place of the $1 is $place."      #整数的位数
</span><span>} 
</span><span> 
</span><span>num_of_int()
</span><span>{
</span><span>    let "ten_thousand = $1/10000"           #整数的数位分解值    
</span><span>    let "thousand =$1/1000%10"
</span><span>    let "hundred = $1/100%10"
</span><span>    let "ten = $1%100/10"
</span><span>    let "indiv = $1%10"
</span><span> 
</span><span>    if [ $ten_thousand -ne 0 ]
</span><span>    then
</span><span>       echo "$ten_thousand  $thousand  $hundred  $ten  $indiv"
</span><span>    elif [ $thousand -ne 0 ]
</span><span>    then
</span><span>        echo "$thousand  $hundred  $ten  $indiv"
</span><span>    elif [ $hundred -ne 0 ]
</span><span>    then
</span><span>        echo "$hundred  $ten  $indiv"
</span><span>    elif [ $ten -ne 0 ]
</span><span>    then
</span><span>       echo "$ten  $indiv"
</span><span>    else
</span><span>       echo "$indiv"
</span><span>    fi
</span><span>}
</span><span> 
</span><span>show()
</span><span>{
</span><span>    echo "Please input the number(1-99999): "
</span><span>    read num
</span><span>   
</span><span>    count_of_int $num
</span><span>    num_of_int $num
</span><span>}
</span><span> 
</span><span>show
</span></code></pre><h4 id=di-gui>递归</h4><p>shell中执行递归函数可以直接或间接地反复调用其自身，每调用一层就进入新的一层，主调函数又是被调函数。<p>使用局部变量进行递归实现阶乘运算，也可采用递推法实现。<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#阶乘运算,当n=0时 0!=1，当n>=1时n!=n*(n-1)!
</span><span>#!/bin/bash
</span><span> 
</span><span>fact ()
</span><span>{
</span><span>    local num=$1         #函数需将先前的局部值进行逐个还原，故设置成局部的变量
</span><span>    echo $num
</span><span>    
</span><span>    if [ "$num" -eq 0 ]
</span><span>    then
</span><span>        factorial=1
</span><span>    else
</span><span>        let "decnum=num-1"
</span><span> 
</span><span>        fact $decnum
</span><span> 
</span><span>        let "factorial=$num * $?"
</span><span>    fi
</span><span>    return $factorial
</span><span>}
</span><span> 
</span><span>fact $1
</span><span>echo "Factorial of $1 is $?"
</span><span> 
</span><span>exit 0
</span></code></pre><p>递归实现汉诺塔的问题（不使用局部变量的递归）<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#汉诺塔算法
</span><span>#!/bin/bash
</span><span> 
</span><span>move=0
</span><span> 
</span><span>dohanoi() 
</span><span>{
</span><span>    if [ $1 -eq 0 ]
</span><span>    then
</span><span>       echo "" 
</span><span>    else
</span><span>        dohanoi "$(($1-1))" $2 $4 $3
</span><span>        echo "move $2 ----> $3"
</span><span>        
</span><span>        let "move=move+1"
</span><span> 
</span><span>        dohanoi "$(($1-1))" $4 $3 $2
</span><span>    fi
</span><span>    
</span><span>    if [ $# -eq 1 ]
</span><span>    then
</span><span>        if [ "$(( $1 > 1 ))" -eq 1 ]
</span><span>        then
</span><span>            dohanoi $1 A C B
</span><span>            echo "Total moves  = $move"
</span><span>        else
</span><span>           echo "The number of disk which you input is illegal! "
</span><span>         fi
</span><span>    fi
</span><span>}
</span><span> 
</span><span>echo "Please input the num of disk:"
</span><span>read num
</span><span>dohanoi $num 'A' 'B' 'C'
</span></code></pre><h4 id=bian-liang-zuo-yong-yu>变量作用域</h4><p>shell中，可以通过local关键字来申明局部变量，局部变量将局限在函数范围内。<p>函数可调用函数外的全局变量，若一个局部变量和一个全局变量的名字相同，则在函数中局部变量会覆盖掉全局变量。<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#!/bin/bash
</span><span> 
</span><span>text="global variable"
</span><span> 
</span><span>use_local_var_fun()
</span><span>{
</span><span>    local text="local variable"          #local声明为局部变量，否则会修改全局text的值
</span><span>    echo "in function------"$text        #暂时覆盖掉全局变量的值
</span><span>}
</span><span> 
</span><span>use_local_var_fun
</span><span> 
</span><span>echo "Out of function------"$text        #text的值为开始定义的值
</span><span>exit 0
</span></code></pre><h2 id=2-wen-jian>2. 文件</h2><h3 id=2-1-wen-jian-du-qu>2.1 文件读取</h3><p>文件的读取可以使用<code>cat</code>命令结合<code>for in</code>循环处理<blockquote><p>注意：<code>$IFS</code>是文件循环处理的分隔符，按按行处理数据需要把该值设置为<code>$'\n'</code>，处理完成之后恢复旧值</blockquote><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>echo "=======文件======="
</span><span>file="data"
</span><span>IFS_OLD=$IFS
</span><span>IFS=$'\n'
</span><span>for line in $(cat $file)
</span><span>do
</span><span>	echo "${line}"
</span><span>done
</span><span>IFS=${IFS_OLD}
</span><span>
</span><span>输出：
</span><span>=======文件=======
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown fox jumps over the lazy dog.
</span></code></pre><h3 id=2-2-mu-lu-de-du-qu>2.2 目录的读取</h3><p>文件的读取可以使用<code>ls</code>命令结合<code>for in</code>循环处理<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>echo "=======文件目录======="
</span><span>function read_implement_file_recursively {
</span><span>	if [[ -d $1 ]]; then
</span><span>		for item in $(ls $1); do
</span><span>			itemPath="$1/${item}"
</span><span>			if [[ -d $itemPath ]]; then
</span><span>				# 目录
</span><span>				echo "处理目录 ${itemPath}"
</span><span>				read_implement_file_recursively $itemPath
</span><span>			else 
</span><span>				# 文件
</span><span>				echo "处理文件 ${itemPath}"
</span><span>			fi
</span><span>		done
</span><span>	else
</span><span>		echo "err:不是一个目录"
</span><span>	fi
</span><span>}
</span><span>
</span><span>read_implement_file_recursively $(pwd)
</span><span>
</span><span>输出：
</span><span>=======文件目录=======
</span><span>处理文件 /Users/aron/git-repo/ShellLearning/helloshell/data
</span><span>处理目录 /Users/aron/git-repo/ShellLearning/helloshell/subfolder
</span><span>处理文件 /Users/aron/git-repo/ShellLearning/helloshell/subfolder/data2
</span><span>处理文件 /Users/aron/git-repo/ShellLearning/helloshell/syntax.sh
</span></code></pre><h3 id=2-3-wen-jian-xie-ru>2.3 文件写入</h3><p>使用输出重定向把内容输出到文件<ul><li><code>></code>输出重定向符号先清空文件然后把内容写入到文件中<li><code>>></code>输出重定向符号把内容追加写入到文件中</ul><p>此外可以结合其他命令实现排序、去重功能<ul><li><code>sort</code>命令对文件内容以行作为单位排序<li><code>uniq</code>命令对文件内容进行去重，以行为单位，一般需要结合<code>sort</code>命令使用</ul><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>file="subfolder/data2"
</span><span>destfile="subfolder/data2-p"
</span><span>sort ${file} | uniq > ${destfile}
</span><span>
</span><span>结果：
</span><span>➜  helloshell git:(master) ✗ cat subfolder/data2
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>The quick brown
</span><span>fox
</span><span>jumps over the lazy dog.%                                                                                          
</span><span>➜  helloshell git:(master) ✗ cat subfolder/data2-p 
</span><span>The quick brown
</span><span>The quick brown fox jumps over the lazy dog.
</span><span>fox
</span><span>jumps over the lazy dog.
</span></code></pre><h3 id=2-4-dui-wen-jian-de-pai-xu-he-bing-he-fen-ge>2.4 对文件的排序、合并和分割</h3><p>文本处理命令包括sort命令、uniq命令、join命令、cut命令、paste命令、split命令、tr命令和tar命令，它们实现对文件记录排序、统计、合并、提取、粘贴、分割、过滤、压缩和解压缩等功能，它们与sed和awk构成了linux文本处理的所有命令和工具。<h4 id=sortming-ling>sort命令</h4><p>sort命令是一种对文本排序的工具，它将输入文件看做由多条记录组成的数据流，而记录由可变宽度的字段组成，以换行符作为定界符。<p>sort命令格式：<code>sort [选项] [输入文件]</code><p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20140910181702875><p>sort命令默认的域分隔符是空格符，-t选项可用于设置分隔符。<code>sort -t:指定的分隔符</code> test中-t与":"之间是没有空格的。<p>未指定-t分隔符是空格符，这时记录内开头与结尾的空格都将被忽略，如（空格）:root:（空格）则只有一个域，-t:指定冒号则这条记录就包含了三个域。<p>sort命令默认是按第1个域进行排序的，也可以通过-k选项指定某个域进行排序。例如：sort -t: -k3 test。<p>sort命令-n选项可以指定根据数字大小进行排序（不按字母顺序排序）。<p>sort命令-r选项用于将排序结果逆向显示，如使用-n按数字从小到大排序后，使用-r选项将结果逆向显示。<p>sort命令-u选项去掉排序结果中的重复行。<p>sort命令-o选项加上文件名将结果保存到另一个文件中（sort默认将排序后的结果输出到屏幕上）。<p>sort命令-m选项将两个排好序的文件合并成一个排好序的文件，在文件合并前它们必须已经排好序。-m选项对未排序的文件合并是没有任何意义的。<p>sort和awk都是分域处理文件的工具，两者结合起来可以有效地对文本块进行排序。<h4 id=uniqming-ling>uniq命令</h4><p>uniq命令用于去除文本文件中的重复行，类似sort -u，但uniq命令去除的重复行必须是连续重复出现的行，中间不能夹杂任何其他文本行，而sort -u命令使所有的重复记录都被去掉。<p>uniq命令有3个选项：<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20140910193114758><h4 id=joinming-ling>join命令</h4><p>join命令用于实现两个文件中记录的连接操作，将两个文件中具有相通域的记录选择出来，再将这些记录所有的域放在一行（包含来自两个文件的所有域）。如join -t: a.txt b.txt，将a.txt和b.txt具有共同域的记录连接到一起。<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20140910194940941><p>join命令的结果默认是不显示这些未进行连接的记录，-a和-v选项用于显示这些未进行连接的记录，-a1和-v1指显示文件1中未连接的记录，而-a2和-v2指显示文件2中的未连接记录。<p>-a与-v的区别是：-a显示以共同域进行连接的结果和未进行连接的记录，而-v则不显示以共同域进行连接的记录。<p>join命令默认显示连接记录在两个文件中的所有域，而且按顺序。-o选项用于改变结果显示的格式，可以指定显示哪几个域、按什么顺序显示这些域。<p>例如：<ul><li><p><code>join -t: -o1.1 2.2 1.2 a.txt b.txt</code>，其中<code>-o1.1 2.2 1.2</code>表示显示格式依次显示第1个文件中的第1个域、第2个文件中的第2个域、第1个文件中的第2个域，结果显示三个域。</p><li><p><code>join -t: -i -1 3 -2 1 a.txt b.txt</code>，文件1的第3个域和文件2的第1个域进行连接，-i忽略大小写。join命令在对两个文件进行连接时，两个文件必须都是按照连接域排好序的。</p></ul><h4 id=cutming-ling>cut命令</h4><p>cut命令用于从标准输入或文本文件中按域或行提取文本，<code>cut [选项] 文件</code>，cut的选项如下：<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20140910200705187><p>cut -c1-5 a.txt，提取a.txt的第1～5个字符。-c有三种表示方式：-cn表示第n个字符、-cn,m表示第n个字符和第m个字符、-cn-m表示第n个字符到第m个字符。-c是按字符提取文本的，无须使用-d改变域分隔符，-f按域提取文本时就需要使用-d设置域分隔符了。-f同样也可以用三种方式指定域数或域范围。<p>cut可以灵活提取文本文件中的内容，默认将提取内容放在标准输出上，也可以使用文件重定向来将内容保存到文件。<h4 id=pasteming-ling>paste命令</h4><p>paste命令用于将文本文件或标准输出中的内容粘贴到新的文件，它可以将来自不同文件的数据粘贴到一起，形成新的文件。paste命令格式：<code>paste [选项] file1 file2</code>，其选项如下：<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20140910202107249><p>paste FILE1 FILE2，粘贴FILE1和FILE2，FILE1在前，将FILE1的内容作为每行记录的第1域、FILE2的内容作为第2域。可以使用-d设置域分隔符paste -d: FILE1 FILE2。<p>paste命令默认是将一个文件按列粘贴的，-s选项可以实现将一个文件按行粘贴。<p>ls | paste -d" " - - - -，从标准输入中读取数据时"-"选项才起作用，"-"表示读取1次标准输入数据即读取到标准输入数据中的一个域，- - - - 每行显示4个文件名。<h4 id=splitming-ling>split命令</h4><p>split命令用于将大文件切割成小文件，split可以按照文件的行数、字节数切割文件，并能在输出的多个小文件中自动加上编号。split命令格式：<code>splite [选项] 待切割的大文件 输出的小文件</code>。<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20140910204135159><p>split -2 a.txt final.txt，按2行对a.txt进行切割，每2行记录切割成1个文件。split命令在final.txt后面自动加上编号以区分不同的小文件，编号为aa~zz。<p>split -b100 a.txt，-b选项在切割文件时仅考虑了文件大小并未考虑记录的完整性。<p>split -C100 a.txt，按100B切割a.txt，按-C并不严格按照100B的大小进行切割，而是在切割时尽量维持每行的完整性。<h4 id=trming-ling>tr命令</h4><p>tr命令实现字符转换功能，类似于sed命令，tr能实现的功能sed命令都可以实现。<code>tr [选项] buffer1 buffer2 < outputfile</code>，其选项有三个，它只能从标准输入读取数据。<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20140910205313734><p>tr -d A-Z < a.txt，删除a.txt文件中所有的大写字母。<p>tr -d "[\n]" < a.txt，删除a.txt文件中所有的换行符。<p>tr -s "[\n]" < a.txt，将重复出现的换行符压缩成一个换行符。<p>tr命令也可以加上buffer1和buffer2，将buffer1用buffer2来替换，tr "[a-z]" "[A-Z]" < a.txt，将a.txt中的小写字母替换成大写字母。<h4 id=tarming-ling>tar命令</h4><p>tar命令是linux的归档命令，实现linux系统文件的打包和解包。<code>tar [选项] 文件名或目录名</code>，tar的常用选项如下：<p><img alt=img src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20140910211505250><p>tar -cf a.tar *.txt，将所有的.txt结尾的文件放入压缩包a.tar。-c表示创建新的包，-f通常是必选选项。<p>tar -tf a.tar，查看a.tar压缩包的内容。-t列出包内容。<p>tar -rf a.tar log*，将以log开头的文件添加到a.tar中，-u选项也可用于为包添加新的文件，-u选项完全能代替-r选项。<p>解压非gzip格式的压缩包：tar -xvf 压缩包名称<p>解压gzip格式的压缩包：tar -zxvf 压缩包名称<h2 id=3-sedliu-bian-ji>3. sed流编辑</h2><p>Sed流编辑结合正则表达式可以方便的对文本文件进行查询、修改、删除、增加等操作<p>注意：osx系统自带的sed命令和标准的gnu-sed使用方式上有些差别，所以以下篇幅所谈论到的sed都是标准的gnu-sed，下面的这个脚本用于判断系统是否安装了gnu-sed，如果没有会自动进行安装，完成之后需要用户执行显示的命令配置下即可。<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span># 检测是否安装gnu sed，mac 内置的sed会有些问题，所以需要安装gnu sed
</span><span>gnuSedInstallCheck() {
</span><span>	# 检查是否安装gnused
</span><span>	# mac安装gnuSed  http://blog.csdn.net/sun_wangdong/article/details/71078083
</span><span>	which_sed=`which sed`
</span><span>	echo $which_sed
</span><span>	echo "testresult = $(expr "$which_sed" : '.*/gnu-sed/')"
</span><span>	which_sed=`ls -al ${which_sed}`
</span><span>	echo $which_sed
</span><span>	echo "testresult = $(expr "$which_sed" : '.*/gnu-sed/')"
</span><span>	if [[ $(expr "$which_sed" : '.*/gnu-sed/') -gt 0 ]]; then
</span><span>		echo "检测到使用gnu sed"
</span><span>	else
</span><span>		if [ ! `which brew` ]
</span><span>		then
</span><span>			echo 'Homebrew not found. Trying to install...'
</span><span>	                    ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" \
</span><span>				|| exit 1
</span><span>		fi
</span><span>		echo 'Trying to install gnu sed...'
</span><span>		brew install gnu-sed --with-default-names || exit 1
</span><span>		# 设置局部环境变量
</span><span>		echo "set PATH...."
</span><span>		source ./set-gnu-sed-path.sh
</span><span>		echo "set PATH done"
</span><span>
</span><span>		echo "请手动执行命令,然后重新执行"
</span><span>		command="PATH=\"/usr/local/Cellar/gnu-sed/4.4/bin:\$PATH\""
</span><span>		echo $command
</span><span>		echo ""
</span><span>		exit 1
</span><span>	fi
</span><span>}
</span></code></pre><p><code>sed</code>命令功能繁多，所以这里只讲讲我在实战中使用到的，首先了解<code>sed</code>命令的结构<p><code>sed -param operation/pattern/replacement/flags</code><p><code>sed param</code><ul><li>-e script 在处理输入时，将script中指定的命令添加到已有的命令中<li>-f file 在处理输入时，将file中指定的命令添加到已有的命令中<li>-n 不产生命令输出，使用print命令来完成输出<li>-i 把修改写入到原文件中</ul><p><code>sed operation</code><ul><li>s 替换<li>a 追加<li>d 删除</ul><p><code>sed pattern/replacement</code><p>查找对应的模式和匹配模式的替换内容<p><code>sed flag</code><p>有4种可用的替换标记：<ul><li>数字，表明新文本将替换第几处模式匹配的地方；<li>g，表明新文本将会替换所有匹配的文本；<li>p，表明原先行的内容要打印出来；<li>w file，将替换的结果写到文件中。</ul><h3 id=3-1-sedtian-jia-nei-rong>3.1 sed添加内容</h3><p>以下是injectContentShell#<code>injectedContentShell.sh</code>脚本文件中的代码片段，使用<code>a</code>操作吧内容添加到方法的开头<ul><li><code>/^- \(.*\){$/</code>这部分是<code>pattern</code>，匹配OC中方法的开始<li><code>a\ '"$injected_content"'</code>这部分是<code>operation</code>，注意其中插入内容的变量要使用双引号和单引号包含处理</ul><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span># 在匹配的行下面添加插入内容
</span><span>sed -i '/^- \(.*\){$/{
</span><span>	a\ '"$injected_content"'
</span><span>}' ${file}
</span></code></pre><h3 id=3-2-sedshan-chu-nei-rong>3.2 sed删除内容</h3><p>以下是<a href=https://gitee.com/dhar/YTTInjectedContentKit/tree/master/DevPods/InjectedContentKit/Example/injectContentShell>injectContentShell</a>#<code>injectedContentShell.sh</code>脚本文件中的代码片段，使用<code>d</code>操作删除内容<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>sed -i '/'"$pattern_str"'/ {
</span><span>	d
</span><span>}' ${file}
</span></code></pre><h3 id=3-3-sedxiu-gai-ti-huan-nei-rong>3.3 sed修改替换内容</h3><p>以下是<a href=https://gitee.com/dhar/YTTInjectedContentKit/tree/master/DevPods/InjectedContentKit/Example/injectContentShell>injectContentShell</a>#<code>RenameClasses.sh</code>脚本文件中的代码片段，使用<code>s</code>操作替换内容，有以下几个要点<ul><li><code>s/'"${original_class_name}"'/'"${result_class_name}"'/g</code>，使用<code>s</code>操作，注意<code>pattern</code>和<code>replacement</code>中变量的处理方式，使用双引号、单引号双重包含，使用<code>flag</code>为<code>g</code>表示全部替换<li><code>grep ${original_class_name} -rl ${pbxproj_dir}</code>，<code>grep</code>命令查找<code>${pbxproj_dir}</code>文件夹下所有出现<code>${original_class_name}</code>内容的文件，<code>-r</code>选项表示递归查找，<code>-l</code>选项表示只显示匹配到的文件，返回的结果可能是多个的。</ul><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>sed -i '{
</span><span>	s/'"${original_class_name}"'/'"${result_class_name}"'/g
</span><span>}' `grep ${original_class_name} -rl ${pbxproj_dir}`
</span><span>sed -i '{
</span><span>	s/'"${original_class_name}"'/'"${result_class_name}"'/g
</span><span>}' `grep ${original_class_name} -rl ${class_name_replace_dir}`
</span></code></pre><h2 id=4-mo-kuai>4. 模块</h2><p>shell是面向过程的语言，不具备面向对象的特性，shell可以把部分功能独立分离出来，放在单独的脚本文件中，其他模块可以导入该脚本文件，使用其中的功能，这就是shell的伪面向对象<h3 id=4-1-gong-ju-mo-kuai>4.1 工具模块</h3><p>工具模块是包含了工具方法的模块，比如数学计算可以放在一个单独的文件中独立为一个模块，其他需要使用到的地方引入这个模块，使用其中定义的方法即可<p><code>Math.sh</code>保存了一些数学计算函数<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#!/bin/bash
</span><span>
</span><span>power(){
</span><span>	base=$1
</span><span>	exp=$2
</span><span>	result=1
</span><span>	for (( i = 0; i < $exp; i++ )); do
</span><span>		result=$[ $result * $base ];
</span><span>	done
</span><span>	echo $result
</span><span>}
</span></code></pre><p>其他模块使用<code>. ./Math.sh</code>包含这个模块，可以调用其中定义的power方法<p>注意：<code>. ./Math.sh</code>中<code>.</code>是<code>source</code>的简写，这里也可以写成<code>source ./Math.sh</code><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>echo "=======模块======="
</span><span>
</span><span>. ./Math.sh
</span><span>
</span><span>result=$(power 3 5)
</span><span>echo "3^5 = ${result}"
</span><span>
</span><span>输出：
</span><span>=======模块=======
</span><span>3^5 = 243
</span></code></pre><h3 id=4-2-liu-cheng-mo-kuai>4.2 流程模块</h3><p>流程模块是包含了一些列操作的模块，可以向该模块传递参数，也可以有返回值。流程模块中有两个地方比较特别，一个是流程模块本身参数的处理方式和外部调用流程模块传入参数的方式<p><strong>流程模块处理参数</strong><p>流程模块处理参数使用<code>getopts</code>命令实现，<code>getopts optionstring opt</code>其中<code>optionstring</code>格式<code>:i:o:</code>，<code>i</code>和<code>o</code>之后的<code>:</code>表示指定<code>i</code>选项和<code>o</code>选项需要有参数，第一个<code>:</code>表示忽略错误，使用case分支处理参数选项对应的参数值。<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#### 参数解析
</span><span>echo "参数>>${@}"
</span><span>while getopts :i:o: opt
</span><span>do
</span><span>	case "$opt" in
</span><span>		i) param_input_dir=$OPTARG
</span><span>			echo "Found the -i option, with parameter value $OPTARG"
</span><span>			;;
</span><span>		o) param_output_file=$OPTARG
</span><span>			echo "Found the -o option, with parameter value $OPTARG"
</span><span>			;;
</span><span>		*) echo "Unknown option: $opt";;
</span><span>	esac
</span><span>done
</span><span>echo "param_input_dir = ${param_input_dir}"
</span><span>echo "param_output_file = ${param_output_file}"
</span></code></pre><p><strong>参数的传递</strong><p>参数的传递和使用命令行的选项类似，可以在选项后面添加该选项的参数值<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>./GetAndStoreClasses.sh\
</span><span>	-i ${class_search_dir}\	
</span><span>	-o ${cfg_file}
</span></code></pre><p>下面定义的是一个流程模块的脚本文件，是<a href=https://gitee.com/dhar/YTTInjectedContentKit/tree/master/DevPods/InjectedContentKit/Example/injectContentShell>injectContentShell</a>#<code>GetAndStoreClasses.sh</code>脚本文件中的代码片段，实现了<code>生成重命名的类的配置脚本</code>功能，可以传递两个参数。<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>#!/bin/bash
</span><span>########################
</span><span># 脚本功能：生成重命名的类的配置脚本
</span><span># 输入参数 -i 输入的文件夹
</span><span># 输入参数 -o 保存的文件
</span><span>########################
</span><span>
</span><span>
</span><span>####### 参数定义
</span><span>param_input_dir=""
</span><span>param_output_file=""
</span><span>
</span><span>
</span><span>####### 参数解析
</span><span>echo "参数>>${@}"
</span><span>while getopts :i:o: opt
</span><span>do
</span><span>	case "$opt" in
</span><span>		i) param_input_dir=$OPTARG
</span><span>			echo "Found the -i option, with parameter value $OPTARG"
</span><span>			;;
</span><span>		o) param_output_file=$OPTARG
</span><span>			echo "Found the -o option, with parameter value $OPTARG"
</span><span>			;;
</span><span>		*) echo "Unknown option: $opt";;
</span><span>	esac
</span><span>done
</span><span>echo "param_input_dir = ${param_input_dir}"
</span><span>echo "param_output_file = ${param_output_file}"
</span><span>
</span><span>
</span><span>####### 配置
</span><span>
</span><span># 属性黑名单配置文件
</span><span>blacklist_cfg_file="$(pwd)/DefaultClassesBlackListConfig.cfg"
</span><span>
</span><span>
</span><span>####### 数据定义
</span><span>
</span><span># 定义保存需要处理目标文件的数组
</span><span>declare -a implement_source_file_array
</span><span>declare -a implement_source_file_name_array
</span><span>implement_source_file_count=0
</span><span>
</span><span># mark: p384
</span><span># 递归函数读取目录下的所有.m文件
</span><span>function read_implement_file_recursively {
</span><span>	echo "read_implement_file_recursively"
</span><span>	if [[ -d $1 ]]; then
</span><span>		for item in $(ls $1); do
</span><span>			itemPath="$1/${item}"
</span><span>			if [[ -d $itemPath ]]; then
</span><span>				# 目录
</span><span>				echo "处理目录 ${itemPath}"
</span><span>				read_implement_file_recursively $itemPath
</span><span>				echo "处理目录结束====="
</span><span>			else 
</span><span>				# 文件
</span><span>				echo "处理文件 ${itemPath}"
</span><span>				if [[ $(expr "$item" : '.*\.m') -gt 0 ]]; then
</span><span>					echo ">>>>>>>>>>>>mmmmmmm"
</span><span>					implement_source_file_array[$implement_source_file_count]=${itemPath}
</span><span>					class_name=${item//".m"/""};
</span><span>					implement_source_file_name_array[$implement_source_file_count]=${class_name}
</span><span>					implement_source_file_count=$[ implement_source_file_count + 1 ];
</span><span>				fi
</span><span>				echo ""
</span><span>			fi
</span><span>		done
</span><span>	else
</span><span>		echo "err:不是一个目录"
</span><span>	fi
</span><span>}
</span><span>
</span><span>post_implement_file_handle() {
</span><span>	local wirte_to_file=$1
</span><span>	# 写入文件中
</span><span>	echo "# 需要处理的类配置文件" > ${wirte_to_file}
</span><span>	for(( i=0;i<${#implement_source_file_name_array[@]};i++)) 
</span><span>	do 
</span><span>		class_file_name=${implement_source_file_name_array[i]}; 
</span><span>		echo ${class_file_name} >> ${wirte_to_file}
</span><span>	done;
</span><span>
</span><span>	# 去重
</span><span>	wirte_to_file_bak="${wirte_to_file}.bak"
</span><span>	mv ${wirte_to_file} ${wirte_to_file_bak}
</span><span>	sort ${wirte_to_file_bak} | uniq > ${wirte_to_file}
</span><span>
</span><span>	# 过滤
</span><span>	mv ${wirte_to_file} ${wirte_to_file_bak}
</span><span>	echo "# Properties Configs Filtered" > ${wirte_to_file}
</span><span>	IFS_OLD=$IFS
</span><span>	IFS=$'\n'
</span><span>	# 上一行的内容
</span><span>	lastLine="";
</span><span>	for line in $(cat ${wirte_to_file_bak} | sed 's/^[ \t]*//g')
</span><span>	do
</span><span>		grep_result=$(grep ${line} ${blacklist_cfg_file})
</span><span>		category_judge_substring="\+"
</span><span>		if [[ ${#line} -le 6 ]] || [[ $(expr "$line" : '^#.*') -gt 0 ]] || [[ -n ${grep_result} ]] || [[ ${line} =~ ${category_judge_substring} ]]; then
</span><span>			# 长度小于等于6、注释内容的行、在黑名单中的内容、分类文件不处理
</span><span>			echo "less then 6 char line or comment line"
</span><span>		else
</span><span>			if [[ -n ${lastLine} ]]; then
</span><span>				# 上一行是非空白行
</span><span>				# 比较上一行内容是否是当前行的一部分，不是添加上一行
</span><span>				if [[ ${line} =~ ${lastLine} ]]; then
</span><span>					echo "${line} 和 ${lastLine} 有交集"
</span><span>				else
</span><span>					echo ${lastLine} >> ${wirte_to_file}
</span><span>				fi
</span><span>			fi
</span><span>			# 更新上一行
</span><span>			lastLine=${line}
</span><span>		fi	
</span><span>	done
</span><span>	IFS=${IFS_OLD}
</span><span>
</span><span>	# 删除临时文件
</span><span>	rm -f ${wirte_to_file_bak}
</span><span>}
</span><span>
</span><span>read_implement_file_recursively ${param_input_dir}
</span><span>post_implement_file_handle ${param_output_file}
</span></code></pre><p>在另一个模块中使用流程模块<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span># 获取需要重命名的类名称，保存到配置文件中
</span><span>./GetAndStoreClasses.sh\
</span><span>	-i ${class_search_dir}\	
</span><span>	-o ${cfg_file}
</span></code></pre><h2 id=5-shu-ru-he-cai-dan>5. 输入和菜单</h2><h3 id=5-1-huo-qu-shu-ru>5.1 获取输入</h3><p>下面是一个循环的输入和检测输入是否是合法目录的例子，是<a href=https://gitee.com/dhar/YTTInjectedContentKit/tree/master/DevPods/InjectedContentKit/Example/injectContentShell>injectContentShell</a>#<code>FileUtil.sh</code>脚本文件中的代码片段<ul><li><code>echo -n "请输入目录: "</code>是输入的提示，<code>-n</code>表示不换行，用户的输入跟随在提示后面<li><code>read path</code>把用户的输入内容保存在变量path中</ul><pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span># 循环检测输入的文件夹
</span><span>checkInputDestDirRecursive() {
</span><span>	echo -n "请输入目录: "
</span><span>	read path
</span><span>	if [[ -d $path ]]; then
</span><span>		CheckInputDestDirRecursiveReturnValue=$path
</span><span>	else
</span><span>		echo -n "输入的目录无效，"
</span><span>		checkInputDestDirRecursive
</span><span>	fi
</span><span>}
</span></code></pre><h3 id=5-2-cai-dan>5.2 菜单</h3><p>在脚本中可能会有使用菜单选项进行交互的场景，有以下几个要点<ul><li><code>read -n 1 option</code>命令中用了-n选项来限制只读取一个字符。这样用户只需要输入一个数字，也不用按回车键，输入的内容保存在<code>option</code>变量中<li><code>clear</code>命令是用来清空命令行的屏幕的<li><code>echo -e</code> -e 选项用来处理转义字符<li><code>echo -en</code> -n 选项让光标处于同一行，用户的输入会显示在同一行<li>使用<code>while</code>循环获取用户的输入，在<code>while</code>循环中使用<code>case</code>分支处理不同的操作</ul><p>以下脚本是<a href=https://gitee.com/dhar/YTTInjectedContentKit/tree/master/DevPods/InjectedContentKit/Example/injectContentShell>injectContentShell</a>#<code>injectedContentShell.sh</code>文件中的一部分<pre class=language-shell data-lang=shell style=background-color:#2b303b;color:#c0c5ce;><code class=language-shell data-lang=shell><span>function genMunu {
</span><span>	clear
</span><span>	echo
</span><span>	echo -e "\t\t\t选项菜单\n"
</span><span>	echo -e "\t1. 删除注入内容"
</span><span>	echo -e "\t2. 添加注入内容"
</span><span>	echo -e "\t0. Exit menu\n\n"
</span><span>	echo -en "\t\tEnter option: "
</span><span>	read -n 1 option
</span><span>}
</span><span>
</span><span>
</span><span>while [[ 1 ]]; do
</span><span>	genMunu
</span><span>	case $option in
</span><span>	0 )
</span><span>		echo ""
</span><span>		echo "Bye"
</span><span>		exit 0
</span><span>	;;
</span><span>	1 )
</span><span>		# 删除配置文件中注入的内容
</span><span>		removeInjectedContent
</span><span>	;;
</span><span>	2 )
</span><span>		# 添加配置文件中注入的内容
</span><span>		addInjectedContent
</span><span>	;;
</span><span>	h )
</span><span>		genMunu
</span><span>	;;
</span><span>	* )
</span><span>		echo "Wrong!!"
</span><span>	;;
</span><span>	esac
</span><span>
</span><span>	echo
</span><span>	echo -en "\n\n\tHit any key to continue"
</span><span>	read -n 1 line
</span><span>
</span><span>done
</span></code></pre><h2 id=4-chu-li-yong-hu-shu-ru>4. 处理用户输入</h2><h3 id=4-1-ming-ling-xing-can-shu>4.1.命令行参数</h3><p>向shell脚本传递数据的最基本方法是使用命令行参数，他允许在运行脚本时向命令行添加数据，例如<code>./mytest 10 30</code>向脚本<code>mytest</code>传递了两个命令行参数（<code>10</code>和<code>30</code>）。脚本会通过<strong>特殊的变量</strong>来处理命令行参数。<p>bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数，这也包括shell所执行的<strong>脚本名称</strong>。<p>位置参数变量是标准的数字：<code>$0</code>是程序名，<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，依次类推，直到第九个参数<code>$9</code>。如果脚本需要的命令行参数不止9个，则必须在变量数字周围加上花括号，比如<code>${10}</code>。<p>如果需要输入更多的命令行参数，则每个参数都必须用空格分开，shell会将每个参数分配给对应的变量。要在参数值中包含空格，必须要用引号（单引号或双引号均可）。 **注意：**将文本字符串作为参数传递时，引号并非数据的一部分，它们只是表明数据的起止位置。 **注意：**利用<code>$0</code>读取脚本名时存在一个潜在的问题，即<code>$0</code>参数会同时包含路径和连在一起的命令，如下表所示。解决这个问题只需要使用<code>basename</code>命令，他会返回不包含路径的脚本名：<code>basename $0</code>，例如<code>script=$(basename $0)</code>。<table><thead><tr><th align=center>执行命令<th align=center><code>$0</code>变量<th align=left>备注<tbody><tr><td align=center><code>bash mz.sh</code><td align=center><code>mz.sh</code><td align=left>没有问题<tr><td align=center><code>./mz.sh</code><td align=center><code>./mz.sh</code><td align=left>包含命令<tr><td align=center><code>bash /home/hwame/mz.sh</code><td align=center><code>/home/hwame/mz.sh</code><td align=left>包含路径</table><p>在shell脚本中使用命令行参数时要小心些。当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。 通俗的说，当脚本中使用了变量<code>$1</code>、<code>$2</code>、<code>$3</code>时，如果允许脚本时没有给出对应的命令行参数则会报错。<p>因此<strong>在使用参数前一定要检查其中是否存在数据</strong>，一种方法是使用<code>-n</code>测试来检查命令行参数<code>$1</code>中是否有数据：<code>if [ -n "$1"]; then</code>。<h3 id=4-2-te-shu-can-shu-bian-liang>4.2.特殊参数变量</h3><p>如果每次都在脚本中使用之前检查一下命令行参数，无疑比较麻烦。bash shell为此提供了一个 特殊变量<code>$#</code>，他含有<strong>脚本运行时携带的命令行参数的个数</strong>。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。注意，变量<code>$#</code>的值不包括脚本名称。<p>**那么问题来了。**既然<code>$#</code>变量含有参数的总数，那么变量<code>${$#}</code>就代表了最后一个命令行参数变量。然而并不是这样，你不能在花括号内使用美元符，必须将美元符换成感叹号即<code>${!#}</code>。很奇怪，但不讲道理。我们也可以拆分一下，将<code>$#</code>赋值给一个变量<code>params</code>然后再使用<code>params</code>变量：<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span># Grabbing the last parameter
</span><span>params=$#
</span><span>echo The last parameter is $params
</span><span>echo The last parameter is ${!#}
</span></code></pre><p>上述示例中的两种方式都没问题。但要注意，当命令行上没有任何参数时，<code>$#</code>的值为<code>0</code>，<code>params</code>变量的值也一样，但<code>${!#}</code>变量会返回命令行用到的脚本名。<p>有时候需要抓取命令行上提供的所有参数，希望能够<strong>在单个变量中存储所有的命令行参数</strong>，而不是先用<code>$#</code>变量来判断命令行上有多少参数，然后再进行遍历。<p>可以使用一组其他的特殊变量<code>$*</code>和<code>$@</code>来解决这个问题：<ul><li><code>$*</code>变量会将命令行上提供的所有参数<strong>当作一个单词</strong>保存，这个单词包含了命令行中出现的每一个参数值。基本上<code>$*</code>变量会将这些参数视为一个整体，而不是多个个体。<li><code>$@</code>变量会将命令行上提供的所有参数<strong>当作同一字符串中的多个独立的单词</strong>。通常通过<code>for</code>命令遍历所有的参数值，得到每个参数。</ul><p>通过使用<code>for</code>命令遍历这两个特殊变量，可以看到它们是如何不同地处理命令行参数的。 <code>$*</code>变量会将所有参数当成单个参数，而<code>$@</code>变量会单独处理每个参数。这是遍历命令行参数的一个绝妙方法。二者之间的差异见下例：<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span>count=1
</span><span>for param in "$*"
</span><span>do
</span><span>    echo "\$* Parameter #$count = $param"
</span><span>    count=$[ $count + 1 ]
</span><span>done
</span><span>echo
</span><span>
</span><span>count=1
</span><span>for param in "$@"
</span><span>do
</span><span>    echo "\$@ Parameter #$count = $param"
</span><span>    count=$[ $count + 1 ]
</span><span>done
</span></code></pre><p>运行结果如图： <a href=https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201%E6%8A%93%E5%8F%96%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95.png><img alt=抓取所有参数的两种方法 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201201%E6%8A%93%E5%8F%96%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95.png></a><h3 id=4-3-yi-dong-bian-liang>4.3.移动变量</h3><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。顾名思义，他会根据它们的相对位置来移动命令行参数。 默认情况下它会将每个参数变量向左移动一个位置。所以，变量<code>$3</code>的值会移到<code>$2</code>中，变量<code>$2</code>的值会移到<code>$1</code>中，而变量<code>$1</code>的值则会被删除（注意，变量<code>$0</code>的值即程序名不会改变）。也可以一次性移动多个位置，只需要给<code>shift</code>命令提供一个参数指明要移动的位置数就行了：<code>shift n</code>。 **注意：**如果某个参数被移出，它的值就被丢弃了，无法再恢复。<p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数，例如：<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span>count=1
</span><span>while [ -n "$1" ]; do
</span><span>    echo "Parameter #$count = $1"
</span><span>    count=$[ $count + 1 ]
</span><span>    shift
</span><span>done
</span></code></pre><p>运行结果如图所示： <a href=https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201%E7%A7%BB%E5%8A%A8%E5%8F%98%E9%87%8F.png><img alt=移动变量 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201201%E7%A7%BB%E5%8A%A8%E5%8F%98%E9%87%8F.png></a><h3 id=4-4-chu-li-xuan-xiang>4.4.处理选项</h3><p>「<code>选项</code>」是跟在单破折线后面的<strong>单个字母</strong>，它能改变命令的行为，此处介绍3种在脚本中处理选项的方法。<h4 id=1-cha-zhao-xuan-xiang>(1)查找选项</h4><p>表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行参数一样。实际上，如果愿意，你可以像处理命令行参数一样处理命令行选项。<ul><li><p>①处理简单选项：</p> <p>可以用</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>shift
</span></code></pre> <p>命令来处理脚本程序携带的命令行选项，用</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>case
</span></code></pre> <p>语句来判断某个参数是否为选项。</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>case
</span></code></pre> <p>语句会检查每个参数是不是有效选项，如果是就运行对应语句中的命令。不管选项按什么顺序出现在命令行上，这种方法都适用。示例如下：</p> <p>一键复制</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span># extracting command line options as parameters
</span><span>while [ -n "$1" ]; do
</span><span>    case "$1" in
</span><span>        -a) echo "Found the -a option" ;;
</span><span>        -b) echo "Found the -b option" ;;
</span><span>        -c) echo "Found the -c option" ;;
</span><span>         *) echo "$1 is not an option" ;;
</span><span>    esac
</span><span>    shift
</span><span>done
</span></code></pre><li><p>②分离参数和选项：</p> <p>对于在shell脚本中同时使用</p> <p>选项</p> <p>和</p> <p>参数</p> <p>的情况，标准方式是用特殊字符（双破折线</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>--
</span></code></pre> <p>）来将二者分开，该字符会告诉脚本</p> <p>何时选项结束</p> <p>以及</p> <p>普通参数何时开始</p> <p>。</p> <p>shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作</p> <p>参数</p> <p>，而不是</p> <p>选项</p> <p>来处理了。要检查双破折线，只要在case语句中加一项就行了，如下例所示：</p> <p>一键复制</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span># extracting options and parameters
</span><span>while [ -n "$1" ]; do
</span><span>    case "$1" in
</span><span>        -a) echo "Found the -a option" ;;
</span><span>        -b) echo "Found the -b option" ;;
</span><span>        -c) echo "Found the -c option" ;;
</span><span>        --) shift
</span><span>            break ;;
</span><span>         *) echo "$1 is not an option" ;;
</span><span>    esac
</span><span>    shift
</span><span>done
</span><span>
</span><span>count=1
</span><span>for param in $@; do
</span><span>    echo "Parameter #$count: $param"
</span><span>    count=$[ $count + 1 ]
</span><span>done
</span></code></pre> <p>运行结果如图，可以看出，第一次未分离时脚本认为所有的命令行参数都是选项；第二次使用</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>--
</span></code></pre> <p>分离后，当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。</p> <p><img alt=分离参数和选项 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201201%E5%88%86%E7%A6%BB%E5%8F%82%E6%95%B0%E5%92%8C%E9%80%89%E9%A1%B9.png></p><li><p>③处理带值的选项：</p> <p>有些选项会带上一个额外的参数值，例如：</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>./mz.sh -a test1 -b -c -d test2
</span></code></pre> <p>。当命令行选项要求额外的参数时，脚本必须能检测到并正确处理，如下例：</p> <p>一键复制</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span># extracting command line options and values
</span><span>while [ -n "$1" ]; do
</span><span>    case "$1" in
</span><span>        -a) echo "Found the -a option";;
</span><span>        -b) param="$2"
</span><span>            echo "Found the -b option, with parameter value $param"
</span><span>            shift ;;
</span><span>        -c) echo "Found the -c option";;
</span><span>        --) shift
</span><span>            break ;;
</span><span>         *) echo "$1 is not an option";;
</span><span>    esac
</span><span>    shift
</span><span>done
</span><span>
</span><span>count=1
</span><span>for param in "$@"; do
</span><span>    echo "Parameter #$count: $param"
</span><span>    count=$[ $count + 1 ]
</span><span>done
</span></code></pre> <p>在这个例子中，</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>case
</span></code></pre> <p>语句定义了三个它要处理的选项，其中</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>-b
</span></code></pre> <p>选项还需要一个额外的参数值。由于要处理的参数是</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>$1
</span></code></pre> <p>，额外的参数值就应该位于</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>$2
</span></code></pre> <p>（因为所有的参数在处理完之后都会被移出）。只要将参数值从</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>$2
</span></code></pre> <p>变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以你还需要使用</p> <pre style=background-color:#2b303b;color:#c0c5ce;><code><span>shift
</span></code></pre> <p>命令多移动一个位置。运行结果如图：</p> <p><img alt=处理带值的选项 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201201%E5%A4%84%E7%90%86%E5%B8%A6%E5%80%BC%E7%9A%84%E9%80%89%E9%A1%B9.png></p></ul><h4 id=2-getoptming-ling>(2)<code>getopt</code>命令</h4><p>上述shell脚本已经有了处理命令行选项的基本能力，但还有一些限制。比如，<strong>合并选项</strong>是Linux中一个很常见的用法，如果你想<strong>将多个选项放进一个参数中</strong>时，它就不能工作了。 <code>getopt</code>命令是一个在处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而在脚本中解析它们时更方便。<p>命令格式：<code>getopt optstring parameters</code>。 <code>optstring</code>是这个过程的关键所在，它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。 首先，在<code>optstring</code>中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。<code>getopt</code>命令会基于你定义的<code>optstring</code>解析提供的参数。<p>举例如图： <a href=https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201getopt%E5%91%BD%E4%BB%A4.png><img alt=getopt命令 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201201getopt%E5%91%BD%E4%BB%A4.png></a> 命令行<code>getopt ab:cd -a -b test1 -cd test2 test3</code>中的<code>optstring</code>定义了四个有效选项字母：<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>。冒号（<code>:</code>）被放在了字母<code>b</code>后面，因为<code>b</code>选项需要一个参数值。当<code>getopt</code>命令运行时，它会检查提供的参数列表（<code>-a -b test1 -cd test2 test3</code>），并基于提供的<code>optstring</code>进行解析。注意，它会自动将<code>-cd</code>选项分成两个单独的选项，并插入双破折线来分隔行中的额外参数<code>test2 test3</code>。 **注意：**如果指定了一个不在<code>optstring</code>中的选项，默认情况下<code>getopt</code>命令会产生一条错误消息，可以在命令后加<code>-q</code>选项来忽略这条错误消息。如下图所示： <a href=https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201%E5%A4%9A%E4%BD%99%E7%9A%84%E9%80%89%E9%A1%B9.png><img alt=多余的选项 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201201%E5%A4%9A%E4%BD%99%E7%9A%84%E9%80%89%E9%A1%B9.png></a><p>---+++<p>可以在脚本中使用<code>getopt</code>来格式化脚本所携带的任何命令行选项或参数，但用起来略微复杂。 用<code>getopt</code>命令生成的格式化后的版本来替换已有的命令行选项和参数，<code>set</code>命令的选项之一是双破折线<code>--</code>，它会将命令行参数替换成<code>set</code>命令的命令行值。<p>该方法会将原始脚本的命令行参数传给<code>getopt</code>命令，之后再将<code>getopt</code>命令的输出传给<code>set</code>命令，用<code>getopt</code>格式化后的命令行参数来替换原始的命令行参数，格式看起来如下所示：<code>set -- $(getopt -q ab:cd "$@")</code>。 现在原始的命令行参数变量的值会被<code>getopt</code>命令的输出替换，而<code>getopt</code>已经为我们格式化 好了命令行参数。利用该方法就可以写出能帮我们处理命令行参数的脚本：<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span>set -- $(getopt -q ab:cd "$@")
</span><span>while [ -n "$1" ]; do
</span><span>    case "$1" in
</span><span>        -a) echo "Found the -a option" ;;
</span><span>        -b) param="$2"
</span><span>            echo "Found the -b option, with parameter value $param"
</span><span>            shift ;;
</span><span>        -c) echo "Found the -c option" ;;
</span><span>        --) shift
</span><span>            break ;;
</span><span>         *) echo "$1 is not an option";;
</span><span>    esac
</span><span>    shift
</span><span>done
</span><span>
</span><span>count=1
</span><span>for param in "$@"; do
</span><span>    echo "Parameter #$count: $param"
</span><span>    count=$[ $count + 1 ]
</span><span>done
</span></code></pre><p>注意到该例和上文<a href=https://hwame.top/20201127/learning-linux-shell-script.html#1-%E6%9F%A5%E6%89%BE%E9%80%89%E9%A1%B9>查找选项</a>中第三种情况「处理带值的选项」一样，唯一不同的是加入了<code>getopt</code>命令来帮助格式化命令行参数。并且可以运行带有复杂选项的脚本如合并的选项：<code>./mz.sh -ac</code>，同时之前的功能照样没有问题。<h4 id=3-geng-gao-ji-de-getoptsming-ling>(3)更高级的<code>getopts</code>命令</h4><p>然而，<code>getopt</code>命令并不擅长处理带空格和引号的参数值，它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。<p><code>getopts</code>命令（<strong>注意是复数</strong>）内建于bash shell，它跟近亲<code>getopt</code>看起来很像，但多了一些扩展功能。<code>getopt</code>将命令行上选项和参数处理后只生成一个输出，而<code>getopts</code>命令能够和已有的shell参数变量配合默契。<p>每次调用<code>getopts</code>时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并返回一个大于<code>0</code>的退出状态码。这让它非常适合用于解析命令行所有参数的循环中。<p><code>getopts</code>命令的格式如下：<code>getopts optstring variable</code>。 <code>optstring</code>值类似于<code>getopt</code>命令中的那个。有效的选项字母都会列在<code>optstring</code>中，如果选项字母要求有个参数值，就加一个冒号。要去掉错误消息的话，可以在<code>optstring</code>之前加一个冒号。<code>getopts</code>命令将当前参数保存在命令行中定义的<code>variable</code>中。 <code>getopts</code>命令会用到两个环境变量：<code>OPTARG</code>环境变量保存选项需要跟的一个参数值；<code>OPTIND</code>环境变量保存了参数列表中<code>getopts</code>正在处理的参数位置。这样你就能在处理完选项之后继续处理其他命令行参数了。<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span># simple demonstration of the getopts command
</span><span>while getopts :ab:c opt
</span><span>do
</span><span>    case "$opt" in
</span><span>        a) echo "Found the -a option" ;;
</span><span>        b) echo "Found the -b option, with value $OPTARG";;
</span><span>        c) echo "Found the -c option" ;;
</span><span>        *) echo "Unknown option: $opt";;
</span><span>    esac
</span><span>done
</span></code></pre><p><code>while</code>语句定义了<code>getopts</code>命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（<code>opt</code>）。注意到在本例中<code>case</code>语句的用法有些不同：<code>getopts</code>命令解析命令行选项时会移除开头的单破折线，所以在<code>case</code>定义中不用单破折线。 <code>getopts</code>命令有几个好用的功能：①可以在参数值中包含空格；②可以将选项字母和参数值放在一起使用，而不用加空格，<code>getopts</code>命令能够从选项中正确解析出参数值；③可以将命令行上所有未定义的选项统一输出成问号，以问号形式发送给代码。 上述代码运行结果如图： <a href=https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202getopts%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95.png><img alt=getopts命令用法 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201202getopts%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95.png></a><p><code>getopts</code>命令知道何时停止处理选项，并将参数留给你处理。在<code>getopts</code>处理每个选项时，它会将<code>OPTIND</code>环境变量值增一。在<code>getopts</code>完成处理时，你可以使用<code>shift</code>命令和<code>OPTIND</code>值来移动参数。如下例：<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span>while getopts :ab:cd opt
</span><span>do
</span><span>    case "$opt" in
</span><span>        a) echo "Found the -a option" ;;
</span><span>        b) echo "Found the -b option, with value $OPTARG" ;;
</span><span>        c) echo "Found the -c option" ;;
</span><span>        d) echo "Found the -d option" ;;
</span><span>        *) echo "Unknown option: $opt" ;;
</span><span>    esac
</span><span>done
</span><span>
</span><span>shift $[ $OPTIND - 1 ]
</span><span>count=1
</span><span>for param in "$@"
</span><span>do
</span><span>    echo "Parameter $count: $param"
</span><span>    count=$[ $count + 1 ]
</span><span>done
</span></code></pre><p>运行结果如图： <a href=https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FOPTIND.png><img alt=环境变量OPTIND src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201202%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FOPTIND.png></a><h3 id=4-5-jiang-xuan-xiang-biao-zhun-hua>4.5.将选项标准化</h3><p>所谓选项标准化，就是尽量遵循某些字母选项在Linux世界里已经拥有的某种程度的标准含义，而不是随意决定用哪些字母选项以及它们的用法，将选项标准化使得脚本看起来能更友好一些。常用的Linux命令选项如下：<table><thead><tr><th align=center>选项<th align=center>含义<th align=left>描述<tbody><tr><td align=center><code>-a</code><td align=center><code>all</code><td align=left>显示所有对象<tr><td align=center><code>-c</code><td align=center><code>count</code><td align=left>生成一个计数<tr><td align=center><code>-d</code><td align=center><code>directory</code><td align=left>指定一个目录<tr><td align=center><code>-e</code><td align=center><code>extend</code><td align=left>扩展一个对象<tr><td align=center><code>-f</code><td align=center><code>file</code><td align=left>指定读入数据的文件<tr><td align=center><code>-h</code><td align=center><code>help</code><td align=left>显示命令的帮助信息<tr><td align=center><code>-i</code><td align=center><code>ignorecase</code><td align=left>忽略文本大小写<tr><td align=center><code>-l</code><td align=center><code>long</code><td align=left>产生输出的长格式版本<tr><td align=center><code>-n</code><td align=center><code>non-interactive</code><td align=left>使用非交互模式（批处理）<tr><td align=center><code>-o</code><td align=center><code>output redirect</code><td align=left>将所有输出重定向到指定的输出文件<tr><td align=center><code>-q</code> <code>-s</code><td align=center><code>quiet</code> <code>silent</code><td align=left>以安静模式运行<tr><td align=center><code>-r</code><td align=center><code>recursive</code><td align=left>递归地处理目录和文件<tr><td align=center><code>-v</code><td align=center><code>verbose</code><td align=left>生成详细输出<tr><td align=center><code>-x</code><td align=center><code>exclude</code><td align=left>排除某个对象<tr><td align=center><code>-y</code><td align=center><code>yes</code><td align=left>对所有问题回答yes</table><h3 id=4-6-huo-de-yong-hu-shu-ru>4.6.获得用户输入</h3><p>尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的人来回答。bash shell为此提供了<code>read</code>命令。<h4 id=1-ji-ben-de-du-qu>(1)基本的读取</h4><p><code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入，在收到输入后会将数据放进一个指定的变量。例如：<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span>echo -n "Enter your name: "
</span><span>read name
</span><span>echo "Hello $name, welcome to my program. "
</span></code></pre><p>注意，上例中生成提示的<code>echo</code>命令使用了<code>-n</code>选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。这让脚本看起来更像表单。 实际上，<strong><code>read</code>命令包含了<code>-p</code>选项，允许你直接在<code>read</code>命令行指定提示符</strong>。例如：<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span>read -p "Please enter your age: " age
</span><span>days=$[ $age * 365 ]
</span><span>echo "That makes you over $days days old! "
</span></code></pre><p><code>read</code>命令也允许指定多个变量，输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。是不是和Python中的<code>*args</code>和<code>**kwargs</code>有点像呢？ 也可以在<code>read</code>命令行中不指定变量，这样它收到的任何数据都会放进特殊环境变量<code>REPLY</code>中。<code>REPLY</code>环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。<h4 id=2-chao-shi>(2)超时</h4><p>如果不管是否有数据输入，脚本都必须继续执行，你可以用<code>-t</code>选项来指定一个计时器，他指定了<code>read</code>命令等待输入的秒数。当计时器过期后，<code>read</code>命令会返回一个非零退出状态码，可以使用<code>if-then</code>语句或<code>while</code>循环这种标准的结构化语句来理清所发生的具体情况。<p>也可以不对输入过程计时，而是让<code>read</code>命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。可以将<code>-n</code>选项和值<code>1</code>一起使用，告诉<code>read</code>命令在接受<strong>单个字符</strong>后退出。只要按下单个字符回答后，<code>read</code>命令就会接受输入并将它传给变量，无需按回车键。<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span>read -n1 -p "Do you want to continue [Y/N]? " answer
</span><span>case $answer in
</span><span>    Y | y) echo
</span><span>           echo "fine, continue on…";;
</span><span>    N | n) echo
</span><span>           echo OK, goodbye
</span><span>           exit;;
</span><span>esac
</span><span>echo "This is the end of the script"
</span></code></pre><p>运行结果如图： <a href=https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202read%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%97%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6.png><img alt=read命令接受指定字符 src=shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/20201202read%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%97%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6.png></a><h4 id=3-yin-cang-fang-shi-du-qu>(3)隐藏方式读取</h4><p>当需要输入类似密码这种需要从脚本用户处得到输入，但又在屏幕上显示输入信息时，可以使用<code>-s</code>选项不回显终端的输入（实际上数据会被显示，只是<code>read</code>命令会将文本颜色设成跟背景色一样）。输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。例如：<code>read -s -p "Enter your password: " password</code>。<h4 id=4-cong-wen-jian-zhong-du-qu>(4)从文件中读取</h4><p>可以用<code>read</code>命令来读取文件里的数据，每次调用<code>read</code>命令都会从文件中读取一行文本。当文件中再没有内容时，<code>read</code>命令会退出并返回非零退出状态码。 如何将文件中的数据传给<code>read</code>命令呢？最常见的方法是对文件使用<code>cat</code>命令，将结果通过管道直接传给含有<code>read</code>命令的<code>while</code>命令。见下例：<p>一键复制<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#!/bin/bash
</span><span>count=1
</span><span>cat textfile | while read line
</span><span>do
</span><span>    echo "Line $count: $line"
</span><span>    count=$[ $count + 1]
</span><span>done
</span><span>echo "Finished processing the file"
</span></code></pre><p>文件<code>textfile</code>内容及运行结果如下： [<img alt=从文件中读取数据 src=Linux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/20201202%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE.png></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>