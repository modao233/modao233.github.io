<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/Interview/part-C++知识总结/stl/>STL</a></h1><div class=post-meta-inline><span class=post-date> 2020-07-25 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/interview/>#Interview</a></span><div class=post-content><h1 id=stl>STL</h1><p>https://github.com/huihut/interview/blob/master/STL/STL.md<p>https://github.com/huihut/interview/tree/master/STL<h2 id=stl-zu-cheng>STL 组成</h2><ul><li>容器（containers）<li>算法（algorithms）<li>迭代器（iterators）<li>仿函数（functors）<li>配接器（adapters）<li>空间配置器（allocator）</ul><h2 id=stl-rong-qi>STL 容器</h2><p>总体分类：<ul><li>序列式容器（sequence containers）：元素都是可以排序的，但不一定是排序好的<li>关联式容器（associattive containers）</ul><h3 id=shun-xu-rong-qi>顺序容器</h3><p>顺序容器实现能按顺序访问的数据结构。<ul><li><p>array(C++11)：静态的连续数组 (类模板)</p><li><p>vector：动态的连续数组 (类模板)</p><li><p>deque：双端队列 (类模板)</p><li><p>forward_list(C++11 起)：单链表 (类模板)</p><li><p>list：双链表 (类模板)</p></ul><h3 id=guan-lian-rong-qi>关联容器</h3><p>关联容器实现能快速查找（ <em>O(log n)</em> 复杂度）的数据结构。<ul><li><p>set：唯一键的集合，按照键排序 (类模板)</p><li><p>map：键值对的集合，按照键排序，键是唯一的 (类模板)</p><li><p>multiset：键的集合，按照键排序 (类模板)</p><li><p>multimap：键值对的集合，按照键排序 (类模板)</p></ul><h3 id=wu-xu-guan-lian-rong-qi>无序关联容器</h3><p>无序关联容器提供能快速查找的无序数据结构（哈希表实现的数据结构）。（均摊 <em>O(1)</em> ，最坏情况 <em>O(n)</em> 的复杂度）<ul><li><p>unordered_set(C++11 起)：唯一键的集合，按照键生成散列 (类模板)</p><li><p>unordered_map(C++11 起)：键值对的集合，按照键生成散列，键是唯一的 (类模板)</p><li><p>unordered_multiset(C++11 起)：键的集合，按照键生成散列 (类模板)</p><li><p>unordered_multimap(C++11 起)：键值对的集合，按照键生成散列 (类模板)</p></ul><h3 id=rong-qi-gua-pei-qi>容器适配器</h3><p>容器适配器提供顺序容器的不同接口。<ul><li><p>stack：适配一个容器以提供栈（LIFO 数据结构）(类模板)</p><li><p>queue：适配一个容器以提供队列（FIFO 数据结构）(类模板)</p><li><p>priority_queue：适配一个容器以提供优先级队列 (类模板)</p></ul><h3 id=span><code>span</code></h3><p><code>span</code> 是相接的对象序列上的非占有视图，某个其他对象占有序列的存储。<ul><li>span(C++20)：对象的连续序列上的无所有权视图 (类模板)</ul><h2 id=stl-shi-li>STL 示例</h2><h3 id=std-array>std::array</h3><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>//此容器是一个聚合类型,能作为聚合类型聚合初始化
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>array</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>string</span><span>>
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(){
</span><span>    </span><span style=color:#65737e;>//初始化
</span><span>    std::array<</span><span style=color:#b48ead;>int</span><span>, </span><span style=color:#d08770;>3</span><span>> a1 = {</span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>2</span><span>, </span><span style=color:#d08770;>3</span><span>};
</span><span>    std::array&LTstd::string, </span><span style=color:#d08770;>2</span><span>> a2 = {std::</span><span style=color:#bf616a;>string</span><span>("</span><span style=color:#a3be8c;>a</span><span>"), "</span><span style=color:#a3be8c;>b</span><span>"};
</span><span>    std::array<</span><span style=color:#b48ead;>int</span><span>, </span><span style=color:#d08770;>3</span><span>> a3;
</span><span>    </span><span style=color:#65737e;>//获取迭代器
</span><span>    std::array<</span><span style=color:#b48ead;>int</span><span>, </span><span style=color:#d08770;>3</span><span>>::iterator begin = a1.</span><span style=color:#bf616a;>begin</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> cbegin = a1.</span><span style=color:#bf616a;>cbegin</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> end = a1.</span><span style=color:#bf616a;>end</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> cend = a1.</span><span style=color:#bf616a;>cend</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> rbegin = a1.</span><span style=color:#bf616a;>rbegin</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> crbegin = a1.</span><span style=color:#bf616a;>crbegin</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> rend = a1.</span><span style=color:#bf616a;>rend</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> crend = a1.</span><span style=color:#bf616a;>crend</span><span>();
</span><span>    </span><span style=color:#65737e;>//容量
</span><span>    </span><span style=color:#b48ead;>bool</span><span> isEmpty = a1.</span><span style=color:#bf616a;>empty</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> size = a1.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> max_size = a1.</span><span style=color:#bf616a;>max_size</span><span>();
</span><span>    </span><span style=color:#65737e;>//操作
</span><span>    a3.</span><span style=color:#bf616a;>fill</span><span>(</span><span style=color:#d08770;>6</span><span>);</span><span style=color:#65737e;>//将定值 value 赋给容器中的所有元素
</span><span>    a1.</span><span style=color:#bf616a;>swap</span><span>(a3);</span><span style=color:#65737e;>//将容器a1内容和a3交换。不导致迭代器和引用关联到别的容器。
</span><span>    </span><span style=color:#65737e;>//访问
</span><span>    </span><span style=color:#b48ead;>int</span><span> a = a1.</span><span style=color:#bf616a;>front</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> b = a1.</span><span style=color:#bf616a;>back</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> c = a1[</span><span style=color:#d08770;>0</span><span>];
</span><span>    </span><span style=color:#b48ead;>int</span><span> d = a1.</span><span style=color:#bf616a;>at</span><span>(</span><span style=color:#d08770;>1</span><span>);
</span><span>    </span><span style=color:#b48ead;>int</span><span> e = std::</span><span style=color:#bf616a;>get</span><span><</span><span style=color:#d08770;>2</span><span>>(a1);</span><span style=color:#65737e;>//访问位置的范围有效性在编译时强制，与 at() 或 operator[] 相反
</span><span>}
</span></code></pre><h3 id=std-vector>std::vector</h3><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>//此容器是一个聚合类型,能作为聚合类型聚合初始化
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>iostream</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>vector</span><span>>
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span>(){
</span><span>    </span><span style=color:#65737e;>//初始化
</span><span>    std::vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>a1</span><span>(</span><span style=color:#d08770;>4</span><span>, </span><span style=color:#d08770;>0</span><span>);
</span><span>    std::vector<</span><span style=color:#b48ead;>int</span><span>> a2;
</span><span>    std::vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>a3</span><span>(a1.</span><span style=color:#bf616a;>begin</span><span>(), a1.</span><span style=color:#bf616a;>end</span><span>());
</span><span>    std::vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>a4</span><span>(a1);
</span><span>    </span><span style=color:#b48ead;>int</span><span> tmp[] = {</span><span style=color:#d08770;>0</span><span>, </span><span style=color:#d08770;>1</span><span>, </span><span style=color:#d08770;>2</span><span>, </span><span style=color:#d08770;>3</span><span>};
</span><span>    std::vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>a5</span><span>(tmp, tmp+sizeof(tmp)/sizeof(</span><span style=color:#b48ead;>int</span><span>));
</span><span>    std::vector<</span><span style=color:#b48ead;>int</span><span>> a6 = a1;
</span><span>    </span><span style=color:#65737e;>//访问
</span><span>    </span><span style=color:#b48ead;>int</span><span> b1 = a1[</span><span style=color:#d08770;>0</span><span>];
</span><span>    </span><span style=color:#b48ead;>int</span><span> b2 = a1.</span><span style=color:#bf616a;>at</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span><span>    </span><span style=color:#b48ead;>int</span><span> b3 = a1.</span><span style=color:#bf616a;>front</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> b4 = a1.</span><span style=color:#bf616a;>back</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> b5 = *a1.</span><span style=color:#bf616a;>data</span><span>();</span><span style=color:#65737e;>//返回指向内存中数组第一个元素的指针
</span><span>    </span><span style=color:#65737e;>//获取迭代器
</span><span>    std::vector<</span><span style=color:#b48ead;>int</span><span>>::iterator begin = a1.</span><span style=color:#bf616a;>begin</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> cbegin = a1.</span><span style=color:#bf616a;>cbegin</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> end = a1.</span><span style=color:#bf616a;>end</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> cend = a1.</span><span style=color:#bf616a;>cend</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> rbegin = a1.</span><span style=color:#bf616a;>rbegin</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> crbegin = a1.</span><span style=color:#bf616a;>crbegin</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> rend = a1.</span><span style=color:#bf616a;>rend</span><span>();
</span><span>    </span><span style=color:#b48ead;>auto</span><span> crend = a1.</span><span style=color:#bf616a;>crend</span><span>();
</span><span>    </span><span style=color:#65737e;>//容量
</span><span>    </span><span style=color:#b48ead;>bool</span><span> isEmpty = a1.</span><span style=color:#bf616a;>empty</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> size = a1.</span><span style=color:#bf616a;>size</span><span>();</span><span style=color:#65737e;>//返回容纳的元素数
</span><span>    </span><span style=color:#b48ead;>int</span><span> capacity = a1.</span><span style=color:#bf616a;>capacity</span><span>();</span><span style=color:#65737e;>//返回当前存储空间能够容纳的元素数
</span><span>    </span><span style=color:#b48ead;>int</span><span> max_size = a1.</span><span style=color:#bf616a;>max_size</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> new_cap = size * </span><span style=color:#d08770;>2</span><span>;
</span><span>    a1.</span><span style=color:#bf616a;>reserve</span><span>(new_cap);</span><span style=color:#65737e;>//增加 vector 的容量到大于或等于 new_cap 的值
</span><span>    a1.</span><span style=color:#bf616a;>shrink_to_fit</span><span>();</span><span style=color:#65737e;>//请求移除未使用的容量
</span><span>    </span><span style=color:#65737e;>//修改器
</span><span>    a1.</span><span style=color:#bf616a;>insert</span><span>(a1.</span><span style=color:#bf616a;>begin</span><span>(), </span><span style=color:#d08770;>10</span><span>);</span><span style=color:#65737e;>//在指定位置前插入
</span><span>    a1.</span><span style=color:#bf616a;>insert</span><span>(a1.</span><span style=color:#bf616a;>end</span><span>(), </span><span style=color:#d08770;>3</span><span>, </span><span style=color:#d08770;>6</span><span>);</span><span style=color:#65737e;>//插入3个6
</span><span>    a1.</span><span style=color:#bf616a;>emplace</span><span>(a1.</span><span style=color:#bf616a;>begin</span><span>(), </span><span style=color:#d08770;>11</span><span>);</span><span style=color:#65737e;>//可避免不必要的临时对象产生
</span><span>    a1.</span><span style=color:#bf616a;>erase</span><span>(a1.</span><span style=color:#bf616a;>begin</span><span>());
</span><span>    a1.</span><span style=color:#bf616a;>erase</span><span>(a1.</span><span style=color:#bf616a;>begin</span><span>(), a1.</span><span style=color:#bf616a;>begin</span><span>()+</span><span style=color:#d08770;>2</span><span>);
</span><span>    a1.</span><span style=color:#bf616a;>push_back</span><span>(</span><span style=color:#d08770;>12</span><span>);
</span><span>    a1.</span><span style=color:#bf616a;>emplace_back</span><span>(</span><span style=color:#d08770;>13</span><span>);
</span><span>    a1.</span><span style=color:#bf616a;>pop_back</span><span>();
</span><span>    a1.</span><span style=color:#bf616a;>resize</span><span>(</span><span style=color:#d08770;>32</span><span>);
</span><span>    a1.</span><span style=color:#bf616a;>resize</span><span>(</span><span style=color:#d08770;>20</span><span>, </span><span style=color:#d08770;>20</span><span>);
</span><span>    a1.</span><span style=color:#bf616a;>swap</span><span>(a2);
</span><span>    std::</span><span style=color:#bf616a;>swap</span><span>(a1, a2);
</span><span>    a1.</span><span style=color:#bf616a;>clear</span><span>();
</span><span>}
</span></code></pre><h2 id=stl-suo-yin>STL 索引</h2><h3 id=bi-jiao>比较</h3><table><thead><tr><th>容器<th>底层数据结构<th>时间复杂度<th>有无序<th>可不可重复<th>其他<tbody><tr><td>array<td>数组<td>随机读改 O(1)<td>无序<td>可重复<td>支持随机访问<tr><td>vector<td>数组<td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)<td>无序<td>可重复<td>支持随机访问<tr><td>deque<td>双端队列<td>头尾插入、头尾删除 O(1)<td>无序<td>可重复<td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问<tr><td>forward_list<td>单向链表<td>插入、删除 O(1)<td>无序<td>可重复<td>不支持随机访问<tr><td>list<td>双向链表<td>插入、删除 O(1)<td>无序<td>可重复<td>不支持随机访问<tr><td>stack<td>deque / list<td>顶部插入、顶部删除 O(1)<td>无序<td>可重复<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时<tr><td>queue<td>deque / list<td>尾部插入、头部删除 O(1)<td>无序<td>可重复<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时<tr><td>priority_queue<td>vector + max-heap<td>插入、删除 O(log2n)<td>有序<td>可重复<td>vector容器+heap处理规则<tr><td>set<td>红黑树<td>插入、删除、查找 O(log2n)<td>有序<td>不可重复<td><tr><td>multiset<td>红黑树<td>插入、删除、查找 O(log2n)<td>有序<td>可重复<td><tr><td>map<td>红黑树<td>插入、删除、查找 O(log2n)<td>有序<td>不可重复<td><tr><td>multimap<td>红黑树<td>插入、删除、查找 O(log2n)<td>有序<td>可重复<td><tr><td>unordered_set<td>哈希表<td>插入、删除、查找 O(1) 最差 O(n)<td>无序<td>不可重复<td><tr><td>unordered_multiset<td>哈希表<td>插入、删除、查找 O(1) 最差 O(n)<td>无序<td>可重复<td><tr><td>unordered_map<td>哈希表<td>插入、删除、查找 O(1) 最差 O(n)<td>无序<td>不可重复<td><tr><td>unordered_multimap<td>哈希表<td>插入、删除、查找 O(1) 最差 O(n)<td>无序<td>可重复<td></table><h3 id=array>array</h3><p>array是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。<p>在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。<p>与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。<p>零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。<p>与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。<p>数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>template </span><span>< </span><span style=color:#b48ead;>class</span><span> T, size_t N > </span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>array</span><span>;
</span></code></pre><table><thead><tr><th>方法<th>含义<tbody><tr><td>begin<td>返回指向数组容器中第一个元素的迭代器<tr><td>end<td>返回指向数组容器中最后一个元素之后的理论元素的迭代器<tr><td>rbegin<td>返回指向数组容器中最后一个元素的反向迭代器<tr><td>rend<td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素<tr><td>cbegin<td>返回指向数组容器中第一个元素的常量迭代器（const_iterator）<tr><td>cend<td>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）<tr><td>crbegin<td>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）<tr><td>crend<td>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）<tr><td>size<td>返回数组容器中元素的数量<tr><td>max_size<td>返回数组容器可容纳的最大元素数<tr><td>empty<td>返回一个布尔值，指示数组容器是否为空<tr><td>operator[]<td>返回容器中第 n（参数）个位置的元素的引用<tr><td>at<td>返回容器中第 n（参数）个位置的元素的引用<tr><td>front<td>返回对容器中第一个元素的引用<tr><td>back<td>返回对容器中最后一个元素的引用<tr><td>data<td>返回指向容器中第一个元素的指针<tr><td>fill<td>用 val（参数）填充数组所有元素<tr><td>swap<td>通过 x（参数）的内容交换数组的内容<tr><td>get（array）<td>形如 <code>std::get&LT0>(myarray)</code>；传入一个数组容器，返回指定位置元素的引用<tr><td>relational operators (array)<td>形如 <code>arrayA > arrayB</code>；依此比较数组每个元素的大小关系</table><h3 id=vector>vector</h3><p>vector 是表示可以改变大小的数组的序列容器。<p>就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。<p>在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。<p>相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。<p>因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。<p>与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。<p>针对 vector 的各种常见操作的复杂度（效率）如下：<ul><li>随机访问 - 常数 O(1)<li>在尾部增删元素 - 平摊（amortized）常数 O(1)}}<li>增删元素 - 至 vector 尾部的线性距离 O(n)}}</ul><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>template </span><span>< </span><span style=color:#b48ead;>class</span><span> T, </span><span style=color:#b48ead;>class</span><span> Alloc = allocator&LTT> > </span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>vector</span><span>;
</span></code></pre><table><thead><tr><th>方法<th>含义<tbody><tr><td>vector<td>构造函数<tr><td>~vector<td>析构函数，销毁容器对象<tr><td>operator=<td>将新内容分配给容器，替换其当前内容，并相应地修改其大小<tr><td>begin<td>返回指向容器中第一个元素的迭代器<tr><td>end<td>返回指向容器中最后一个元素之后的理论元素的迭代器<tr><td>rbegin<td>返回指向容器中最后一个元素的反向迭代器<tr><td>rend<td>返回一个反向迭代器，指向中第一个元素之前的理论元素<tr><td>cbegin<td>返回指向容器中第一个元素的常量迭代器（const_iterator）<tr><td>cend<td>返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）<tr><td>crbegin<td>返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）<tr><td>crend<td>返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）<tr><td>size<td>返回容器中元素的数量<tr><td>max_size<td>返回容器可容纳的最大元素数<tr><td>resize<td>调整容器的大小，使其包含 n（参数）个元素<tr><td>capacity<td>返回当前为 vector 分配的存储空间（容量）的大小<tr><td>empty<td>返回 vector 是否为空<tr><td>reserve<td>请求 vector 容量至少足以包含 n（参数）个元素<tr><td>shrink_to_fit<td>要求容器减小其 capacity（容量）以适应其 size（元素数量）<tr><td>operator[]<td>返回容器中第 n（参数）个位置的元素的引用<tr><td>at<td>返回容器中第 n（参数）个位置的元素的引用<tr><td>front<td>返回对容器中第一个元素的引用<tr><td>back<td>返回对容器中最后一个元素的引用<tr><td>data<td>返回指向容器中第一个元素的指针<tr><td>assign<td>将新内容分配给 vector，替换其当前内容，并相应地修改其 size<tr><td>push_back<td>在容器的最后一个元素之后添加一个新元素<tr><td>pop_back<td>删除容器中的最后一个元素，有效地将容器 size 减少一个<tr><td>insert<td>通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小<tr><td>erase<td>从 vector 中删除单个元素（<code>position</code>）或一系列元素（<code>[first，last)</code>），这有效地减少了被去除的元素的数量，从而破坏了容器的大小<tr><td>swap<td>通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象<tr><td>clear<td>从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器<tr><td>emplace<td>通过在 position（参数）位置处插入新元素 args（参数）来扩展容器<tr><td>emplace_back<td>在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后<tr><td>get_allocator<td>返回与vector关联的构造器对象的副本<tr><td>swap(vector)<td>容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同<tr><td>relational operators (vector)<td>形如 <code>vectorA > vectorB</code>；依此比较每个元素的大小关系</table><h3 id=deque>deque</h3><p>deque（['dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。<p>特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。<p>因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。<p>两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。<p>对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。<p>deque上常见操作的复杂性（效率）如下：<ul><li>随机访问 - 常数O(1)<li>在结尾或开头插入或移除元素 - 摊销不变O(1)<li>插入或移除元素 - 线性O(n)</ul><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>template </span><span>< </span><span style=color:#b48ead;>class</span><span> T, </span><span style=color:#b48ead;>class</span><span> Alloc = allocator&LTT> > </span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>deque</span><span>;
</span></code></pre><p>deque的方法和vector一样，但其压入弹出操作是双向的：<table><thead><tr><th>方法<th>含义<tbody><tr><td>push_back<td>在当前的最后一个元素之后 ，在 deque 容器的末尾添加一个新元素<tr><td>push_front<td>在 deque 容器的开始位置插入一个新的元素，位于当前的第一个元素之前<tr><td>pop_back<td>删除 deque 容器中的最后一个元素，有效地将容器大小减少一个<tr><td>pop_front<td>删除 deque 容器中的第一个元素，有效地减小其大小<tr><td>emplace_front<td>在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前<tr><td>emplace_back<td>在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</table><h3 id=forward-list>forward_list</h3><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。<p>forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表<p>之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。<p>与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。<p>的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。<p>该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。<p><strong>不支持随机访问，仅支持单向访问</strong><table><thead><tr><th>方法<th>含义<tbody><tr><td>front<td>访问第一个元素(公开成员函数)<tr><td>before_begin（cbefore_begin）<td>返回指向第一个元素之前迭代器(公开成员函数)<tr><td>begin（cbegin）<td>返回指向起始的迭代器(公开成员函数)<tr><td>end（cend）<td>返回指向末尾的迭代器(公开成员函数)<tr><td>empty<td>检查容器是否为空(公开成员函数)<tr><td>max_size<td>返回可容纳的最大元素数(公开成员函数)<tr><td>clear<td>清除内容(公开成员函数)<tr><td>insert_after<td>在某个元素后插入新元素(公开成员函数)<tr><td>emplace_after<td>在元素后原位构造元素(公开成员函数)<tr><td>erase_after<td>擦除元素后的元素(公开成员函数)<tr><td>push_front<td>插入元素到容器起始(公开成员函数)<tr><td>emplace_front<td>在容器头部就地构造元素(公开成员函数)<tr><td>pop_front<td>移除首元素(公开成员函数)<tr><td>resize<td>改变容器中可存储元素的个数(公开成员函数)<tr><td>swap<td>交换内容(公开成员函数)<tr><td>merge<td>合并二个已排序列表(公开成员函数)<tr><td>splice_after<td>从另一 forward_list 移动元素(公开成员函数)<tr><td>remove（remove_if）<td>移除满足特定标准的元素(公开成员函数)<tr><td>reverse<td>将该链表的所有元素的顺序反转(公开成员函数)<tr><td>unique<td>删除连续的重复元素(公开成员函数)<tr><td>sort<td>对元素进行排序(公开成员函数)</table><h3 id=list>list</h3><p>list，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。<p><strong>不支持随机访问，支持双向访问</strong><p><strong>支持双向压入弹出</strong><h3 id=set>set</h3><p>set 是按照特定顺序存储唯一元素的容器。<h3 id=multiset>multiset</h3><h3 id=map>map</h3><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。<p>在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>typedef</span><span> pair<</span><span style=color:#b48ead;>const</span><span> Key, T> value_type;
</span></code></pre><p>在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>template </span><span>< </span><span style=color:#b48ead;>class</span><span> Key,                                     </span><span style=color:#65737e;>// map::key_type
</span><span>           </span><span style=color:#b48ead;>class</span><span> T,                                       </span><span style=color:#65737e;>// map::mapped_type
</span><span>           </span><span style=color:#b48ead;>class</span><span> Compare = less&LTKey>,                     </span><span style=color:#65737e;>// map::key_compare
</span><span>           </span><span style=color:#b48ead;>class</span><span> Alloc = allocator&LTpair<</span><span style=color:#b48ead;>const</span><span> Key,T> >    </span><span style=color:#65737e;>// map::allocator_type
</span><span>           > </span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>map</span><span>;
</span></code></pre><table><thead><tr><th>方法<th>含义<tbody><tr><td>map<td>构造函数<tr><td>begin<td>返回引用容器中第一个元素的迭代器<tr><td>key_comp<td>返回容器用于比较键的比较对象的副本<tr><td>value_comp<td>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前<tr><td>find<td>在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器<tr><td>count<td>在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量<tr><td>lower_bound<td>返回一个非递减序列 <code>[first, last)</code>（参数）中的第一个大于等于值 val（参数）的位置的迭代器<tr><td>upper_bound<td>返回一个非递减序列 <code>[first, last)</code>（参数）中第一个大于 val（参数）的位置的迭代器<tr><td>equal_range<td>获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（<code>pair< map&LTchar,int>::iterator, map&LTchar,int>::iterator ></code>）</table><h3 id=multimap>multimap</h3><h3 id=unordered-set>unordered_set</h3><h3 id=unordered-multiset>unordered_multiset</h3><h3 id=unordered-map>unordered_map</h3><h3 id=unordered-multimap>unordered_multimap</h3><h3 id=stack>stack</h3><p>stack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。<h3 id=queue>queue</h3><p>queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。<h3 id=priority-queue>priority_queue</h3><h2 id=stl-suan-fa>STL 算法</h2><table><thead><tr><th>算法<th>底层算法<th>时间复杂度<th>可不可重复<tbody><tr><td>find<td>顺序查找<td>O(n)<td>可重复<tr><td>sort<td>内省排序<td>O(n*log2n)<td>可重复</table><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>// 简单查找算法，要求输入迭代器（input iterator）
</span><span style=color:#bf616a;>find</span><span>(beg, end, val); </span><span style=color:#65737e;>// 返回一个迭代器，指向输入序列中第一个等于 val 的元素，未找到返回 end
</span><span style=color:#bf616a;>find_if</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 返回一个迭代器，指向第一个满足 unaryPred 的元素，未找到返回 end
</span><span style=color:#bf616a;>find_if_not</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 end
</span><span style=color:#bf616a;>count</span><span>(beg, end, val); </span><span style=color:#65737e;>// 返回一个计数器，指出 val 出现了多少次
</span><span style=color:#bf616a;>count_if</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 统计有多少个元素满足 unaryPred
</span><span style=color:#bf616a;>all_of</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 返回一个 bool 值，判断是否所有元素都满足 unaryPred
</span><span style=color:#bf616a;>any_of</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPred
</span><span style=color:#bf616a;>none_of</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 返回一个 bool 值，判断是否所有元素都不满足 unaryPred
</span><span>
</span><span style=color:#65737e;>// 查找重复值的算法，传入向前迭代器（forward iterator）
</span><span style=color:#bf616a;>adjacent_find</span><span>(beg, end); </span><span style=color:#65737e;>// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end
</span><span style=color:#bf616a;>adjacent_find</span><span>(beg, end, binaryPred); </span><span style=color:#65737e;>// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end
</span><span style=color:#bf616a;>search_n</span><span>(beg, end, count, val); </span><span style=color:#65737e;>// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end
</span><span style=color:#bf616a;>search_n</span><span>(beg, end, count, val, binaryPred); </span><span style=color:#65737e;>// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end
</span><span>
</span><span style=color:#65737e;>// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器
</span><span style=color:#bf616a;>search</span><span>(beg1, end1, beg2, end2); </span><span style=color:#65737e;>// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1
</span><span style=color:#bf616a;>search</span><span>(beg1, end1, beg2, end2, binaryPred); </span><span style=color:#65737e;>// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1
</span><span style=color:#bf616a;>find_first_of</span><span>(beg1, end1, beg2, end2); </span><span style=color:#65737e;>// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1
</span><span style=color:#bf616a;>find_first_of</span><span>(beg1, end1, beg2, end2, binaryPred); </span><span style=color:#65737e;>// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1
</span><span style=color:#bf616a;>find_end</span><span>(beg1, end1, beg2, end2); </span><span style=color:#65737e;>// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1
</span><span style=color:#bf616a;>find_end</span><span>(beg1, end1, beg2, end2, binaryPred); </span><span style=color:#65737e;>// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1
</span><span>
</span><span style=color:#65737e;>// 其他只读算法，传入输入迭代器
</span><span style=color:#bf616a;>for_each</span><span>(beg, end, unaryOp); </span><span style=color:#65737e;>// 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略
</span><span style=color:#bf616a;>mismatch</span><span>(beg1, end1, beg2); </span><span style=color:#65737e;>// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素
</span><span style=color:#bf616a;>mismatch</span><span>(beg1, end1, beg2, binaryPred); </span><span style=color:#65737e;>// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素
</span><span style=color:#bf616a;>equal</span><span>(beg1, end1, beg2); </span><span style=color:#65737e;>// 比较每个元素，确定两个序列是否相等。
</span><span style=color:#bf616a;>equal</span><span>(beg1, end1, beg2, binaryPred); </span><span style=color:#65737e;>// 比较每个元素，确定两个序列是否相等。
</span><span>
</span><span style=color:#65737e;>// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（<）或 comp 比较操作实现比较。
</span><span style=color:#bf616a;>lower_bound</span><span>(beg, end, val); </span><span style=color:#65737e;>// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end
</span><span style=color:#bf616a;>lower_bound</span><span>(beg, end, val, comp); </span><span style=color:#65737e;>// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end
</span><span style=color:#bf616a;>upper_bound</span><span>(beg, end, val); </span><span style=color:#65737e;>// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end
</span><span style=color:#bf616a;>upper_bound</span><span>(beg, end, val, comp); </span><span style=color:#65737e;>// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end
</span><span style=color:#bf616a;>equal_range</span><span>(beg, end, val); </span><span style=color:#65737e;>// 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器
</span><span style=color:#bf616a;>binary_search</span><span>(beg, end, val); </span><span style=color:#65737e;>// 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。
</span><span>
</span><span style=color:#65737e;>// 只写不读算法，要求输出迭代器（output iterator）
</span><span style=color:#bf616a;>fill</span><span>(beg, end, val); </span><span style=color:#65737e;>// 将 val 赋予每个元素，返回 void
</span><span style=color:#bf616a;>fill_n</span><span>(beg, cnt, val); </span><span style=color:#65737e;>// 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器
</span><span style=color:#bf616a;>genetate</span><span>(beg, end, Gen); </span><span style=color:#65737e;>// 每次调用 Gen() 生成不同的值赋予每个序列，返回 void
</span><span style=color:#bf616a;>genetate_n</span><span>(beg, cnt, Gen); </span><span style=color:#65737e;>// 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器
</span><span>
</span><span style=color:#65737e;>// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中
</span><span style=color:#bf616a;>copy</span><span>(beg, end, dest); </span><span style=color:#65737e;>// 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列
</span><span style=color:#bf616a;>copy_if</span><span>(beg, end, dest, unaryPred); </span><span style=color:#65737e;>// 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列
</span><span style=color:#bf616a;>copy_n</span><span>(beg, n, dest); </span><span style=color:#65737e;>// 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列
</span><span style=color:#bf616a;>move</span><span>(beg, end, dest); </span><span style=color:#65737e;>// 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中
</span><span style=color:#bf616a;>transform</span><span>(beg, end, dest, unaryOp); </span><span style=color:#65737e;>// 调用给定操作（一元操作），并将结果写到dest中
</span><span style=color:#bf616a;>transform</span><span>(beg, end, beg2, dest, binaryOp); </span><span style=color:#65737e;>// 调用给定操作（二元操作），并将结果写到dest中
</span><span style=color:#bf616a;>replace_copy</span><span>(beg, end, dest, old_val, new_val); </span><span style=color:#65737e;>// 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_val
</span><span style=color:#bf616a;>replace_copy_if</span><span>(beg, end, dest, unaryPred, new_val); </span><span style=color:#65737e;>// 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_val
</span><span style=color:#bf616a;>merge</span><span>(beg1, end1, beg2, end2, dest); </span><span style=color:#65737e;>// 两个输入序列必须都是有序的，用 < 运算符将合并后的序列写入到 dest 中
</span><span style=color:#bf616a;>merge</span><span>(beg1, end1, beg2, end2, dest, comp); </span><span style=color:#65737e;>// 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中
</span><span>
</span><span style=color:#65737e;>// 使用前向迭代器的写算法，要求前向迭代器
</span><span style=color:#bf616a;>iter_swap</span><span>(iter1, iter2); </span><span style=color:#65737e;>// 交换 iter1 和 iter2 所表示的元素，返回 void
</span><span style=color:#bf616a;>swap_ranges</span><span>(beg1, end1, beg2); </span><span style=color:#65737e;>// 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。
</span><span style=color:#bf616a;>replace</span><span>(beg, end, old_val, new_val); </span><span style=color:#65737e;>// 用 new_val 替换等于 old_val 的每个匹配元素
</span><span style=color:#bf616a;>replace_if</span><span>(beg, end, unaryPred, new_val); </span><span style=color:#65737e;>// 用 new_val 替换满足 unaryPred 的每个匹配元素
</span><span>
</span><span style=color:#65737e;>// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）
</span><span style=color:#bf616a;>copy_backward</span><span>(beg, end, dest); </span><span style=color:#65737e;>// 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。
</span><span style=color:#bf616a;>move_backward</span><span>(beg, end, dest);  </span><span style=color:#65737e;>// 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。
</span><span style=color:#bf616a;>inplace_merge</span><span>(beg, mid, end); </span><span style=color:#65737e;>// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 < 比较元素。
</span><span style=color:#bf616a;>inplace_merge</span><span>(beg, mid, end, comp); </span><span style=color:#65737e;>// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。
</span><span>
</span><span style=color:#65737e;>// 划分算法，要求双向选代器（bidirectional iterator）
</span><span style=color:#bf616a;>is_partitioned</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 true
</span><span style=color:#bf616a;>partition_copy</span><span>(beg, end, dest1, dest2, unaryPred); </span><span style=color:#65737e;>// 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。
</span><span style=color:#bf616a;>partitioned_point</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 输入序列必须是已经用 unaryPred 划分过的。返回满足  unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPred
</span><span style=color:#bf616a;>stable_partition</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg
</span><span style=color:#bf616a;>partition</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg
</span><span>
</span><span style=color:#65737e;>// 排序算法，要求随机访问迭代器（random-access iterator）
</span><span style=color:#bf616a;>sort</span><span>(beg, end); </span><span style=color:#65737e;>// 排序整个范围
</span><span style=color:#bf616a;>stable_sort</span><span>(beg, end); </span><span style=color:#65737e;>// 排序整个范围（稳定排序）
</span><span style=color:#bf616a;>sort</span><span>(beg, end, comp); </span><span style=color:#65737e;>// 排序整个范围
</span><span style=color:#bf616a;>stable_sort</span><span>(beg, end, comp); </span><span style=color:#65737e;>// 排序整个范围（稳定排序）
</span><span style=color:#bf616a;>is_sorted</span><span>(beg, end); </span><span style=color:#65737e;>// 返回一个 bool 值，指出整个输入序列是否有序
</span><span style=color:#bf616a;>is_sorted</span><span>(beg, end, comp); </span><span style=color:#65737e;>// 返回一个 bool 值，指出整个输入序列是否有序
</span><span style=color:#bf616a;>is_sorted_until</span><span>(beg, end); </span><span style=color:#65737e;>// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器
</span><span style=color:#bf616a;>is_sorted_until</span><span>(beg, end, comp); </span><span style=color:#65737e;>// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器
</span><span style=color:#bf616a;>partial_sort</span><span>(beg, mid, end); </span><span style=color:#65737e;>// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置
</span><span style=color:#bf616a;>partial_sort</span><span>(beg, mid, end, comp); </span><span style=color:#65737e;>// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置
</span><span style=color:#bf616a;>partial_sort_copy</span><span>(beg, end, destBeg, destEnd); </span><span style=color:#65737e;>// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中
</span><span style=color:#bf616a;>partial_sort_copy</span><span>(beg, end, destBeg, destEnd, comp); </span><span style=color:#65737e;>// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中
</span><span style=color:#bf616a;>nth_element</span><span>(beg, nth, end); </span><span style=color:#65737e;>// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它
</span><span style=color:#bf616a;>nth_element</span><span>(beg, nth, end, comp); </span><span style=color:#65737e;>// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它
</span><span>
</span><span style=color:#65737e;>// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列
</span><span style=color:#bf616a;>remove</span><span>(beg, end, val); </span><span style=color:#65737e;>// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器
</span><span style=color:#bf616a;>remove_if</span><span>(beg, end, unaryPred); </span><span style=color:#65737e;>// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器
</span><span style=color:#bf616a;>remove_copy</span><span>(beg, end, dest, val); </span><span style=color:#65737e;>// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器
</span><span style=color:#bf616a;>remove_copy_if</span><span>(beg, end, dest, unaryPred); </span><span style=color:#65737e;>// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器
</span><span style=color:#bf616a;>unique</span><span>(beg, end); </span><span style=color:#65737e;>// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置
</span><span style=color:#bf616a;>unique </span><span>(beg, end, binaryPred); </span><span style=color:#65737e;>// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置
</span><span style=color:#bf616a;>unique_copy</span><span>(beg, end, dest); </span><span style=color:#65737e;>// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置
</span><span style=color:#bf616a;>unique_copy_if</span><span>(beg, end, dest, binaryPred); </span><span style=color:#65737e;>// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置
</span><span style=color:#bf616a;>rotate</span><span>(beg, mid, end); </span><span style=color:#65737e;>// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素
</span><span style=color:#bf616a;>rotate_copy</span><span>(beg, mid, end, dest); </span><span style=color:#65737e;>// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素
</span><span>
</span><span style=color:#65737e;>// 使用双向迭代器的重排算法
</span><span style=color:#bf616a;>reverse</span><span>(beg, end); </span><span style=color:#65737e;>// 翻转序列中的元素，返回 void
</span><span style=color:#bf616a;>reverse_copy</span><span>(beg, end, dest);; </span><span style=color:#65737e;>// 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置
</span><span>
</span><span style=color:#65737e;>// 使用随机访问迭代器的重排算法
</span><span style=color:#bf616a;>random_shuffle</span><span>(beg, end); </span><span style=color:#65737e;>// 混洗输入序列中的元素，返回 void
</span><span style=color:#bf616a;>random_shuffle</span><span>(beg, end, rand); </span><span style=color:#65737e;>// 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 void
</span><span style=color:#bf616a;>shuffle</span><span>(beg, end, Uniform_rand); </span><span style=color:#65737e;>// 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void
</span><span>
</span><span style=color:#65737e;>// 最小值和最大值，使用 < 运算符或给定的比较操作 comp 进行比较
</span><span style=color:#bf616a;>min</span><span>(val1, va12); </span><span style=color:#65737e;>// 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略
</span><span style=color:#bf616a;>min</span><span>(val1, val2, comp);
</span><span style=color:#bf616a;>min</span><span>(init_list);
</span><span style=color:#bf616a;>min</span><span>(init_list, comp);
</span><span style=color:#bf616a;>max</span><span>(val1, val2);
</span><span style=color:#bf616a;>max</span><span>(val1, val2, comp);
</span><span style=color:#bf616a;>max</span><span>(init_list);
</span><span style=color:#bf616a;>max</span><span>(init_list, comp);
</span><span style=color:#bf616a;>minmax</span><span>(val1, val2); </span><span style=color:#65737e;>// 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略
</span><span style=color:#bf616a;>minmax</span><span>(vall, val2, comp);
</span><span style=color:#bf616a;>minmax</span><span>(init_list);
</span><span style=color:#bf616a;>minmax</span><span>(init_list, comp);
</span><span style=color:#bf616a;>min_element</span><span>(beg, end); </span><span style=color:#65737e;>// 返回指向输入序列中最小元素的迭代器
</span><span style=color:#bf616a;>min_element</span><span>(beg, end, comp); </span><span style=color:#65737e;>// 返回指向输入序列中最小元素的迭代器
</span><span style=color:#bf616a;>max_element</span><span>(beg, end); </span><span style=color:#65737e;>// 返回指向输入序列中最大元素的迭代器
</span><span style=color:#bf616a;>max_element</span><span>(beg, end, comp); </span><span style=color:#65737e;>// 返回指向输入序列中最大元素的迭代器
</span><span style=color:#bf616a;>minmax_element</span><span>(beg, end); </span><span style=color:#65737e;>// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素
</span><span style=color:#bf616a;>minmax_element</span><span>(beg, end, comp); </span><span style=color:#65737e;>// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素
</span><span>
</span><span style=color:#65737e;>// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。
</span><span style=color:#bf616a;>lexicographical_compare</span><span>(beg1, end1, beg2, end2);
</span><span style=color:#bf616a;>lexicographical_compare</span><span>(beg1, end1, beg2, end2, comp);
</span></code></pre><h2 id=qi-ta>其它</h2><h3 id=tuple>tuple</h3><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。<p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>template &LTclass... Types> class tuple;
</span></code></pre><p>Example<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#include &LTiostream>     // std::cout
</span><span>#include &LTtuple>        // std::tuple, std::get, std::tie, std::ignore
</span><span>
</span><span>int main ()
</span><span>{
</span><span>  std::tuple&LTint,char> foo (10,'x');
</span><span>  auto bar = std::make_tuple ("test", 3.1, 14, 'y');
</span><span>
</span><span>  std::get&LT2>(bar) = 100;                                    // access element
</span><span>
</span><span>  int myint; char mychar;
</span><span>
</span><span>  std::tie (myint, mychar) = foo;                            // unpack elements
</span><span>  std::tie (std::ignore, std::ignore, myint, mychar) = bar;  // unpack (with ignore)
</span><span>
</span><span>  mychar = std::get&LT3>(bar);
</span><span>
</span><span>  std::get&LT0>(foo) = std::get&LT2>(bar);
</span><span>  std::get&LT1>(foo) = mychar;
</span><span>
</span><span>  std::cout << "foo contains: ";
</span><span>  std::cout << std::get&LT0>(foo) << ' ';
</span><span>  std::cout << std::get&LT1>(foo) << '\n';
</span><span>
</span><span>  return 0;
</span><span>}
</span></code></pre><p>Output<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>foo contains: 100 y
</span></code></pre><h4></h4><h4 id=tuple-tuple>tuple::tuple</h4><p>构建一个 tuple（元组）对象。<p>这涉及单独构建其元素，初始化取决于调用的构造函数形式：<p>（1）默认的构造函数<p>构建一个 元组对象的元素值初始化。<p>（2）复制/移动构造函数<p>该对象使用tpl的内容进行初始化 元组目的。tpl 的相应元素被传递给每个元素的构造函数。<p>（3）隐式转换构造函数<p>同上。tpl中的 所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。<p>（4）初始化构造函数 用elems中的相应元素初始化每个元素。elems 的相应元素被传递给每个元素的构造函数。<p>（5）对转换构造函数<p>该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。<p>（6）分配器版本<p>和上面的版本一样，除了每个元素都是使用allocator alloc构造的。<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>default (1)	
</span><span>constexpr tuple();
</span><span>copy / move (2)	
</span><span>tuple (const tuple& tpl) = default;
</span><span>tuple (tuple&& tpl) = default;
</span><span>implicit conversion (3)	
</span><span>template &LTclass... UTypes>
</span><span>  tuple (const tuple&LTUTypes...>& tpl);
</span><span>template &LTclass... UTypes>
</span><span>  tuple (tuple&LTUTypes...>&& tpl);
</span><span>initialization (4)	
</span><span>explicit tuple (const Types&... elems);
</span><span>template &LTclass... UTypes>
</span><span>  explicit tuple (UTypes&&... elems);
</span><span>conversion from pair (5)	
</span><span>template &LTclass U1, class U2>
</span><span>  tuple (const pair&LTU1,U2>& pr);
</span><span>template &LTclass U1, class U2>
</span><span>  tuple (pair&LTU1,U2>&& pr);
</span><span>allocator (6)	
</span><span>template&LTclass Alloc>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc);
</span><span>template&LTclass Alloc>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc, const tuple& tpl);
</span><span>template&LTclass Alloc>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc, tuple&& tpl);
</span><span>template&LTclass Alloc,class... UTypes>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc, const tuple&LTUTypes...>& tpl);
</span><span>template&LTclass Alloc, class... UTypes>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc, tuple&LTUTypes...>&& tpl);
</span><span>template&LTclass Alloc>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc, const Types&... elems);
</span><span>template&LTclass Alloc, class... UTypes>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc, UTypes&&... elems);
</span><span>template&LTclass Alloc, class U1, class U2>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc, const pair&LTU1,U2>& pr);
</span><span>template&LTclass Alloc, class U1, class U2>
</span><span>  tuple (allocator_arg_t aa, const Alloc& alloc, pair&LTU1,U2>&& pr);
</span></code></pre><p>Example<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#include &LTiostream>     // std::cout
</span><span>#include &LTutility>      // std::make_pair
</span><span>#include &LTtuple>        // std::tuple, std::make_tuple, std::get
</span><span>
</span><span>int main ()
</span><span>{
</span><span>  std::tuple&LTint,char> first;                             // default
</span><span>  std::tuple&LTint,char> second (first);                    // copy
</span><span>  std::tuple&LTint,char> third (std::make_tuple(20,'b'));   // move
</span><span>  std::tuple&LTlong,char> fourth (third);                   // implicit conversion
</span><span>  std::tuple&LTint,char> fifth (10,'a');                    // initialization
</span><span>  std::tuple&LTint,char> sixth (std::make_pair(30,'c'));    // from pair / move
</span><span>
</span><span>  std::cout << "sixth contains: " << std::get&LT0>(sixth);
</span><span>  std::cout << " and " << std::get&LT1>(sixth) << '\n';
</span><span>
</span><span>  return 0;
</span><span>}
</span></code></pre><p>Output<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>sixth contains: 30 and c
</span></code></pre><h3 id=pair>pair</h3><p>这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。<p>pair是tuple（元组）的一个特例。<p>pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。<p>应用：<ul><li>可以将两个类型数据组合成一个如map&LTkey, value><li>当某个函数需要两个返回值时</ul><pre style=background-color:#2b303b;color:#c0c5ce;><code><span>template &LTclass T1, class T2> struct pair;
</span></code></pre><h4 id=-1></h4><h4 id=pair-pair>pair::pair</h4><p>构建一个pair对象。<p>这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式：<p>（1）默认的构造函数<p>构建一个 对对象的元素值初始化。<p>（2）复制/移动构造函数（和隐式转换）<p>该对象被初始化为pr的内容 对目的。pr 的相应成员被传递给每个成员的构造函数。<p>（3）初始化构造函数<p>会员 第一是由一个和成员构建的第二与b。<p>（4）分段构造<p>构造成员 first 和 second 到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>default (1)	
</span><span>constexpr pair();
</span><span>copy / move (2)	
</span><span>template&LTclass U, class V> pair (const pair&LTU,V>& pr);
</span><span>template&LTclass U, class V> pair (pair&LTU,V>&& pr);
</span><span>pair (const pair& pr) = default;
</span><span>pair (pair&& pr) = default;
</span><span>initialization (3)	
</span><span>pair (const first_type& a, const second_type& b);
</span><span>template&LTclass U, class V> pair (U&& a, V&& b);
</span><span>piecewise (4)	
</span><span>template &LTclass... Args1, class... Args2>
</span><span>  pair (piecewise_construct_t pwc, tuple&LTArgs1...> first_args,
</span><span>                                   tuple&LTArgs2...> second_args);
</span></code></pre><p>Example<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>#include &LTutility>      // std::pair, std::make_pair
</span><span>#include &LTstring>       // std::string
</span><span>#include &LTiostream>     // std::cout
</span><span>
</span><span>int main () {
</span><span>  std::pair &LTstd::string,double> product1;                     // default constructor
</span><span>  std::pair &LTstd::string,double> product2 ("tomatoes",2.30);   // value init
</span><span>  std::pair &LTstd::string,double> product3 (product2);          // copy constructor
</span><span>
</span><span>  product1 = std::make_pair(std::string("lightbulbs"),0.99);   // using make_pair (move)
</span><span>
</span><span>  product2.first = "shoes";                  // the type of first is string
</span><span>  product2.second = 39.90;                   // the type of second is double
</span><span>
</span><span>  std::cout << "The price of " << product1.first << " is $" << product1.second << '\n';
</span><span>  std::cout << "The price of " << product2.first << " is $" << product2.second << '\n';
</span><span>  std::cout << "The price of " << product3.first << " is $" << product3.second << '\n';
</span><span>  return 0;
</span><span>}
</span></code></pre><p>Output<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>The price of lightbulbs is $0.99
</span><span>The price of shoes is $39.9
</span><span>The price of tomatoes is $2.3
</span></code></pre></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>