<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/计算机网络/di-5zhang-yun-shu-ceng/">第5章 运输层</a></h1><div class=post-meta-inline><span class=post-date> 2018-07-24 </span></div><div class=post-content><p>运输层：<ul><li>运输层为相互通信的应用进程提供逻辑通信<li>端口和套接字的意义<li>无连接的UDP的特点<li>面向连接的TCP的特定<li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议<li>TCP的滑动窗口、流量控制、拥塞控制和连接管理</ul><h2 id=yun-shu-ceng-xie-yi-gai-shu>运输层协议概述</h2><p>运输层向上面的应用层提供通信服务。当网络的边缘部分的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。<p>两台主机进行通信就是两台主机中的应用进程互相通信，通信的真正端点并不是主机而是主机中的进程。<p><img alt=image-20201029205358115 src=image-20201029205358115.png><p><strong>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信</strong>。<p><img alt=image-20201029210330272 src=image-20201029210330272.png><p>运输层还要对收到的报文进行<strong>差错检测</strong>。<p>TCP/IP运输层的两个主要协议都是互联网的正式标准：<ul><li>用户数据报协议UDP<li>传输控制协议TCP</ul><p><img alt=image-20201029210344256 src=image-20201029210344256.png><p>两个对等运输实体在通信时传送的数据单元叫做<strong>运输协议数据单元TPDU</strong>。但在TCP/IP体系中，根据所使用的协议是TCP或UDP，分别称之为<strong>TCP报文段</strong>或<strong>UDP用户数据报</strong>。<p><img alt=image-20201029211216165 src=image-20201029211216165.png><p>运输层的复用和分用：<ul><li><strong>复用</strong>：应用层所有的应用进程都可以通过运输层再传送到IP层（网络层）<li><strong>分用</strong>：运输层从IP层收到发送给各应用进程的数据后，必须分别交付指明的各应用进程</ul><p><strong>硬件端口</strong>是不同硬件设备进行交互的接口，<strong>软件端口</strong>是应用层的各种协议进程与运输实体进行层间交互的一种地址。<p>TCP/IP的运输层用一个16位<strong>端口号</strong>来标志一个端口，端口号只有<strong>本地意义</strong>，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。<p>运输层的端口号分为两大类：<ul><li><p>服务器端使用的端口号</p> <ul><li>熟知端口号：又称系统端口号，数值为0~1023，由IANA为应用程序指派<li>登记端口号：数值为1024~49151，使用时要在IANA按照规定的手续登记，防止重复</ul> <p><img alt=image-20201029212820764 src=image-20201029212820764.png></p><li><p>客户端使用的端口号：又称为短暂端口号，数值为49152~65535</p></ul><h2 id=yong-hu-shu-ju-bao-xie-yi-udp>用户数据报协议UDP</h2><p>UDP的主要特点是：<ul><li><p>UDP是无连接的</p><li><p>UDP使用尽最大努力交付</p><li><p>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p> <p><img alt=image-20201029225417038 src=image-20201029225417038.png></p><li><p>UDP没有拥塞控制</p><li><p>UDP支持一对一、一对多、多对一和多对多的交互通信</p><li><p>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短</p></ul><p>用户数据报UDP有两个字段：<ul><li>数据字段<li>首部字段：8个字节，由四个字段组成，每个字段2个字节： <ul><li>源端口：源端口号。在需要对方回信时选用。不需要时可用全0<li>目的端口：目的端口号。这在终点交付报文时必须使用<li>长度：UDP用户数据报的长度，其最小值是8（仅有首部）<li>检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃</ul></ul><p><img alt=image-20201029225431486 src=image-20201029225431486.png><p>当运输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点——应用进程。<p><img alt=image-20201029225656203 src=image-20201029225656203.png><p>如果接收方UDP发现收到的报文中的目的端口号不正确，就丢弃该报文，并由网际控制报文协议ICMP发送“端口不可达”差错报文给发送方。<p>UDP用户数据报在计算检验和时，要在UDP用户数据报之前增加12个字节的<strong>伪首部</strong>，这是在计算检验和时临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，仅仅是为了计算检验和。<p>IP数据报的检验和只检验IP数据报的首部，但UDP的检验和是把首部和数据部分一起都检验。<h2 id=chuan-shu-kong-zhi-xie-yi-tcpgai-shu>传输控制协议TCP概述</h2><p>TCP最主要的特点：<ul><li>TCP是面向连接的传输层协议<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）<li>TCP提供可靠交付的服务<li>TCP提供全双工通信<li>面向字节流。TCP中的“流”指的是流入到进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构字节流。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</ul><p><img alt=image-20201030172956309 src=image-20201030172956309.png><p>TCP连接是一条<strong>虚连接</strong>（也就是逻辑连接），而不是一条真正的物理连接。<p>TCP并不关心应用程序一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送的报文长度是应用程序给出的）。<p>TCP把连接作为最基本的抽象，每一条TCP连接有两个端点，TCP连接的端点叫做<strong>套接字</strong>或<strong>插口</strong>，端口号拼接到IP地址即构成了套接字：<code>套接字socket = (IP地址:端口号)</code>。<p>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定，即：<p><code>TCP连接 ::= {socket1, socket2} = {(IP1:port1),(IP2:port2)}</code><h2 id=ke-kao-chuan-shu-de-gong-zuo-yuan-li>可靠传输的工作原理</h2><p>TCP发送的报文段是交给IP层传送的，但IP层只能提供尽最大努力服务，即TCP下面的网络所提供的是不可靠的传输。TCP必须采用适当的措施才能使得两个传输层之间的通信变得可靠。<h2 id=ting-zhi-deng-dai-xie-yi>停止等待协议</h2><p><img alt=image-20201031143215751 src=image-20201031143215751.png><p>可靠传输协议的设计：A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发过的分组，即超时重传。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。<p>需要注意三点：<ol><li>A在发送完一个分组后，必须暂时保留已发送的分组的副本<li>分组和确认分组都必须进行编号<li>超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些</ol><p><img alt=image-20201031143634601 src=image-20201031143634601.png><p>确认丢失时：<ol><li>丢弃这个重复的分组M1，不向上层交付<li>向A发送确认</ol><p>确认和重传机制，使得可以在不可靠的传输网络上实现可靠的通信。<p>可靠传输协议常称为<strong>自动重传请求ARQ</strong>：重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。<p><img alt=image-20201031144151737 src=image-20201031144151737.png><p>$信道利用率U = {T_D \over T_D + RTT + T_A}$<p><img alt=image-20201031144206600 src=image-20201031144206600.png><h2 id=lian-xu-arqxie-yi>连续ARQ协议</h2><p><img alt=image-20201031144747565 src=image-20201031144747565.png><p>连续ARQ协议规定：发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。图中原来已经发送了前5个分组，那么现在可以发送第6个分组了。<p>接收方一般采用<strong>累积确认</strong>的方式：接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，<strong>对按序到达的最后一个分组发送确认</strong>，表示到这个分组为止的所有分组都已正确收到了。<p>累积确认：<ul><li>优点：容易实现，即使确认丢失也不必重传。<li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</ul><h2 id=tcpbao-wen-duan-de-shou-bu-ge-shi>TCP报文段的首部格式</h2><p>TCP是面向字节流的，但是TCP传送的数据单元却是报文段。TCP首部的固定长度（最小长度）是20字节，整个首部的长度是4字节的整数倍。<p><img alt=image-20201031150431371 src=image-20201031150431371.png><h2 id=tcpke-kao-chuan-shu-de-shi-xian>TCP可靠传输的实现</h2><p>TCP的滑动窗口是以字节为单位的。<p><img alt=image-20201031153801209 src=image-20201031153801209.png><p>发送窗口的位置由窗口的前沿和后沿的位置共同确定：<ul><li>发送窗口的后沿的变化情况有两种： <ul><li>不动：没有收到新的确认<li>前移：收到了新的确认</ul><li>发送窗口的的前沿： <ul><li>通常是不断向前移动：没有收到新的确认，对方通知的窗口大小也不变<li>也有可能不动：收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动<li>可能向后收缩：发生在对方通知的窗口缩小了。但TCP的标准强烈不赞成这样做。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。</ul></ul><p><img alt=image-20201031155704324 src=image-20201031155704324.png><p>发送方的应用进程把字节流写入TCP的发送缓存，接收方的应用程序从TCP的接收缓存中读取字节流。<p>发送缓存用来暂时存放：<ul><li>发送应用程序传送给发送方TCP准备发送的数据<li>TCP已发送出但尚未收到确认的数据</ul><p>发送窗口通常只是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。<p>接收缓存用来暂时存放：<ul><li>按序到达的、但尚未被接收应用程序读取的数据<li>未按序到达的数据</ul><p>TCP的发送窗口是根据接收窗口设置的，但同一时刻，发送窗口不总是和接收窗口一样大：<ul><li>通过网络传送窗口值需要经历一定的时间滞后<li>发送方可能根据网络当时的拥塞情况适当减小自己的发送窗口数值</ul><p>TCP标准对不按序到达的数据并无明确规定：<ul><li>如果接收方把不按序到达是数据一律丢弃，则接收窗口的管理会比较简单，但是对网络资源的利用不利<li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</ul><p>TCP要求接收方必须有累积确认的功能，这样可以减少开销：<ul><li>可以在合适的时候发送确认，但不应该过分推迟发送确认<li>可以在自己有数据要发送是把确认信息顺便捎带上，该情况实际并不经常发生，因为大多数应用程序很少同时在两个方向上发生数据</ul><p>TCP的通信是全双工通信，通信中的每一方都在发送和接收报文段，每一方都有自己的发送窗口和接收窗口。<p>运输层的超时计时器的超时重传时间设置：<ul><li>报文段的往返时间$RTT$<li>加权平均往返时间$RTT_S$： <ul><li>第一次：$RTT_S = RTT样本值$<li>$新的RTT_S = (1-\alpha)\times(旧的RTT_S)+\alpha\times(新的RTT_S样本)$，（$0\le\alpha\lt1$，RFC 6298推荐为$\alpha = {1 \over 8}$，即0.125）</ul><li>超时计时器设置的<strong>超时重传时间RTO</strong>：$RTO = RTT_S + 4\times RTT_D$<li>$RTT_D$是RTT的偏差的加权平均值： <ul><li>第一次测量时，为测量到的RTT样本值的一半<li>$新的RTT_D = (1-\beta)\times(旧的RTT_D)+\beta \times|RTT_S - 新的RTT样本|$，$\beta$小于1，推荐值是0.25</ul><li>Karn算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返时间的估测，使计算结果更加合理。Karn算法：在计算加权平均$RTT_S$时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均$RTT_S$和RTO就较准确；且，报文段每重传一次，就把RTO增大一些，典型的做法是增大为原来的2倍。</ul><p>当接收方接受到不连续的字节块时，可使用选择确认SACK，此时在建立连接时要在TCP首部的选项中加上“允许SACK”的选项。由于首部选项的长度最多只有40字节，而指明一个边界要用4字节（因为序号有32位），因此在选项中最多只能指明4个字节块的边界信息（8个边界），共用了32字节，另外需要1个字节指明是SACK选项，1个字节指明这个选项占用多少字节。<p>SACK文档并没有指明发送方应当怎样响应SACK，因此大多数的实现还是重传所有未被确认的数据块。<h2 id=tcpde-liu-liang-kong-zhi>TCP的流量控制</h2><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。<p><img alt=image-20201031203010356 src=image-20201031203010356.png><p>发送方的发送窗口不能超过接收方给出的接收窗口的数值。<p>TCP的窗口单位是字节，不是报文段。<p>TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值，如果窗口值仍然是零，则重新设置持续计时器。<h2 id=tcpde-yong-sai-kong-zhi>TCP的拥塞控制</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况叫做<strong>拥塞</strong>。<p>所谓<strong>拥塞控制</strong>就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。<p>拥塞控制的前提是：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，设计到所有的主机、所有的路由器，以及降低网络传输性能有关的所有因素。<p>相反，<strong>流量控制</strong>往往是指点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<p><img alt=image-20201031213929383 src=image-20201031213929383.png><p>拥塞控制的两大方面：<ul><li>开环控制：设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正了。<li>闭环控制：基于反馈环路的概念，主要有几种措施： <ul><li>监测网络系统以便检测到拥塞在何时、何处发生<li>把拥塞发生的信息传送到可采取行动的地方<li>调整网络系统的运行以解决出现的问题</ul></ul><p><strong>TCP进行拥塞控制的算法有四种：</strong><ul><li>慢开始<li>拥塞避免<li>快重传<li>快恢复</ul><p>发送方维持一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。当接收方总是有足够大的缓存空间时，发送方让自己的发送窗口等于拥塞窗口。<p>判断网络拥塞的依据就是出现了超时。<p><img alt=image-20201101170414504 src=image-20201101170414504.png><p>相关变量：（<strong>用报文段的个数作为窗口大小的单位</strong>）<ul><li>cwnd：拥塞窗口大小<li>SMSS：发送方的最大报文段<li>ssthresh：慢开始门限，用来防止cwnd增长过大引起网络拥塞 <ul><li>当$cwnd \lt ssthresh$，使用慢开始算法<li>当$cwnd \gt ssthresh$，停止使用慢开始算法而改用拥塞避免算法<li>当$cwnd = ssthresh$，既可使用慢开始算法，也可使用拥塞避免算法</ul><li>传输轮次：一个传输轮次所经历的时间其实就是往返时间RTT。强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</ul><p>慢开始算法：每经过一个传输轮次，拥塞窗口cwnd就加倍。<p>拥塞避免算法：每经过一个传输轮次，拥塞窗口cwnd就加一。拥塞避免并非完全能够避免了拥塞，是说把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。<p>快重传算法可以让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要求对方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。<p><img alt=image-20201101171524869 src=image-20201101171524869.png><p>发送方知道只是丢失了个别的报文段时，不启动慢开始，而是执行<strong>快恢复</strong>算法：<ul><li>ssthresh = cwnd/2<li>cwnd = ssthresh<li>执行拥塞避免算法</ul><p>在拥塞避免阶段，拥塞窗口是按照线性规律增大的，常称为<strong>加法增大AI</strong>。<p>一旦出现超时或3个重复确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值，常称为<strong>乘法减小MD</strong>。<p>二者合一起就是<strong>AIMD</strong>算法。<p><img alt=image-20201101171933600 src=image-20201101171933600.png><p>接收方根据自己的接收能力设定了接收方窗口rwnd，并把该窗口值写入TCP首部中的窗口字段，传给发送方。接收方窗口又称为通知窗口。<p>发送方的发送窗口一定不能够超过对方给出的接收方窗口值rwnd，则：</p><center>发送方窗口的上限值=Min[rwnd, cwnd]</center><ul><li>当$rwnd \lt cwnd$：接收方的接收能力限制发送方窗口的最大值<li>当$rwnd \gt cwnd$：网络的拥塞程度限制发送方窗口的最大值<li>rwnd和cwnd中数值较小的一个，控制了发送方发送数据的速率</ul><p>网络层的策略对TCP拥塞控制影响最大的就是路由器的分组丢弃策略。最简单的情况下是使用<strong>尾部丢弃策略</strong>，路由器的尾部丢弃往往会导致一连串的分组丢失，使发送方出现超时重传，使TCP进入慢开始状态，尾部丢弃可能同时影响很多条TCP连接，使很多TCP连接在同一时间突然都进入慢开始状态，这在TCP术语中称为<strong>全局同步</strong>。全局同步使得全网的通信量突然下降很多，而在网络恢复后，其通信量又突然增大很多。<p>为了避免网络中的全局同步现象，提出了<strong>主动队列管理AQM</strong>，AQM早期的实现方案是<strong>随机早期检测RED</strong>。<h2 id=tcpde-yun-shu-lian-jie-guan-li>TCP的运输连接管理</h2><p>TCP是面向连接的协议。运输连接是用来传送TCP报文的。TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。<p>运输连接有三个阶段：连接建立、数据传送、连接释放<p>运输连接的管理就是使运输连接的建立和释放都能正常进行。<p>TCP连接的建立采用客户服务器模式：<ul><li>主动发起连接建立的应用进程叫做<strong>客户</strong><li>被动等待连接建立的应用进程叫做<strong>服务器</strong></ul><p><img alt=image-20201101213840232 src=image-20201101213840232.png><p><img alt=image-20201101214333994 src=image-20201101214333994.png><p><img alt=image-20201101214351953 src=image-20201101214351953.png><p>建立TCP连接时，A最后要发送一次确认，主要是为了防止已失效的连接请求报文段突然又传到了B，因而产生错误。<p>释放TCP连接时，A要经历<code>2MSL</code>时间的<code>TIME-WAIT</code>状态，理由是：<ul><li>为了保证A发送的最后一个ACK报文段能够到达B<li>防止已失效的连接请求报文段出现在本连接中，防止本连接的报文段被下一次TCP连接所接收</ul></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>