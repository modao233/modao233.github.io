<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/CppPrimer/cppprimer-di-5zhang/">C++ Primer 第5章 语句</a></h1><div class=post-meta-inline><span class=post-date> 2018-06-15 </span></div><div class=post-content><p>和大多数语言一样，C++提供了条件执行语句、重复执行相同代码的循环语句和用于中断当前控制流的跳转语句。本章将详细介绍C++所支持的这些语句。<h2 id=5-1-jian-dan-yu-ju>5.1 简单语句</h2><p>C++大多数语句以分号结束。<p>表达式末尾加上分号就变成了<strong>表达式语句</strong>：执行表达式并丢弃掉求值结果。<p>最简单的语句是<strong>空语句</strong>：空语句中只含有一个单独的分号，语法需要但是逻辑上不需要的时候可使用。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>ival + </span><span style=color:#d08770;>5</span><span>;		</span><span style=color:#65737e;>//表达式语句</span><span style=color:#65737e;>
</span><span>cout << ival;</span><span>
</span><span>
</span><span>;	</span><span style=color:#65737e;>//空语句</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>while</span><span>(cin >> s && s != sought)</span><span>
</span><span>    ;	</span><span style=color:#65737e;>//空语句</span><span style=color:#65737e;>
</span><span>
</span><span style=color:#65737e;>//空语句一般是无害的</span><span style=color:#65737e;>
</span><span>ival = v1 + v2;;	</span><span style=color:#65737e;>//正确，第二个分号表示一条多余的空语句</span><span style=color:#65737e;>
</span><span style=color:#65737e;>//空语句并非总是无害的</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>while</span><span>(iter != svec.</span><span style=color:#bf616a;>end</span><span>());	</span><span style=color:#65737e;>//while循环主体是空语句</span><span style=color:#65737e;>
</span><span>	++iter;					</span><span style=color:#65737e;>//不属于循环的一部分</span><span style=color:#65737e;>
</span></code></pre><p><strong>空语句使用时应该加上注释，使读代码的人知道该语句是有意省略的</strong>。<p><strong>复合语句</strong>是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作<strong>块（block）</strong>。一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。<p>如果语法上需要一条语句，而逻辑上需要多条语句，则应该使用复合语句。块不以分号结束。<p>空块是指内部没有任何语句的一对花括号，空块的作用等价于空语句。<h2 id=5-2-yu-ju-zuo-yong-yu>5.2 语句作用域</h2><p>可以在if、switch、while和for语句的<strong>控制结构内</strong>定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量就超出作用范围。<h2 id=5-3-tiao-jian-yu-ju>5.3 条件语句</h2><h3 id=5-3-1-ifyu-ju>5.3.1 if语句</h3><p>if语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。if语句有两种形式：一种含有else分支，另外一种没有。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>if </span><span>(condition)</span><span>
</span><span>    statement</span><span>
</span><span>    </span><span>
</span><span style=color:#b48ead;>if </span><span>(condition)</span><span>
</span><span>    statement</span><span>
</span><span style=color:#b48ead;>else</span><span>
</span><span>    statement2</span><span>
</span><span>    </span><span>
</span><span style=color:#b48ead;>if </span><span>(condition)</span><span>
</span><span>    statement</span><span>
</span><span style=color:#b48ead;>else if</span><span>(condition2)</span><span>
</span><span>    statement2</span><span>
</span></code></pre><p>当if分支多于else分支时，else与if语句如何匹配，这个问题通常称作<strong>悬垂else</strong>。C++规定else与离它最近的尚未匹配的if匹配，消除了程序的二义性。<p>对if或else之后写上花括号，可以避免代码混乱不清，也便于维护。使用花括号可以控制else的匹配if。<h3 id=5-3-2-switchyu-ju>5.3.2 switch语句</h3><p>switch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。<p>case关键字和它对应的值一起被称为<strong>case标签</strong>。case标签必须是<strong>整型常量表达式</strong>。任何两个case标签的值不能相同，否则会引发错误，另外，default也是一种特殊的case标签。<p>如果某个case标签匹配成功了，将从该标签开始往后顺序执行所以case分支，除非显示中断这一过程，否则直到switch结尾才停下来。大多数情况下，在下一个case标签之前应有一条break语句。有时候我们需要多个case共享同一组操作，就可以故意省略break语句。C++形式比较自由，case标签之后不一定非得换行。<p>如果没有一个case标签匹配switch表达式的值，程序将执行紧跟在default标签后的语句。<p>即使不准备在default标签下做任何工作，定义一个default标签也是有用的。其目的在于告诉程序的读者，我们已经考虑了默认的情况，只是目前什么也没做。<p>标签不应该单独出现，它后面必须跟上<strong>一条语句或者另外一个case标签</strong>。如果switch结构以一个空的default标签作为结束，则该default标签后面必须跟上一条空语句或一个空块。<p>switch内部的变量定义：C++不允许跨过变量的初始化语句直接跳转到该变量的作用域内的另一个位置。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>case </span><span style=color:#d08770;>true</span><span>:</span><span>
</span><span>	</span><span style=color:#65737e;>//变量作用域是switch之内</span><span style=color:#65737e;>
</span><span>	string file_name;	</span><span style=color:#65737e;>//错误：控制流绕过了一个隐式初始化的变量</span><span style=color:#65737e;>
</span><span>	</span><span style=color:#b48ead;>int</span><span> ival = </span><span style=color:#d08770;>0</span><span>;		</span><span style=color:#65737e;>//错误：控制了绕过了一个显示初始化的变量</span><span style=color:#65737e;>
</span><span>	</span><span style=color:#b48ead;>int</span><span> jval;			</span><span style=color:#65737e;>//正确：因为jval没有初始化</span><span style=color:#65737e;>
</span><span>	</span><span style=color:#b48ead;>break</span><span>;</span><span>
</span><span style=color:#b48ead;>case </span><span style=color:#d08770;>false</span><span>:</span><span>
</span><span>	</span><span style=color:#65737e;>//正确：jval虽然在作用域内，但是它没有被初始化</span><span style=color:#65737e;>
</span><span>	jval = </span><span style=color:#bf616a;>next_num</span><span>();	</span><span style=color:#65737e;>//正确：给jval赋一个值</span><span style=color:#65737e;>
</span><span>	</span><span style=color:#b48ead;>if </span><span>(file_name.</span><span style=color:#bf616a;>empty</span><span>())	</span><span style=color:#65737e;>//file_name在作用域内，但是没有被初始化</span><span style=color:#65737e;>
</span><span>		</span><span style=color:#65737e;>//...</span><span style=color:#65737e;>
</span></code></pre><p>如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。<p>如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面所有的case标签都在变量的作用域之外。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>case </span><span style=color:#d08770;>true</span><span>:</span><span>
</span><span>	{</span><span>
</span><span>        </span><span style=color:#65737e;>//正确：声明语句位于语句块内部</span><span style=color:#65737e;>
</span><span>    	string file_name = </span><span style=color:#bf616a;>get_file_name</span><span>();</span><span>
</span><span>	}</span><span>
</span><span>	</span><span style=color:#b48ead;>break</span><span>;</span><span>
</span><span style=color:#b48ead;>case </span><span style=color:#d08770;>false</span><span>:</span><span>
</span><span>	</span><span style=color:#b48ead;>if</span><span>(file_name.</span><span style=color:#bf616a;>empty</span><span>());	</span><span style=color:#65737e;>//错误：file_name不在作用域之内</span><span style=color:#65737e;>
</span></code></pre><h2 id=5-4-die-dai-yu-ju>5.4 迭代语句</h2><h3 id=5-4-1-whileyu-ju>5.4.1 while语句</h3><p>只要条件为真，<strong>while</strong>语句就重复地执行循环体。while的条件部分可以是一个表达式或者是一个带初始化的变量声明，通常来说，应该由条件本身或者循环体设法改变表达式的值，否则循环无法终止。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>while</span><span>(condition)</span><span>
</span><span>    statement</span><span>
</span></code></pre><h3 id=5-4-2-chuan-tong-de-foryu-ju>5.4.2 传统的for语句</h3><p>初始化只执行一次，条件表达式值为真则执行循环体。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>for </span><span>(init-statement; condition; expression)</span><span>
</span><span>    statement</span><span>
</span></code></pre><h3 id=5-6-3-fan-wei-foryu-ju>5.6.3 范围for语句</h3><p>C++11新标准引入<strong>范围for语句</strong>，配合auto可方便遍历容器或其他序列的所有元素，如果需要执行写操作，循环变量必须声明为引用类型。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>for </span><span>(declaration : expression)</span><span>
</span><span>    statement</span><span>
</span></code></pre><h3 id=5-4-4-do-whileyu-ju>5.4.4 do while语句</h3><p><strong>do while语句</strong>：先执行循环体后检查条件，无论条件如何，至少执行一次循环。<p>do while语句应该在括号包围起来的条件后面用一个分号表示语句结束。<p>因为对于do while来说先执行语句或块，后判断条件，所以不允许在条件部分定义变量。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>do</span><span>
</span><span>    statement</span><span>
</span><span style=color:#b48ead;>while </span><span>(condition);</span><span>
</span></code></pre><h2 id=5-5-tiao-zhuan-yu-ju>5.5 跳转语句</h2><h3 id=5-5-1-breakyu-ju>5.5.1 break语句</h3><p><strong>break语句</strong>负责终止离它最近的while、do while、for或switch语句，并从这些语句后的第一条语句开始继续执行。<p>break语句只能出现在迭代语句或者switch语句内部（包括嵌套在此类循环里的语句或块的内部），break语句的作用范围仅限于最近的循环或者switch。<h3 id=5-5-2-continueyu-ju>5.5.2 continue语句</h3><p><strong>continue语句</strong>终止最近的循环中的当前迭代并立即开始下一处迭代，continue语句只能出现在for、while和do while循环的内部，或者嵌套在此类循环里的语句或块的内部。<p>嵌套在循环中的continue语句仅作用于离它最近的循环，只有switch嵌套在循环内部中时才能使用continue。<p>对于while或者do while语句来说，继续判断条件的值；对于传统for循环来说，继续执行for语句头的expression；对于范围for语句来说，用序列的下一个元素初始化循环控制变量。<h3 id=5-5-3-gotoyu-ju>5.5.3 goto语句</h3><p><strong>goto语句</strong>的作用是从goto语句无条件跳转到同一函数内的另一条语句。goto语句的语法形式是：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>goto</span><span> label;</span><span>
</span></code></pre><p>label是用于标识一条语句的标识符。<strong>带标签语句</strong>是一种特殊的语句，在它之前有一个标识符以及一个冒号。标签标识符独立于变量或其他标识符的名字，因此，标签标识符可以和程序中其他实体标识符使用同一个名字而不会相互干扰。goto语句和控制器转向的那条带标签的语句必须位于同一个函数之内。<p>和switch语句相似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>	</span><span style=color:#65737e;>//...</span><span style=color:#65737e;>
</span><span>	</span><span style=color:#b48ead;>goto</span><span> end;</span><span>
</span><span>	</span><span style=color:#b48ead;>int</span><span> ix = </span><span style=color:#d08770;>10</span><span>;	</span><span style=color:#65737e;>//错误：goto语句绕过了一个带初始化的变量定义</span><span style=color:#65737e;>
</span><span>end:</span><span>
</span><span>	</span><span style=color:#65737e;>//错误：此次的代码需要使用ix，但是goto语句绕过了它的定义</span><span style=color:#65737e;>
</span><span>	ix = </span><span style=color:#d08770;>42</span><span>;</span><span>
</span></code></pre><p>向后跳过一个已经执行过的定义是合法的，跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//向后跳过一个带初始化的变量定义是合法的</span><span style=color:#65737e;>
</span><span>begin:</span><span>
</span><span>	</span><span style=color:#b48ead;>int</span><span> sz = </span><span style=color:#bf616a;>get_size</span><span>();</span><span>
</span><span>	</span><span style=color:#b48ead;>if</span><span>(sz <= </span><span style=color:#d08770;>0</span><span>){</span><span>
</span><span>        </span><span style=color:#b48ead;>goto</span><span> begin;</span><span>
</span><span>    }</span><span>
</span></code></pre><p>不要在程序中使用goto语句，goto语句会让程序难以理解又难修改。<h2 id=5-6-tryyu-ju-kuai-he-yi-chang-chu-li>5.6 try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。<p>当程序某部分检测到一个无法处理的问题时，需要用的异常处理，此时检测出问题的部分应该发出某种信号以表明程序遇到了故障无法继续下去，而信号发出方无须知道故障在何处得到处理。一旦发出异常信号，检测出问题的部分也就完成了任务。<p>如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括：<ul><li><strong>throw表达式</strong>，异常检测部分使用throw表达式来表示它遇到了无法处理的问题，我们说throw<strong>引发</strong>了异常<li><strong>try语句块</strong>，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个<strong>catch子句</strong>结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们常被称作<strong>异常处理代码</strong>。<li>一套<strong>异常类</strong>，用于在throw表达式和相关的catch子句直接传递异常的具体信息</ul><h3 id=5-6-1-throwbiao-da-shi>5.6.1 throw表达式</h3><p>程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。<p>抛出异常将终止当前的函数，并把控制器转移到能处理该异常的代码。<h3 id=5-6-2-tryyu-ju-kuai>5.6.2 try语句块</h3><p>形式：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>try</span><span>{</span><span>
</span><span>    program-statements	</span><span style=color:#65737e;>//组成程序的正常逻辑</span><span style=color:#65737e;>
</span><span>}</span><span style=color:#b48ead;>catch</span><span>(exception-declaration){	</span><span style=color:#65737e;>//异常声明</span><span style=color:#65737e;>
</span><span>    handler-statements</span><span>
</span><span>}</span><span style=color:#b48ead;>catch</span><span>(exception-declaration){</span><span>
</span><span>    handler-statements</span><span>
</span><span>}</span><span style=color:#65737e;>//...</span><span style=color:#65737e;>
</span></code></pre><p>在复杂的系统中，程序在遇到抛出异常的代码前，其执行路径已经经过了多个try语句块。在异常被抛出时，首先搜索抛出该异常的函数(a)，如果没有找到匹配的catch子句，终止该函数(a)，并在调用该函数的函数(b)中继续寻找，如果最终还是没有找到匹配的catch子句，这个新的函数(b)也被终止，继续搜索调用它(b)的函数(c)。以此类推，沿着程序的执行路径逐层回退，直到找到catch子句为止。如果最终还是没有找到任何匹配的catch子句，程序转到名为<strong>terminate</strong>的标准函数。该函数与系统有关，一般情况下，执行该函数将导致程序非正常退出。<p>对于没有任何try语句块定义的异常，也按照类似的方式处理。<p><strong>在异常发生期间正确执行了“清理”工作的程序被称作异常安全的代码</strong>，编写异常安全的代码非常困难。<h3 id=5-6-3-biao-zhun-yi-chang>5.6.3 标准异常</h3><p>C++标准定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：<ul><li>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外的信息<li>stdexcept头文件定义了几种常用的异常类<li>new头文件定义了bad_alloc异常类<li>type_info头文件定义了bad_cast异常类</ul><p><img alt=image-20200615233825079 src=image-20200615233825079.png><p>标准库异常类只定义了几种运算：创建和拷贝异常类型的对象、为异常类型的对象赋值。<ol><li>exception、bad_alloc、bad_cast对象则只能以默认初始化的方式进行初始化，不允许为这些对象提供初始值。<li>其他异常类的行为恰好相反：应该使用string对象或者C风格字符串初始化这些类型的对象，不允许使用默认初始化的方式，当创建这些对象时，必须提供初始值，该初始值含有错误相关的信息。</ol><p>异常类型只定义了一个名为what的成员函数，不接收参数，返回值是一个指向C风格字符串的const char*。该函数的目的是提供关于异常的一些文本信息。<p>what函数返回的C风格字符串的内容与异常对象的类型有关：<ul><li>异常类型有字符串初始值，则what返回该字符串<li>对于其他无初始值的异常类型来说，what返回的内容由编译器决定</ul></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>