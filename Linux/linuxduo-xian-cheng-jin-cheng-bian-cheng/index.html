<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/Linux/linuxduo-xian-cheng-jin-cheng-bian-cheng/>多线程&多进程的意义</a></h1><div class=post-meta-inline><span class=post-date> 2021-07-16 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/linux/>#Linux</a></span><div class=post-content><p>多线程&多进程的意义<ul><li>提高应用程序的响应<li>有效使地使用多处理器<li>改进程序结构</ul><p>多线程/多进程编程需要解决的问题：进程/线程同步和互斥<p>四种同步模式：<ul><li>互斥锁：仅允许每次一个线程来执行特定的部分代码或者访问特定数据。<li>读写锁：允许对受保护的共享资源进行并发读取和独占写入。要修改资源，线程必须首先获取互斥写锁。只有释放所有的读锁之后，才允许使用互斥写锁。<li>条件变量：会一直阻塞线程，直到特定的条件为真。<li>信号量：通常用来协调对资源的访问。其中信号计数会初始化为可用资源的数目。然后，线程在资源增加时会增加计数，在删除资源时会减小计数，这些操作都以原子方式执行。计数为零时，尝试减小信号的线程会被阻塞，直到计数大于零为止。可用于异步事件通知</ul><p>进程间通信方式：<ul><li>内存共享(shm)：创建共享内存区，需要访问这块内存区的进程将其映射到自己的虚拟内存空间，就按内存访问的方式使用了。<li>消息队列(msg)：一个存放消息（数据）容器，一个进程往消息队列中写数据，而另一个进程从消息队列中取数据。<li>信号量(sem)：不能传递复杂消息，只能用来同步<li>管道(pipe)：有命名管道和匿名管道之分，匿名管道只能用于父子进程通讯，命名管道可用于非父子进程，命名管道就是FIFO，管道是单向的先进先出的通讯方式。<li>Unix Socket：使用socket的api，实现进程间双向通信，和普通的socket区别在于传输数据不走网络协议栈<li>signal：通过kill(,SIGUSR1)向指定线程发出明确信号</ul><blockquote><p>注意：shm、msg、sem是系统级资源，进程退出后，不会自动销毁。可通过ipcs命令查看系统中创建好的对象。</blockquote><p>基于POSIX标准的多线程/进程编程接口<p>线程的创建<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_create</span><span>(pthread_t *</span><span style=color:#bf616a;>thread</span><span>, </span><span style=color:#b48ead;>const </span><span>pthread_attr_t *</span><span style=color:#bf616a;>attr</span><span>,
</span><span>                  </span><span style=color:#b48ead;>void </span><span>*(*start_routime) (</span><span style=color:#b48ead;>void </span><span>*), </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>arg</span><span>);
</span></code></pre><ul><li><p>参数attr是线程属性</p><li><p>start_routine 是新线程的执行函数</p><li><p>arg是透传给start_routine的数据</p><li><p>接口执行成功后，通过thread返回线程ID，该线程ID仅仅是库里的标识，在内核无相应的记录，故仅在当前进程有效。也可通过 pthread_self()接口获取当前线程的ID</p><li><p>线程在内核中的唯一标识（相当于PID）为TID。可通过系统调用来获取：syscall(NR_gettid)</p><li><p>线程的状态信息可从 <code>/proc/&LTPID>/task/&LTTID></code> 中获取</p></ul><blockquote><p>线程属性pthread_attr_t对象的操作接口<ul><li>pthread_attr_init：初始化为缺省值<li>pthread_attr_destroy：销毁属性对象<li>pthread_attr_setdetachstate：设置分离状态<li>pthread_attr_setguardsize：设置栈溢出保护区<li>pthread_attr_setscope：设置竞争CPU的范围（默认PROCESS，即合同进程线程竞争CPU）<li>pthread_attr_setschedpolicy：设置调度策略<li>pthread_attr_setinheritsched：设置调度策略的继承方式（默认新线程不继承创建者线程的调度策略）<li>pthread_attr_setschedparam：设置调度参数（优先级）<li>pthread_attr_setstacksize：设置线程栈大小（32位机默认1MB、64位机默认2MB）<li>pthread_attr_setstack：设置栈地址和大小（可以从堆malloc内存作为线程栈）</ul></blockquote><p>线程的分离<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_detach</span><span>(pthread_t </span><span style=color:#bf616a;>threadd</span><span>);
</span></code></pre><ul><li>使线程处于分离状态，让其自身自灭。效果和通过pthread_attr_setdetachstate设置线程属性相同。<li>线程处于分离状态后，会在退出时自动回收资源，而不需要其他线程join它</ul><p>线程的取消<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_cancel</span><span>(pthread_t </span><span style=color:#bf616a;>thread</span><span>);
</span></code></pre><ul><li>发送Cancel信号给线程。（返回成功不意味着线程终止）<li>默认情况下（没有设置过Cancellation Type），目标线程收到Cancel信号后，需要运行到取消点（特定的一些系统调用）才能退出。<li>鉴于以上特点，强烈建议不要使用该接口退出线程。而是采用线程自主退出的方式。</ul><p>等待线程终止<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_join</span><span>(pthread_t </span><span style=color:#bf616a;>thread</span><span>, </span><span style=color:#b48ead;>void </span><span>**</span><span style=color:#bf616a;>retval</span><span>);
</span></code></pre><ul><li>等待线程结束，并回收线程资源<li>当目标线程处于非分离状态，必须调用此接口来完成接收，不然就会出现内存泄漏。</ul><p>线程特定数据（TSD）<ul><li>单线程 C 程序有两类基本数据：局部数据和全局数据。对于多线程 C 程序，添加了第三类数据：线程特定数据。线程特定数据与全局数据非常相似，区别在于前者为线程专有。<li>是线程本地存储（TLS）技术在Linux上的实现。<li>TSD基于每个线程进程维护，是定义和引用线程专用数据的唯一方法。<li>每个TSD项对应一个key，而这个key对进程中所有线程来说是全局的。<li>实际应用：同一个接口在不同线程中使用线程特定的数据，从而和线程关联起来。典型例子：errno</ul><p>TSD的使用：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>pthread.h</span><span>>
</span><span>
</span><span style=color:#65737e;>//创建TSD的键
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_key_create</span><span>(pthread_key_t *</span><span style=color:#bf616a;>key</span><span>, </span><span style=color:#b48ead;>void </span><span>(*destructor)(</span><span style=color:#b48ead;>void</span><span>*));
</span><span style=color:#65737e;>//删除TSD键
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_key_delete</span><span>(pthread_key_t </span><span style=color:#bf616a;>key</span><span>);
</span><span style=color:#65737e;>//为指定TSD键设置线程特定绑定
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_setspecific</span><span>(pthreadd_key_t </span><span style=color:#bf616a;>key</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>value</span><span>);
</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#8fa1b3;>pthread_getspecific</span><span>(pthread_key_t </span><span style=color:#bf616a;>key</span><span>);
</span></code></pre><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//运行初始化函数init_routine, 并确保init_routine在本进程中只执行一次
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_once</span><span>(pthread_once_t *</span><span style=color:#bf616a;>once_control</span><span>, 
</span><span>                 </span><span style=color:#b48ead;>void </span><span>(*init_routine)(</span><span style=color:#b48ead;>void</span><span>));
</span></code></pre><p>互斥锁：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//初始化由mp指向的互斥锁（可位于共享内存），mattr为互斥锁属性
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_mutex_init</span><span>(pthread_mutex_t *</span><span style=color:#bf616a;>mp</span><span>, 
</span><span>                       </span><span style=color:#b48ead;>const </span><span>pthread_mutexattr_t *</span><span style=color:#bf616a;>mattr</span><span>);
</span><span style=color:#65737e;>//锁定互斥锁。返回EOWNERDEAD表示所有者挂了。
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_mutex_lock</span><span>(pthread_mutex_t *</span><span style=color:#bf616a;>mutex</span><span>);
</span><span style=color:#65737e;>//解除锁定互斥锁
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_mutex_unlock</span><span>(pthread_mutex_t *</span><span style=color:#bf616a;>mutex</span><span>);
</span><span style=color:#65737e;>//恢复锁的一致性。当锁的所有者死掉后，需先调此接口恢复锁的一致性，再去锁定
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_mutex_consistent</span><span>(pthread_mutex_t *</span><span style=color:#bf616a;>mutex</span><span>);
</span><span style=color:#65737e;>//销毁互斥锁
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_mutex_destroy</span><span>(pthread_mutex_t *</span><span style=color:#bf616a;>mp</span><span>);
</span></code></pre><ul><li>如果要将mutex应用于进程间同步，需将mp指向共享内存，并设置PTHREAD_PROCESS_SHARED、PTHREAD_MUTEX_ROBUST属性。另外注意要在异常时及时通过调用pthread_mutex_consistent修复锁。<li>可通过设置互斥锁属性PTHREAD_MUTEX_RECURSIVE，将互斥锁配置成递归锁。即一个线程在锁定该互斥锁后，可以在不释放的情况下再次锁定。</ul><p>读写锁：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//初始化由rwlock指定的读写锁（可位于共享内存）
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_rwlock_init</span><span>(pthread_rwlock_t *</span><span style=color:#bf616a;>rwlock</span><span>, 
</span><span>                        </span><span style=color:#b48ead;>const </span><span>pthread_rwlockattr_t *</span><span style=color:#bf616a;>attr</span><span>);
</span><span style=color:#65737e;>//获取读锁
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_rwlock_rdlock</span><span>(pthread_rwlock_t *</span><span style=color:#bf616a;>rwlock</span><span>);
</span><span style=color:#65737e;>//获取写锁
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_rwlock_wrlock</span><span>(pthread_rwlock_t *</span><span style=color:#bf616a;>rwlock </span><span>);
</span><span style=color:#65737e;>//解除锁定读写锁
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_rwlock_unlock </span><span>(pthread_rwlock_t *</span><span style=color:#bf616a;>rwlock</span><span>);
</span><span style=color:#65737e;>//销毁读写锁
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_rwlock_destroy</span><span>(pthread_rwlock_t *</span><span style=color:#bf616a;>rwlock</span><span>);
</span></code></pre><ul><li>读写锁是用来解决读者和写者同步的问题，读可以有多个同时读，写只允许一个写，另外写的时候不允许读，读的时候不允许写。<li>设置读写锁属性PTHREAD_PROCESS_SHARED，可允许其他进程共享读写锁</ul><p>条件变量：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//初始化由cv指向的条件变量（可位于共享内存），cattr为条件变量属性
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_cond_init</span><span>(pthread_cond_t *</span><span style=color:#bf616a;>cv</span><span>, </span><span style=color:#b48ead;>const </span><span>pthread_condattr_t *</span><span style=color:#bf616a;>cattr</span><span>);
</span><span style=color:#65737e;>//基于条件变量阻塞。
</span><span style=color:#65737e;>//以原子方式释放 mp 所指向的互斥锁，并导致调用线程基于 cv 所指向的条件变量阻塞。
</span><span style=color:#65737e;>//当阻塞被解除后，又原子方式再次获取互斥锁——即使是返回错误
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_cond_wait</span><span>(pthread_cond_t *</span><span style=color:#bf616a;>cv</span><span>, pthread_mutex_t *</span><span style=color:#bf616a;>mp</span><span>);
</span><span style=color:#65737e;>//在指定时间前阻塞。返回ETIMEDOUT表示等待超时。
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_cond_timedwait</span><span>(pthread_cond_t *</span><span style=color:#bf616a;>cv</span><span>, pthread_mutex_t *</span><span style=color:#bf616a;>mp</span><span>, 
</span><span>                           </span><span style=color:#b48ead;>const struct</span><span> timespec *</span><span style=color:#bf616a;>abstime</span><span>);
</span><span style=color:#65737e;>//解除一个线程的阻塞。由调度策略决定唤醒哪个线程。
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_cond_signal</span><span>(pthread_cond_t *</span><span style=color:#bf616a;>cv</span><span>);
</span><span style=color:#65737e;>//解除所有线程的阻塞。将导致线程竞争互斥锁
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_cond_broadcast</span><span>(pthread_cond_t *</span><span style=color:#bf616a;>cv</span><span>);
</span><span style=color:#65737e;>//销毁条件变量状态
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pthread_cond_destroy</span><span>(pthread_cond_t *</span><span style=color:#bf616a;>cv</span><span>);
</span></code></pre><ul><li><p>通常，对条件的评估是在互斥锁的保护下进行的。如果条件为假，线程会基于条件变量阻塞。当另一个线程更改条件值时，会针对条件变量发出信号。这种变化会导致所有等待该条件的线程解除阻塞并尝试再次获取互斥锁。</p><li><p>为了支持多进程间共享条件变量。需将cv指向共享内存，同时设置条件变量的属性为PTHREAD_PROCESS_SHARED</p><li><p>pthread_cond_timewait默认使用的时钟类型是CLOCK_REALTIME，假如系统实时时钟被修改，将导致timewait出现错误。可将条件变量的属性中的时钟类型该为CLOCK_MONOTONIC（单调时钟）。同时在获取当前tv时使用</p> <pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>struct</span><span> timespec tv;
</span><span style=color:#bf616a;>clock_gettime</span><span>(CLOCK_MONOTONIC, &tv);
</span></code></pre></ul><p>信号量：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//初始sem指定的信号量（可位于共享内存），pshare非0时表示允许其他进程共享，value是信号量计数初始值
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sem_init</span><span>(sem_t *</span><span style=color:#bf616a;>sem</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>pshared</span><span>, </span><span style=color:#b48ead;>unsigned int </span><span style=color:#bf616a;>value</span><span>);
</span><span style=color:#65737e;>//以原子方式增加 sem 所指示的信号量
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sem_post</span><span>(sem_t *</span><span style=color:#bf616a;>sem</span><span>);
</span><span style=color:#65737e;>//基于信号量阻塞，直到 sem 所指示的信号计数大于零为止，之后以原子方式减小计数
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sem_wait</span><span>(sem_t *</span><span style=color:#bf616a;>sem</span><span>);
</span><span style=color:#65737e;>//销毁信号量
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sem_destroy</span><span>(sem_t *</span><span style=color:#bf616a;>sem</span><span>);
</span></code></pre><p>共享内存（shm）<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//创建共享内存。key一般由ftok生成，size为共享内存大小
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>shmget</span><span>(key_t </span><span style=color:#bf616a;>key</span><span>, size_t </span><span style=color:#bf616a;>size</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>shmflg</span><span>);
</span><span style=color:#65737e;>//挂接共享内存。若成功则返回映射后的虚拟地址
</span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#8fa1b3;>shmat</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>shmid</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>shmaddr</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>shmflg</span><span>);
</span><span style=color:#65737e;>//解挂共享内存。使共享内存的引用计数减1
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>shmdt</span><span>(</span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>shmaddr</span><span>);
</span><span style=color:#65737e;>//销毁共享内存。cmd置为IPC_RMID
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>shmctl</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>shmid</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>cmd</span><span>, </span><span style=color:#b48ead;>struct</span><span> shmid_ds *</span><span style=color:#bf616a;>buf</span><span>);
</span></code></pre><ul><li>共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。是最高效的IPC方式<li>共享内存没有提供同步机制，这使得我们在使用共享内存进行进程间通信时，往往需要借助其他手段来保证进程之间的同步。如：信号量<li>可通过ipcs命令查看和删除共享内存</ul><p>消息队列（msg）<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//创建消息队列。key要求整个系统唯一，一般由ftok生成
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>msgget</span><span>(key_t </span><span style=color:#bf616a;>key</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>msgflg</span><span>);
</span><span style=color:#65737e;>//往消息队列发送消息
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>msgsnd</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>msqid</span><span>, </span><span style=color:#b48ead;>const void </span><span>*</span><span style=color:#bf616a;>msgp</span><span>, size_t </span><span style=color:#bf616a;>msgsz</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>msgflg</span><span>);
</span><span style=color:#65737e;>//从消息队列读取消息
</span><span>ssize_t </span><span style=color:#8fa1b3;>msgrcv</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>msqid</span><span>, </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>msgp</span><span>, size_t </span><span style=color:#bf616a;>msgsz</span><span>, </span><span style=color:#b48ead;>long </span><span style=color:#bf616a;>msgtyp</span><span>,
</span><span>                      </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>msgflg</span><span>);
</span><span style=color:#65737e;>//删除消息队列。cmd置为IPC_RMID
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>msgctl</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>msqid</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>cmd</span><span>, </span><span style=color:#b48ead;>struct</span><span> msqid_ds *</span><span style=color:#bf616a;>buf</span><span>);
</span></code></pre><ul><li>可通过ipcs命令查看和删除消息队列</ul><p>信号量(sem)<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//创建信号量。key一般由ftok生成，nsems为信号计数初始值
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>semget</span><span>(key_t </span><span style=color:#bf616a;>key</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>nsems</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>semflg</span><span>);
</span><span style=color:#65737e;>//操作信号量。sops->sem_op为-1时表示P操作，+1时表示V操作
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>semop</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>semid</span><span>, </span><span style=color:#b48ead;>struct</span><span> sembuf *</span><span style=color:#bf616a;>sops</span><span>, </span><span style=color:#b48ead;>unsigned </span><span style=color:#bf616a;>nsops</span><span>);
</span><span style=color:#65737e;>//销毁信号量。cmd置为IPC_RMID
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>semctl</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>semid</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>semnum</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>cmd</span><span>, ...);
</span></code></pre><ul><li>用来解决进程间的同步与互斥问题的一种进程间通信机制，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（P/V操作）<li>和shm和msg一样，sem不会随进程退出而销毁，可通过ipcs命令查看和删除信号量</ul><p>管道（pipe）<ul><li>管道是一种最基本的IPC机制<li>规定数据从管道的写端流入管道，从读端流出。<li>原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。其本质是一个伪文件<li>数据不可反复读取。一旦被读走，便不在管道中存在<li>数据只能在一个方向上流动。<li>管道分为匿名管道和命名管道</ul><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//匿名管道：通过系统调用pipe()来实现，只能在有亲缘关系的进程间使用
</span><span style=color:#65737e;>//创建管道成功后，得到两个文件描述符fd[0]、fd[1]，分别指向管道的读端和写端
</span><span style=color:#65737e;>//接下来可以通过read/write标准的文件读写接口操作管道，实现数据传输
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>pipe</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd</span><span>[</span><span style=color:#d08770;>2</span><span>]);
</span></code></pre><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//命名管道：和匿名管道类似，但不局限于亲緣关系的进程。它基于管道文件，因此我们首先要创建一个管道文件：
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>mkfifo</span><span>(</span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>name</span><span>,mode_t </span><span style=color:#bf616a;>mode</span><span>);
</span><span style=color:#65737e;>//调用以上系统调用的效果，和通过mkfifo命令创建的一样。
</span><span>
</span><span style=color:#65737e;>//创建管道文件后，需要调用open打开管道文件
</span><span style=color:#b48ead;>int</span><span> fd=</span><span style=color:#bf616a;>open</span><span>(name,O_RDONLY);   </span><span style=color:#65737e;>//读
</span><span style=color:#b48ead;>int</span><span> fd=</span><span style=color:#bf616a;>open</span><span>(name,O_WRONLY);  </span><span style=color:#65737e;>//写
</span><span>
</span><span style=color:#65737e;>//接下来就可以和匿名管道一样通过read/write进行读写了
</span></code></pre><p>管道的读写行为：<ul><li>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。<li>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。<li>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</ul><p>Unix Socket<ul><li>UNIX Domain SOCKET 是在Socket架构上发展起来的用于同一台主机的进程间通信。它不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序列号应答等。只是将应用层数据从一个进程拷贝到另一个进程。<li>UNIX Domain SOCKET有SOKCET_DGRAM和SOCKET_STREAM两种模式，类似于UDP和TCP，但是面向消息的UNIX socket也是可靠的，消息既不会丢失也不会乱序。<li>和pipe不一样，UNIX socket通讯是全双工的<li>使用UNIX Socket的过程和网络socket十分相似。也要先调用socket()创建一个socket文件描述符，domain指定为AF_UNIX<li>与网络socket编程最明显的不同在于地址格式不同，用结构体sockaddr_un表示，网络编程的socket地址是IP地址加端口号，而UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。</ul><p>signal<ul><li>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。从它的命名可以看出，它的实质是软中断<li>许多重要的程序都需要处理信号。比如，终端用户输入了 ctrl+c 来中断程序，会通过信号机制停止一个程序。<li>每个信号都有一个名字和编号，这些名字都以“SIG”开头，例如“SIGIO ”、“SIGCHLD”等等。信号定义在signal.h头文件中，信号名都定义为正整数。信号从1开始编号。<li>信号的处理方式有三种： <ul><li>忽略：SIGKILL和SIGSTOP不能忽略<li>捕捉：由用户自定义信号处理函数，SIGKILL和SIGSTOP不能被捕捉<li>默认动作：对于每种信号，系统都有默认的处理方式，可通过”man 7 signal”查看</ul><li>可通过kill命令向进程发送信号，如发送SIGKILL（编号9）信号给PID为1555的进程：kill -9 1555</ul><p>signal()函数不能携带数据，如果要携带数据，则需要使用高级版的接口：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sigaction</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>signum</span><span>, </span><span style=color:#b48ead;>const struct</span><span> sigaction *</span><span style=color:#bf616a;>act</span><span>, 
</span><span>              </span><span style=color:#b48ead;>struct</span><span> sigaction *</span><span style=color:#bf616a;>oldact</span><span>);   </span><span style=color:#65737e;>// 注册
</span><span>
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>sigqueue</span><span>(pid_t </span><span style=color:#bf616a;>pid</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sig</span><span>, </span><span style=color:#b48ead;>const union</span><span> sigval </span><span style=color:#bf616a;>value</span><span>);   </span><span style=color:#65737e;>// 发送
</span></code></pre></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>