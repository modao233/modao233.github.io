<!DOCTYPE html>
<html>
  <head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>modao</title>
	
	<script type="text/javascript" charset="utf-8">
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?36479f1e15841da95f9e92a25b010d23";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<meta name="generator" content="Hexo 5.4.0"></head>
  <body>
	
      
<link rel="stylesheet" href="/css/navigatebar.css">


<div class="navigatebar">
	<div class="navigatebar-button navigatebar-mine">
    <a href="/">modao</a>
	</div>
	
	
        <div class="navigatebar-button">
          <a href="/">Home</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/categories">Categories</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/links">Friends</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/sites">Sites</a>
        </div>
	
        <div class="navigatebar-button">
          <a href="/stars">Stars</a>
        </div>
	
</div>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">


<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%90%84%E7%89%88%E6%9C%AC"><span class="toc-text">C++各版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">C++11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="toc-text">关键字及新语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E5%AE%B9%E5%99%A8"><span class="toc-text">STL 容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">智能指针内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11-%E7%BC%96%E8%AF%91%E5%99%A8%E6%94%AF%E6%8C%81%EF%BC%9A"><span class="toc-text">C++11 编译器支持：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E5%90%84%E7%89%88%E6%9C%AC"><span class="toc-text">C各版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C99%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">C99部分新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C11"><span class="toc-text">C11</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Similar-Posts"><span class="toc-text">Similar Posts</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		(转载)C和C++的历史版本迭代整理
	</div>
	
	<div class="page-date">
		2020-12-07
	</div>
	
	<div class="category-area">
		
			 
				「
				<div class="category">
					<a href="/categories/C++">C++</a>
				
				</div>
				」
			
		
	</div>
	
	<div class="content">
		<p>原文：<a target="_blank" rel="noopener" href="https://xiaodongq.github.io/2019/10/18/C%E5%92%8CC++%E7%9A%84%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E6%95%B4%E7%90%86/#c%E5%90%84%E7%89%88%E6%9C%AC-1">C和C++的历史版本迭代整理</a></p>
<p>介绍C和C++的历史版本迭代。部分常用特性说明。</p>
<span id="more"></span>

<h2 id="C-各版本"><a href="#C-各版本" class="headerlink" title="C++各版本"></a>C++各版本</h2><p>C++版本之前也讲到过：<a target="_blank" rel="noopener" href="https://xiaodongq.github.io/2019/10/16/C++%E4%B8%AD%E7%9A%84RAII%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E5%BA%94%E7%94%A8/">C++中的RAII机制和互斥锁应用</a></p>
<p>百度百科：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/c%2B%2B0x">c++0x</a></p>
<ul>
<li>  1998年是C++标准委员会成立的第一年，以后每5年视实际需要更新一次标准。</li>
<li>  2009年，C++标准有了一次更新，一般称该草案为C++0x。</li>
<li>  C++0x是C++11标准成为正式标准之前的草案临时名字。</li>
<li>  后来，2011年，C++新标准标准正式通过，更名为ISO/IEC 14882:2011，简称C++11。</li>
</ul>
<p>维基百科：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C%2B%2B11#cite_note-1">C++11</a></p>
<ul>
<li>C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。    <ul>
<li>  它取代第二版标准ISO/IEC 14882:2003  （第一版ISO/IEC 14882:1998公开于1998年， 第二版于2003年更新，分别通称C++98以及C++03，两者差异很小），且已被C++14取代</li>
</ul>
</li>
<li>C++14 旨在作为C++11的一个小扩展，主要提供漏洞修复和小的改进。    <ul>
<li>  2014年8月18日，经过C++标准委员投票，C++14标准获得一致通过。ISO/IEC 14882:2014</li>
</ul>
</li>
<li>C++17 又称C++1z，是继 C++14 之后，C++ 编程语言 ISO/IEC 标准的下一次修订的非正式名称。    <ul>
<li>  官方名称 ISO/IEC 14882:2017</li>
<li>  基于 C++ 11，C++ 17 旨在简化该语言的日常使用，使开发者可以更简单地编写和维护代码。</li>
<li>  C++ 17是对 C++ 语言的重大更新</li>
<li>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/csdnnews/article/details/78737012">C++ 17 标准正式发布</a></li>
</ul>
</li>
</ul>
<p>相比于C++03，C++11标准包含核心语言的新机能，而且扩展C++标准程序库，并入了大部分的C++ Technical Report 1程序库（数学的特殊函数除外）。</p>
<p>关于C++11的版本发布过程…：</p>
<blockquote>
<p>  上一个版本的C++国际标准是2003年发布的，所以叫C++ 03。然后C++国际标准委员会在研究C++  03的下一个版本的时候，一开始计划是07年发布，所以最初这个标准叫C++ 07。但是到06年的时候，官方觉得07年肯定完不成C++  07，而且官方觉得08年可能也完不成。最后干脆叫C++  0x。x的意思是不知道到底能在07还是08还是09年完成。结果2010年的时候也没完成，最后在2011年终于完成了C++标准。所以最终定名为C++11。  参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20141092/answer/21463744">c++ 0x和c++ 11是什么关系？0x又是什么意思？</a></p>
</blockquote>
<h3 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h3><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3ac281aa457f">C++11 新特性</a></p>
<h4 id="关键字及新语法"><a href="#关键字及新语法" class="headerlink" title="关键字及新语法"></a>关键字及新语法</h4><ul>
<li>auto 关键字及用法    <ul>
<li>  C++11 之前，auto 具有存储期说明符的语义。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。</li>
</ul>
</li>
<li>nullptr 关键字及用法    <ul>
<li>  引入nullptr，是因为重载函数处理 NULL 的时候会出问题，二义性</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">void foo(int);   //(1)<br>void foo(void*); //(2)<br><br>foo(NULL);    // 重载决议选择 (1)，但调用者希望是 (2)<br>foo(nullptr); // 调用(2)<br></code></pre></td></tr></table></figure>

<ul>
<li>for 循环语法    <ul>
<li>  for ( 范围声明 : 范围表达式 ) 循环语句</li>
</ul>
</li>
</ul>
<h4 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h4><ul>
<li>std::array    <ul>
<li>  std::array 提供了静态数组，编译时确定大小、更轻量、更效率，当然也比 std::vector 有更多局限性。</li>
</ul>
</li>
<li>std::forward_list    <ul>
<li>  单向链表</li>
</ul>
</li>
<li>  std::unordered_map</li>
<li>  std::unordered_set</li>
</ul>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul>
<li>std::thread    <ul>
<li>  在 C++11 以前，C++ 的多线程编程均需依赖系统或第三方接口实现</li>
<li>  一定程度上影响了代码的移植性。</li>
<li>  C++11 中，引入了 boost 库中多线程的部分内容，形成标准后的接口与 boost 库基本没有变化，这样方便了使用者切换使用 C++ 标准接口。</li>
</ul>
</li>
<li>std::atomic    <ul>
<li>  从实现上，可以理解为这些原子类型内部自己加了锁。</li>
</ul>
</li>
<li>  std::condition_variable</li>
</ul>
<h4 id="智能指针内存管理"><a href="#智能指针内存管理" class="headerlink" title="智能指针内存管理"></a>智能指针内存管理</h4><ul>
<li>  std::shared_ptr</li>
<li>  std::weak_ptr</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>  std::function、std::bind 封装可执行对象</li>
<li>lambda 表达式    <ul>
<li>  lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作。</li>
</ul>
</li>
</ul>
<h3 id="C-11-编译器支持："><a href="#C-11-编译器支持：" class="headerlink" title="C++11 编译器支持："></a>C++11 编译器支持：</h3><p>参考的知乎问答：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27010179">C++11编译器的支持</a></p>
<ul>
<li>  编译器对C++0x和C++11的支持</li>
<li>GCC编译器对C++11的特性支持    <ul>
<li>  codecvt用于编码转换，在GCC 5时引入，在GCC 7（C++17）时废弃。</li>
<li>  GCC 4.9时正则表达式</li>
<li>  GCC 4.8时引入了类成员变量函数返回值的左值、右值引用</li>
<li>  GCC 4.7时正式启用-std=c++11，之前都是使用-std=c++0x</li>
<li>  GCC 4.6时引入了range based for，即for each。</li>
<li>  GCC 4.5时引入了lambda表达式，大大方便了函数式编程。</li>
<li>  stoi/stod和to_string系列函数其实很早就引入了GCC（&lt; 4.5）</li>
</ul>
</li>
</ul>
<p>参考zh.cppreference.com整理的对于各个标准特性的支持情况(包含C++11,C++14,17等等)：</p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/compiler_support#cpp11">C++ 编译器支持情况表</a></p>
<p>选取GCC中个人目前注意的几个：</p>
<ul>
<li>auto, 4.4    <ul>
<li>  C++0x/C++11 为 auto 关键字定义了完全不同的语义,4.5开始支持 参考：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/aix/library/au-gcc/index.html">GCC 4.5 中的 C++0x 特性支持</a></li>
</ul>
</li>
<li>  nullptr, 4.6</li>
<li>范围 for 循环, 4.6    <ul>
<li>  for ( 范围声明 : 范围表达式 ) 循环语句</li>
</ul>
</li>
<li>noexcept, 4.6    <ul>
<li>  指定函数是否抛出异常。 <code>void f() noexcept; // 函数 f() 不抛出</code></li>
</ul>
</li>
<li>override 与 final, 4.7    <ul>
<li>  override 指定一个虚函数覆盖另一个虚函数。 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/override">override 说明符</a></li>
<li>  final 指定某个虚函数不能在子类中被覆盖，或者某个类不能被子类继承。 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/final">final 说明符</a></li>
</ul>
</li>
<li>decltype 4.8.1    <ul>
<li>  检查实体的声明类型，或表达式的类型和值类别。</li>
</ul>
</li>
</ul>
<h2 id="C各版本"><a href="#C各版本" class="headerlink" title="C各版本"></a>C各版本</h2><p>参考：</p>
<p>维基百科：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80#C99">C语言</a></p>
<ul>
<li>C语言早期    <ul>
<li>  最早由丹尼斯·里奇（Dennis Ritchie）为了在PDP-11电脑上运行的Unix系统所设计出来的编程语言</li>
<li>  第一次发展在1969年到1973年之间。</li>
<li>  在PDP-11出现后，丹尼斯·里奇与肯·汤普逊着手将Unix移植到PDP-11上</li>
<li>  1973年，Unix操作系统的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。</li>
<li>  1975年C语言开始移植到其他机器上使用。史蒂芬·强生实现了一套“可移植编译器”</li>
</ul>
</li>
<li>K&amp;R C    <ul>
<li>  1978年，丹尼斯·里奇和布莱恩·柯林汉合作出版了《C程序设计语言》的第一版。 “K&amp;R C”（柯里C）。</li>
</ul>
</li>
<li>C89    <ul>
<li>  1989年，C语言被美国国家标准协会（ANSI）标准化，这个版本又称为C89</li>
<li>  标准化的一个目的是扩展K&amp;R C，增加了一些新特性。</li>
</ul>
</li>
<li>C90    <ul>
<li>  1990年，国际标准化组织（ISO）规定国际标准的C语言</li>
<li>  通过对ANSI标准的少量修改，最终制定了 ISO 9899:1990，又称为C90。</li>
<li>  随后，ANSI亦接受国际标准C，并不再发展新的C标准。</li>
</ul>
</li>
<li>C99    <ul>
<li>  1994年为C语言创建了一个新标准，但是只修正了一些C89标准中的细节和增加更多更广的国际字符集支持。</li>
<li>  不过，这个标准引出了1999年ISO 9899:1999的发表。它通常被称为C99。</li>
<li>  C99被ANSI于2000年3月采用。</li>
</ul>
</li>
<li>C11    <ul>
<li>  2011年12月8日，ISO正式发布了新的C语言的新标准C11，之前被称为C1X</li>
<li>  官方名称为ISO/IEC 9899:2011</li>
<li>  新的标准提高了对C++的兼容性，并增加了一些新的特性。</li>
<li>  这些新特性包括泛型宏、多线程、带边界检查的函数、匿名结构等。</li>
</ul>
</li>
<li>C18    <ul>
<li>  C18没有引入新的语言特性，只对C11进行了补充和修正。</li>
</ul>
</li>
</ul>
<p>K&amp;R C语言到ANSI/ISO标准C语言 (C89/C90)的改进包括：</p>
<ul>
<li>  增加了真正的标准库</li>
<li>  新的预处理命令与特性</li>
<li>  函数原型允许在函数申明中指定参数类型</li>
<li>  一些新的关键字，包括 const、volatile 与 signed</li>
<li>  宽字符、宽字符串与多字节字符</li>
<li>  对约定规则、声明和类型检查的许多小改动与澄清</li>
</ul>
<h3 id="C99部分新特性"><a href="#C99部分新特性" class="headerlink" title="C99部分新特性"></a>C99部分新特性</h3><p>(只截取了部分本人关注的)：</p>
<ul>
<li>  支持不定长的数组，声明时使用 int a[var] 的形式。</li>
<li>  变量声明不必放在语句块的开头，for 语句提倡写成 for(int i=0;i&lt;100;++i) 的形式</li>
<li>  允许采用（type_name）{xx,xx,xx} 类似于 C++ 的构造函数的形式构造匿名的结构体。</li>
<li>  除了已有的 <code>__line__</code> <code>__file__</code> 以外，增加了 <code>__func__</code> 得到当前的函数名。</li>
<li>  取消了函数返回类型默认为 int 的规定。</li>
<li>  增加和修改了一些标准头文件(定义bool的、定义复数的、里增加了 struct tmx，对 struct tm 做了扩展。)</li>
</ul>
<blockquote>
<p>  但是各个公司对C99的支持所表现出来的兴趣不同。当GCC和其它一些商业编译器支持C99的大部分特性的时候[4]，微软和Borland却似乎对此不感兴趣。</p>
</blockquote>
<h3 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h3><p>参考：</p>
<p>维基百科：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C11">C11</a></p>
<ul>
<li>C11：    <ul>
<li>  C11（也被称为C1X）指ISO标准ISO/IEC 9899:2011，是当前最新的C语言标准。</li>
<li>  在它之前的C语言标准为C99 (1999年ISO 9899:1999)，C99被ANSI于2000年3月采用。</li>
<li>  这次修订新增了被主流C语言编译器(如GCC,Clang,Visual C++等)增加的内容</li>
<li>  引入了内存模型以更好的执行多线程</li>
<li>  之前C99的一些被推迟的计划在C11中增加了，但是对C99仍保留向后兼容。</li>
</ul>
</li>
<li>编译器支持    <ul>
<li>  GCC从4.6版本开始，已经可以支持一些C11的特性，但多线程相关的库直到2019年还未出现稳定的实现，等于没有编译器可以完整的支持C11</li>
<li>  GCC 4.6 版本使用参数-std=c1x ，4.7版本以后使用参数-std=c11</li>
<li>  Clang则是自3.1版开始支持，并在LLVM 3.6版之后默认使用C11的语法</li>
<li>  但另一个主流编译器，微软的 Visual Studio 则是自 C99 开始就没有支持新的C语言版本了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  虽然 gcc 与 clang 支持C11的语法，却没有实现strcat_s()等边界检查函数以及线程相关库。gcc的支持者狂热的四处宣称这些库是GNU C库的责任而不是gcc的责任——尽管gcc和GNU C库都是GNU项目的子项目。</p>
</blockquote>
<hr>
<h2 id="Similar-Posts"><a href="#Similar-Posts" class="headerlink" title="Similar Posts"></a>Similar Posts</h2><p><a target="_blank" rel="noopener" href="https://xiaodongq.github.io/2019/10/22/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8/">C++11的智能指针使用</a>                        </p>
<p><a target="_blank" rel="noopener" href="https://xiaodongq.github.io/2019/10/21/C++%E4%B8%8D%E5%8F%AF%E6%8B%B7%E8%B4%9D%E7%B1%BB%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">C++不可拷贝类和右值引用</a>                        </p>
<p><a target="_blank" rel="noopener" href="https://xiaodongq.github.io/2019/10/20/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/">C++构造函数的隐式转换和转换函数</a>                        </p>

	</div>
</div>
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>
<script>
    function setClipboardText(event){
        
        let clipboardData = event.clipboardData || window.clipboardData;
        
        if (!clipboardData) { return; }
        event.preventDefault();
        
        let text = window.getSelection().toString();
		    
        if (text) {
            
            event.preventDefault();
            
            var copyright = '\n\n'
            + '\n作品采用 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议 进行许可'
            + '\n著作权归作者所有，商业转载请联系作者获得授权，非商业转载请注明出处。'
            + '\n作者: modao'
            + '\n邮箱: rustacean@aliyun.com'
            + '\n原文地址: https://modao.site/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Cpp/C%E5%92%8CC++%E7%9A%84%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E6%95%B4%E7%90%86/'
			
            clipboardData.setData('text/plain', text + copyright);
    
        }
    };
	
    var contents = document.getElementsByClassName("content-area");
   
    contents[0].addEventListener('copy',function(e){
        setClipboardText(e);
    });

</script>
    
  </body>
</html>