<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>PL</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/Linux-Unix系统编程手册/di-4zhang-tong-yong-io/">第4章 通用IO</a></h1><div class=post-meta-inline><span class=post-date> 2021-02-01 </span></div><div class=post-content><p>所有执行IO操作的系统调用都以文件描述符来指代打开的文件。 文件描述符是非负整数<p>每个进程，文件描述符都自成一套。<p>shell进程默认打开3个文件描述符：0、1、2 程序继承shell文件描述符副本，所以也默认打开。<p><img alt=4-1 src=./image-20211128205535998.png><p>UNIX I/O模型的显著特点之一：输入/输出的通用性概念。这意味着使用4个同样的系统调用open()、read()、write()、close()可以对所有类型的文件执行I/O操作。<p>要实现通用I/O，就必须确保每一文件系统和设备驱动程序都实现了相同的I/O系统调用集。<p>当需要访问文件系统或设备的<strong>专有功能</strong>时，可以使用ioctl()系统调用，该调用为通用I/O模型之外的<strong>专有特性</strong>提供了访问接口。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/stat.h</span><span>>
</span><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>fcntl.h</span><span>>
</span><span>
</span><span style=color:#65737e;>//成功返回文件描述符，失败返回-1并将errno置为相应的标志位
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>open</span><span>(</span><span style=color:#b48ead;>const char </span><span>*</span><span style=color:#bf616a;>pathname</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>flags</span><span>, ...</span><span style=color:#65737e;>/* mode_t mode */</span><span>);
</span></code></pre><ul><li><p>如果pathname是符号链接，会对其作解引用</p><li><p>flags为位掩码，用于指定文件的访问模式</p> <img style="zoom: 80%;" alt=image-20220802201231009 src=C:\Users\modao\AppData\Roaming\Typora\typora-user-images\image-20220802201231009.png><li><p>mode为位掩码，当open()没有指定O_CREAT标志时，可以省略，作用是指定新创建文件的访问权限</p></ul><p>新建文件的访问权限：<ul><li>不仅仅依赖于参数mode<li>受进程umask值的影响<li>受父目录的默认访问控制列表（可能存在）的影响</ul><p>open()调用成功，必须保证其返回值为进程未用文件描述符中数值最小者。可以丽影该特性以特定文件描述符打开某一个文件。<p><img alt=image-20220802202634825 src=C:%5CUsers%5Cmodao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220802202634825.png><p>4-3表中常量分为3组：<ul><li>文件访问模式标志：三种在flags参数中不能同时使用，能通过fcntl()的F_GETFL操作检索文件的访问模式<li>文件创建标志：这些标志不能检索，无法修改<li>已打开文件的状态标志：使用fcntl()的F_GETFL和F_SETFL操作可以分别检索和修改这些标志，故又称<strong>文件状态标志</strong></ul></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>