<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/Unix网络编程-笔记/unixwang-luo-bian-cheng-di-1zhang/">Unix网络编程-第1章 简介</a></h1><div class=post-meta-inline><span class=post-date> 2019-12-07 </span></div><div class=post-content><p>Unix网络编程-第1章 简介<pre style=background-color:#2b303b;color:#c0c5ce;><code><span>源代码下载：http://www.unpbook.com/
</span><span>
</span><span>源代码使用方法见解压后的README文件
</span></code></pre><p><strong>TCP是一个没有记录边界的<em>字节流</em>协议，TCP本身并不提供记录结束的标志：如果应用程序需要确定记录的边界，它就要自己去实现，已有的一些常用的方法可供选择。</strong><p><strong>迭代服务器</strong>：对于每个客户都迭代执行一次。<p><strong>并发服务器</strong>：同时能处理多个客户。<p><strong>原始套接字</strong>：网络应用绕过传输层直接使用IPv4或IPv6。<p><strong>为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口？</strong><p>理由有两：<ol><li>顶上三层处理具体网络应用的所有细节，却对通信细节了解很少；底下四层对具体网络应用了解不多，却处理所有的通信细节：发送数据，等待确认，给无序到达的数据排序，计算并验证校验和，等等。<li>顶上三层通常构成所谓的用户进程(user process)，底下四层却通常作为操作系统内核的一部分提供。Unix与其他现代操作系统都提供分隔用户进程与内核的机制。</ol><p>由此可见，第4层和第5层之间的接口是构建API的的自然位置。<p><img alt=image-20210313172914195 src=image-20210313172914195.png><p><img alt=image-20210122104917940 src=image-20210122104917940.png><p><strong>网络拓扑的发现</strong><ol><li>netstat -ni，提供网络接口信息，-n标志指定输出数值地址<li>netstat -nr，展示路由表，-n标志指定输出数值地址<li>ifconfig，查看所有接口详细信息<li>ifconfig eth0，查看eth0接口的详细信息</ol><p><strong>POSIX是Portable Operating System Interface的首字母的缩写，可移植操作系统接口。</strong><p>现有32位Unix系统上共同的编程模型称为ILP32模型，表示整数（I）、长整数（L)、指针（P）都占用32位<p>64位Unix系统上变得最为流行的模型称为LP64模型，表示只有长整数（L）、指针（P）占用64位<p>LP64模型意味着我们不能假设一个指针能存放在一个整数中。<table><thead><tr><th>数据类型<th>ILP32<th>LP64<tbody><tr><td>char<td>8<td>8<tr><td>short<td>16<td>16<tr><td>int<td>32<td>32<tr><td>long<td>32<td>64<tr><td>指针<td>32<td>64</table><h2 id=zhang-jie-mo-xi-ti>章节末习题：</h2><p>第三题：<p>修改client socket(AF_INET, SOCK_STREAM, 0) AF_INET成9999，结果报socket error: Address family not supported by protocol family ，经查询：AF_INET本身代表了protocol family的一个特殊标记值，如果修改成其他值，相当于一个新的protocol family，那么之后传入的address family当然不会支持了。<p>第四题：<p>client增加一个计数器并打印。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>int</span><span> counter = </span><span style=color:#d08770;>0</span><span>;
</span><span>
</span><span style=color:#b48ead;>while </span><span>( (n = </span><span style=color:#bf616a;>read</span><span>(sockfd, recvline, MAXLINE)) > </span><span style=color:#d08770;>0</span><span>) {
</span><span>    counter++;
</span><span>    recvline[n] = </span><span style=color:#d08770;>0</span><span>;    </span><span style=color:#65737e;>/* null terminate */
</span><span>    </span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#96b5b4;>fputs</span><span>(recvline, stdout) == EOF)
</span><span>        </span><span style=color:#bf616a;>err_sys</span><span>("</span><span style=color:#a3be8c;>fputs error</span><span>");
</span><span>}
</span><span>
</span><span style=color:#bf616a;>printf</span><span>("</span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>",counter);
</span></code></pre><p>第五题：<p>修改server端代码，将原本完整的内容，单字节发送，并查看client端实际执行的read次数。<pre class=language-C data-lang=C style=background-color:#2b303b;color:#c0c5ce;><code class=language-C data-lang=C><span style=color:#bf616a;>snprintf</span><span>(buff, sizeof(buff), "</span><span style=color:#d08770;>%.24s</span><span style=color:#96b5b4;>\r\n</span><span>", </span><span style=color:#96b5b4;>ctime</span><span>(&ticks));
</span><span>
</span><span style=color:#b48ead;>for </span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < </span><span style=color:#96b5b4;>strlen</span><span>(buff); ++i) {
</span><span>    </span><span style=color:#bf616a;>Write</span><span>(connfd, &(buff[i]), </span><span style=color:#d08770;>1</span><span>);
</span><span>}
</span><span>
</span><span style=color:#bf616a;>Close</span><span>(connfd);
</span></code></pre><p>实际执行client端，每次执行read的counter都在变化。</div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>