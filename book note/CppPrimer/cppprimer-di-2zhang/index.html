<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>PL</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/CppPrimer/cppprimer-di-2zhang/">C++ Primer 第2章 变量和基本类型</a></h1><div class=post-meta-inline><span class=post-date> 2018-06-09 </span></div><div class=post-content><p>C++ Primer 第2章 变量和基本类型<h2 id=2-1-ji-ben-nei-zhi-lei-xing>2.1 基本内置类型</h2><p>C++定义了一套包括算术类型和空类型在内的基本数据类型。<h3 id=2-1-1-suan-zhu-lei-xing>2.1.1 算术类型</h3><p>算术类型分为两类：整型和浮点型。算术类型的尺寸在不同机器上有所差别。<table><thead><tr><th>类型<th>含义<th>最小尺寸<th>常见<tbody><tr><td>bool<td>布尔类型<td>未定义<td><tr><td>char<td>字符<td>8位<td><tr><td>wchar_t<td>宽字符<td>16位<td><tr><td>char16_t<td>Unicode字符<td>16位<td><tr><td>char32_t<td>Unicode字符<td>32位<td><tr><td>short<td>短整型<td>16位<td><tr><td>int<td>整型<td>16位<td><tr><td>long<td>长整型<td>32位<td><tr><td>long long<td>长整型<td>64位<td><tr><td>float<td>单精度浮点数<td>6位有效数字<td>32位<tr><td>double<td>双精度浮点数<td>10位有效数字<td>64位<tr><td>long double<td>扩展精度浮点数<td>10位有效数字<td>96或128位</table><p>除去布尔型和扩展的字符型之外，其它整型可以划分为<strong>带符号的</strong>和<strong>无符号的</strong>两种。<p>类型int、short、long和long long都是带符合的，通常在类型名前添加unsigned就可以得到无符号类型。<p>字符型被分为了三种：char、signed char和unsifned char。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。<p>C++标准没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。<p>在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，在另一些机器上是无符号的。<p>执行浮点数运算选用double，因为float通常精度不够而双精度浮点数和单精度浮点数的计算代价相差无几，甚至double比float快。<h3 id=2-1-2-lei-xing-zhuan-huan>2.1.2 类型转换</h3><p>类型所能表示的值的范围决定了转换的过程：<ul><li><p>当我们将非布尔型的算术值赋值给布尔类型时，初始值为0则结果为false，否则为true</p><li><p>当我们将布尔值赋值给非布尔型时，初始值为false则结果为0，初始值为true结果为1</p><li><p>将浮点数赋值给整数类型，保留浮点数小数点前的部分</p><li><p>将整数值赋值给浮点型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失</p><li><p>当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示值总数取模后的余数。</p> <p>8位的unsigned char表示0到255区间的数，则表示值总数为256</p><li><p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。</p></ul><p>如果表达式里既有带符号类型又有无符号类型，带符号类型会转换成无符号类型。<h3 id=2-1-3-zi-mian-zhi-chang-liang>2.1.3 字面值常量</h3><p>整型字面值的表示方法：<ul><li>十进制：20<li>八进制：<strong>0</strong>24<li>十六进制：<strong>0x</strong>14</ul><p>整型字面值的数据类型：<ul><li>默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的<li>十进制字面值的类型是int、long和long long中能容纳其数值值的最小尺寸的那个<li>八进制和十六进制字面值的类型是能容纳其数值的int、unsinged int、long、unsigned long、long long和unsigned long long中尺寸最小者<li>十进制字面值可以是带符号类型，严格说十进制字面值不会是负数，负号并不在字面值之内，仅仅是对字面值取负值而已</ul><p>浮点型字面值的表示方法：<ul><li>小数表示：3.14159<li>科学计数法：3.14159<strong>E</strong>0、0<strong>e</strong>0</ul><p>浮点型字面值的类型：double<p>字符和字符串字面值：<ul><li>由单引号括起来的一个字符称为char型字面值：‘a’<li>由双引号括起来的零个或多个字符则构成字符串型字面值：“Hello”</ul><p>字符串字面值的类型<strong>实际上</strong>是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符（‘\0’），因此字符串字面值的实际长度比内容多1。<p>如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span>std::cout << "</span><span style=color:#a3be8c;>a really, really</span><span>"
</span><span>            "</span><span style=color:#a3be8c;>two lines</span><span>" << std::endl;
</span></code></pre><p>有两类字符不能直接使用：<ol><li>不可打印字符：退格或其他控制字符<li>特殊含义字符：单引号、双引号、问号、反斜线</ol><p>以上两种情况需要用的转义序列：以反斜线开始+字符<p>可通过添加类型前缀和后缀改变字面值默认类型：<ul><li>字符和字符串字面值通过设置前缀<li>整型和浮点型字面值通过设置后缀</ul><h2 id=2-2-bian-liang>2.2 变量</h2><p>变量提供一个具名的、可供程序操作的存储空间。<h3 id=2-2-1-bian-liang-ding-yi>2.2.1 变量定义</h3><p>区分对象和变量：遵循多数人习惯，将具有某种数据类型的内存空间认为是对象<p>当对象在创建时获得一个特定的值，则成对象被初始化了。<p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值是把对象的当前值擦除，而以一个新值来替代。<p><strong>列表初始化</strong><p>变量初始化有四种形式：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> a = </span><span style=color:#d08770;>0</span><span>;
</span><span style=color:#b48ead;>int</span><span> a = {</span><span style=color:#d08770;>0</span><span>};
</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>a</span><span>{</span><span style=color:#d08770;>0</span><span>};
</span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>a</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span></code></pre><p>C++11开始花括号初始化变量得到了全面应用，这种初始化形式称为列表初始化。<p>当用于内置类型的变量时，列表初始化有个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，编译器将报错。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>long double</span><span> ld = </span><span style=color:#d08770;>3.1415926536</span><span>;
</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>a</span><span>{ld}, b = {ld};    </span><span style=color:#65737e;>//错误，因为存在丢失信息的风险
</span><span style=color:#b48ead;>int</span><span> d = ld;        </span><span style=color:#65737e;>//正确，且确实丢失部分值
</span></code></pre><p>默认初始化，变量没有指定处值将被赋予默认值，由变量类型决定，且受定义变量位置影响：<ul><li>定义于任何函数体之外的变量被初始化为0<li>函数体内部的内置类型变量不被初始化，未被初始化的内置类型变量的值是未定义的</ul><h3 id=2-2-2-bian-liang-sheng-ming-he-ding-yi-de-guan-xi>2.2.2 变量声明和定义的关系</h3><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可悲独立编译。<p>为了支持分离式编译，C++将声明和定义区分开来：<ul><li>声明：使得名字为程序所知，一个文件如果使用别处定义的名字则必须包含对那个名字的声明。<li>定义：负责创建与名字关联的实体，申请存储空间，可能还会赋初值</ul><p>如果想要声明一个变量而非定义它，就在变量名添加关键字extern，并不要显示地初始化变量。【任何包含了显示初始化的声明即成为定义】<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>extern int</span><span> i;    </span><span style=color:#65737e;>//声明i而非定义i
</span><span style=color:#b48ead;>int</span><span> j;            </span><span style=color:#65737e;>//声明并定义j
</span><span style=color:#b48ead;>extern double</span><span> pi = </span><span style=color:#d08770;>3.1416</span><span>;    </span><span style=color:#65737e;>//定义
</span></code></pre><p>在函数体内部如果试图初始化一个由extern关键字标记的变量，将引发错误。<p>变量只能定义一次，可以多次声明。<p>C++是一种静态类型的语言，其含义是编译阶段检查类型，其过程称为类型检查。<h3 id=2-2-3-biao-shi-fu>2.2.3 标识符</h3><p>标识符由字母、数字或下划线组成，必须以字母或下划线开头。标识符对长度无限制，对大小写敏感。<ul><li>C++语言保留一些名字供语言本身使用，不可用作标识符<li>C++为标准库保留一些名字，用户定义的标识符不能连续出现两个下划线开头，不能出现下划线紧连大写字母开头<li>定义在函数体外的标识符不能以下划线开头</ul><p>变量命名规范：<ul><li>标识符要体现实际含义<li>变量名一般使用小写字母<li>用户自定义的类名一般使用大写字母开头<li>如果标识符由多个单词组成，可以用下划线分隔或驼峰命名：student_loan、studentLoan</ul><h3 id=2-2-4-ming-zi-de-zuo-yong-yu>2.2.4 名字的作用域</h3><p>作用域是程序的一部分，大多数作用域都以花括号分隔。同一个名字在不同的作用域可能指向不同的实体。<p>名字main定义于所有花括号之外，和其它大多数定义在函数体之外的名字一样拥有全局作用域。全局作用域的名字在整个程序的范围内都可使用。定义于函数体内，则拥有块作用域，访问范围仅限块内。<p>作用域能彼此包含，被包含的作用域称为内层作用域，包含着别的作用域的作用域称为外层作用域。<h2 id=2-3-fu-he-lei-xing>2.3 复合类型</h2><p>复合类型：基于其他类型定义的类型。引用和指针属于复合类型。<h3 id=2-3-1-yin-yong>2.3.1 引用</h3><p>引用：左值引用，为对象起了另一个名字。定义引用时，程序将它和它的初始值对象绑定在一起，并无法重新绑定到另一个对象，因此引用必须初始化。<p>引用并非对象，是一个已经存在的对象的别名，因为引用本身不是对象，所以无法定义引用的引用。<p>引用标识符都必须以&开头：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>1024</span><span>;
</span><span style=color:#b48ead;>int </span><span>&r = i;
</span></code></pre><h3 id=2-3-2-zhi-zhen>2.3.2 指针</h3><p>指针是”指向“另一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。<p>指针和引用的不同点：<ol><li>指针本身就是一个对象，允许指针赋值和拷贝，可以修改指向<li>指针无须定义时赋初值</ol><p>指针存放某个对象的地址，要获取该地址，需要使用取地址符(操作符&)<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> ival = </span><span style=color:#d08770;>42</span><span>;
</span><span style=color:#b48ead;>int </span><span>*p = &ival;
</span></code></pre><p>引用不是对象，无法定义指向引用的指针。指针的类型与指向对象的类型必须相同。<p>指针的值应属于4种状态之一：<ol><li>指向一个对象<li>指向紧邻对象所占空间的下一个位置<li>空指针 ，意味着没有指向对象<li>无效指针，上述情况之外的其他值</ol><p>解引用符（操作符*）：对指针解引用会得出所指的对象，因此对解引用的结果赋值，实际上也就是给指针所指对象赋值。<strong>解引用操作仅适用于哪些确实指向了某个对象的有效指针</strong>。<p>空指针不指向任何对象，生成空指针的方法：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int </span><span>*p1 = </span><span style=color:#d08770;>nullptr</span><span>;    </span><span style=color:#65737e;>//等价于int *p1 = 0;
</span><span style=color:#b48ead;>int </span><span>*p2 = </span><span style=color:#d08770;>0</span><span>;        </span><span style=color:#65737e;>//直接初始化为字面常量0
</span><span style=color:#65737e;>//需要首先#include cstdlib
</span><span style=color:#b48ead;>int </span><span>*p3 = </span><span style=color:#d08770;>NULL</span><span>;        </span><span style=color:#65737e;>//等价于int *p3 = 0;
</span></code></pre><p>nullptr是C++11后引入的方法，nullptr是一种特殊类型的字面值，可以转换成任意其他指针类型。NULL是预处理变量，它的值是0。<p>对于两个类型相同的合法指针，可以进行比较，比较结果是bool类型：如果指针存放的地址值相同则相等。<p>void*指针：特殊类型的指针，可用于存放任意对象的地址。不能直接操作void*指针所指的对象，因为我们不知道这个对象到底是什么类型，也无法确定能做哪些操作。<h3 id=2-3-3-li-jie-fu-he-lei-xing-de-sheng-ming>2.3.3 理解复合类型的声明</h3><p>在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就可以定义出不同类型的变量：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>1024</span><span>, *p = &i, &r = i;
</span></code></pre><p>建议将操作符*（或是&）与变量名连在一起，强调变量具有的复合类型。<p>一般来说，声明符中修饰符的个数没有限制，当多个修饰符连写在一起时，按照其逻辑憨详加解释即可。**表示指向指针的指针，***表示指向指针的指针的指针，以此类推。<p>引用本身不是对象，不能定义指向引用的指针。<p>指针是对象，存在对指针的引用。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>42</span><span>;
</span><span style=color:#b48ead;>int </span><span>*p;
</span><span style=color:#b48ead;>int </span><span>*&r = p;    </span><span style=color:#65737e;>//对指针p的引用
</span><span>
</span><span>r = &i;
</span><span>*r = </span><span style=color:#d08770;>0</span><span>;        </span><span style=color:#65737e;>//i的值变为0
</span></code></pre><p><strong>理解r的类型是什么：从右向左阅读r的定义</strong>：离变量名最近的符号对变量的类型有直接影响，所以r是一个引用。声明符的其余部分用以确定r引用的类型是什么，所以r引用的类型是一个int指针。<h2 id=2-4-constxian-ding-fu>2.4 const限定符</h2><p>const限定符对变量的类型加以限定，防止其值被修改。<p>因为const对象一旦创建后不能再修改，所以const对象必须初始化。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const int</span><span> i = </span><span style=color:#bf616a;>get_size</span><span>();    </span><span style=color:#65737e;>//正确：运行时初始化
</span><span style=color:#b48ead;>const int</span><span> j = </span><span style=color:#d08770;>42</span><span>;            </span><span style=color:#65737e;>//正确：编译时初始化
</span><span style=color:#b48ead;>const int</span><span> k;                </span><span style=color:#65737e;>//错误：未经初始化
</span></code></pre><p>const类型的对象上不能执行改变其内容的操作。const限定符仅仅在执行改变其值的操作时才发挥作用。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>42</span><span>;
</span><span style=color:#b48ead;>const int</span><span> ci = i;    </span><span style=color:#65737e;>//正确：i的值拷贝给ci
</span><span style=color:#b48ead;>int</span><span> j = ci;            </span><span style=color:#65737e;>//正确：ci的值拷贝给j
</span></code></pre><p>默认情况下，const对象被设定为仅在文件内有效，当多个文件出现了同名const变量时，其实等同于在不同文件中分别定义了独立的变量。<p>若想要多个文件共享一个const变量，则不管声明还是定义都添加extern关键字，这样只需定义一次就可以了。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//定义并初始化一个常量，该常量能被其他文件访问
</span><span style=color:#b48ead;>extern const int</span><span> bufSize = </span><span style=color:#bf616a;>fcn</span><span>();
</span><span style=color:#65737e;>//在另一个文件声明使用
</span><span style=color:#b48ead;>extern const int</span><span> buffSize；
</span></code></pre><h3 id=2-4-1-constde-yin-yong>2.4.1 const的引用</h3><p>可以把引用绑定到const对象上，称为<strong>对常量的引用</strong>，对常量的引用不能修改它所绑定的对象。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const int</span><span> ci = </span><span style=color:#d08770;>1024</span><span>;
</span><span style=color:#b48ead;>const int </span><span>&r1 = ci;    </span><span style=color:#65737e;>//正确，引用及其对应的对象都是常量
</span><span>r1 = </span><span style=color:#d08770;>42</span><span>；    </span><span style=color:#65737e;>//错误：r1是对常量的引用
</span><span style=color:#b48ead;>int </span><span>&r2 = ci;    </span><span style=color:#65737e;>//错误：试图让一个非常量引用指向一个常量对象
</span></code></pre><p>引用的类型必须与其所引用的对象的类型一致，但是有两个例外：<ol><li>在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可<li>允许为一个常量引用绑定非常量对象、字面值，甚至是个一般表达式</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>42</span><span>;
</span><span style=color:#b48ead;>const int </span><span>&r1 = i;        </span><span style=color:#65737e;>//正确
</span><span style=color:#b48ead;>const int </span><span>&r2 = </span><span style=color:#d08770;>42</span><span>;        </span><span style=color:#65737e;>//正确
</span><span>cosnt </span><span style=color:#b48ead;>int </span><span>&r3 = r1 * </span><span style=color:#d08770;>2</span><span>;    </span><span style=color:#65737e;>//正确
</span><span style=color:#b48ead;>int </span><span>&r4 = r1 * </span><span style=color:#d08770;>2</span><span>;        </span><span style=color:#65737e;>//错误
</span></code></pre><p>能够这样的原因，是产生了一个临时变量，临时变量通过绑定的对象进行初始化，接着绑定到引用上。如此，如果引用类型不是const，则可以通过引用修改到临时变量，这是非法的。<h3 id=2-4-2-zhi-zhen-he-const>2.4.2 指针和const</h3><p>指向常量的指针：存放常量对象的地址。<p>指针类型必须与其所指对象的类型一致，但是有两个例外：<ol><li><p>允许另一个指向常量的指针指向一个非常量对象</p> <p>指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变</p><li><p>占位</p></ol><p>指针是对象而引用不是，允许把指针本身定为常量。<strong>常量指针</strong>必须初始化，一旦初始化完成就不能改变。常量指针不变的是指针本身的值而不是指向的那个值。<p><strong>弄清楚声明的含义：从右向左阅读，离变量名最近的对变量有直接影响，其余部分确定对象的类型</strong>。<h3 id=2-4-3-ding-ceng-const>2.4.3 顶层const</h3><p>指针本身是一个对象，可以指向另一个对象，指针本身是常量以及指针所指的是不是一个常量是两个相互独立的问题。<p><strong>顶层const</strong>表示指针本身是个常量。<p><strong>底层const</strong>表示指针所指的对象是一个常量（指针的类型包含const）。<p>拷贝操作时，顶层const和底层const的区别：<ol><li>顶层const不受什么影响<li>底层const存在限制，要么拷入拷出的对象都是具有底层const资格，要么能够转换：非常量可以转常量，反之不行</ol><h3 id=2-4-4-constexprhe-chang-liang-biao-da-shi>2.4.4 constexpr和常量表达式</h3><p>常量表达式：值不会发生改变并且在<strong>编译过程</strong>就能够得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。<p>在一个复杂的系统，很难分辨一个初始值到底是不是常量表达式，C++11新标准规定，允许变量声明为constexpr类型，以便由编译器来验证变量的值是否是一个常量表达式。<p>声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。<p>尽管普通函数不能作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数，这种函数应该足够简单以使得编译时就可以计算出结果，这样就能用constexpr函数去初始化constexpr变量了。<p>常量表达式需要编译时就得到计算，因此对声明constexpr时用的的类型必须有所限制，这些类型一般比较简单，值也显而易见、容易得到，称为“字面值类型”。<p>算术类型、引用和指针都属于字面值类型，其中引用和指针受严格限制。一个constexpr指针的初始值必须是nullptr或者0，或是存储于某个固定地址中的对象。<p>函数体内部定义的变量一般来说并非存在固定地址，函数体之外的对象地址固定不变，函数可以定义有效范围超出函数本身的变量，这些变量也有固定地址。<p>在constexpr声明中如果定义了一个指针，限定符constexpr只对指针有效，与指针所指对象无关。<p>constexpr指针既可以指向常量也可以指向一个非常量，如果是非常量，则非常量的存储地址必须是固定的。<h2 id=2-5-chu-li-lei-xing>2.5 处理类型</h2><h3 id=2-5-1-lei-xing-bie-ming>2.5.1 类型别名</h3><p>两种方法定义类型别名：<ol><li>传统的方法是使用关键字<strong>typedef</strong><li>C++11新标准规定了新的方法，使用<strong>别名声明</strong>来定义类型的别名：using</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>typedef char </span><span>*pstring;
</span><span style=color:#b48ead;>const</span><span> pstring cstr = </span><span style=color:#d08770;>0</span><span>;        </span><span style=color:#65737e;>//cstr是指向char的常量指针
</span><span style=color:#b48ead;>const</span><span> pstring *ps；            </span><span style=color:#65737e;>//ps是一个指针，它的对象是指向char的常量指针；
</span><span>
</span><span style=color:#b48ead;>const char </span><span>*cstr2 = </span><span style=color:#d08770;>0</span><span>;        </span><span style=color:#65737e;>//指向const char的指针
</span></code></pre><p><del>使用类型别名的声明语句时，尝试将类型名替换成本来的样子，以理解该语句的含义</del>，这是错误的理解。<h3 id=2-5-2-autolei-xing-shuo-ming-fu>2.5.2 auto类型说明符</h3><p>C++11新标准引入了auto类型说明符，用它能让编译器替我们分析表达式所属的类型。auto让编译器通过初始值推算变量类型，因此，auto定义的变量必须有初始值。<p>编译器推断出来的auto类型有时候和初始值的类型并不完全一致，编译器会适当地改变结果类型使其更复合初始化规则。<ol><li><p>编译器以引用对象的类型作为auto的类型：</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>, &r = i;
</span><span style=color:#b48ead;>auto</span><span> a = r;            </span><span style=color:#65737e;>//a是一个整数（r是i的别名，而i是一个整数）
</span></code></pre><li><p>auto一般会忽略掉顶层const，同时底层const则会被保留下来</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const int</span><span> ci = i, &cr = ci;
</span><span style=color:#b48ead;>auto</span><span> b = ci;    </span><span style=color:#65737e;>//b是一个整数（ci的顶层const特性被忽略掉了）
</span><span style=color:#b48ead;>auto</span><span> c = cr;    </span><span style=color:#65737e;>//c是一个整数（cr是ci的别名，ci本身是一个顶层const）
</span><span style=color:#b48ead;>auto</span><span> d = &i;    </span><span style=color:#65737e;>//d是一个整型指针（整数的地址就是指向整数的指针）
</span><span style=color:#b48ead;>auto</span><span> e = &ci;    </span><span style=color:#65737e;>//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）
</span></code></pre><li><p>如果希望推断出的auto类型是一个顶层const，需要明确指出：</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const auto</span><span> f = ci;    </span><span style=color:#65737e;>//ci的推演类型是int，f是const int
</span></code></pre><li><p>还可以将引用类型设为auto，此时原来的初始化规则仍然适用：</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>auto </span><span>&g = ci;    </span><span style=color:#65737e;>//g是一个整型常量引用，绑定到ci
</span><span style=color:#b48ead;>auto </span><span>&h = </span><span style=color:#d08770;>42</span><span>;    </span><span style=color:#65737e;>//错误：不能为非常量引用绑定字面值
</span><span style=color:#b48ead;>const auto </span><span>&j = </span><span style=color:#d08770;>42</span><span>;    </span><span style=color:#65737e;>//正确：可以为常量引用绑定字面值
</span></code></pre> <p><strong>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。</strong>==和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。==</p> <pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//对加粗语句的理解,auto引用
</span><span style=color:#b48ead;>auto </span><span>&g = ci;    </span><span style=color:#65737e;>//g具有顶层常量，ci是常量，g也是常量
</span><span style=color:#65737e;>//对高亮语句理解，普通引用
</span><span style=color:#b48ead;>const int </span><span>&g = ci;    </span><span style=color:#65737e;>//g具有底层常量，只有g引用的对象是常量
</span></code></pre></ol><p>要在一条语句中定义多个变量，符号&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种数据类型：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>auto</span><span> k = ci, &l = i;    </span><span style=color:#65737e;>//k是整数，l是整数引用
</span><span style=color:#b48ead;>auto </span><span>&m = ci, *p = &ci;    </span><span style=color:#65737e;>//m是对整型常量的引用
</span><span style=color:#65737e;>//错误：i的类型是int而&ci的类型是const int
</span><span style=color:#b48ead;>auto </span><span>&n = i, *p2 = &ci;
</span></code></pre><h3 id=2-5-3-decltypelei-xing-zhi-shi-fu>2.5.3 decltype类型指示符</h3><p>C++11新标准引入类型说明符decltype：选择并返回操作数的数据类型。在此过程，编译器分析表达式并得到它的类型，却不实际计算表达式的值。<p>decltype处理顶层const和引用的方式和auto有些许不同。<p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const int</span><span> ci = </span><span style=color:#d08770;>0</span><span>, & cj = ci;
</span><span style=color:#b48ead;>decltype</span><span>(ci) x = </span><span style=color:#d08770;>0</span><span>;    </span><span style=color:#65737e;>//x的类型是const int
</span><span style=color:#b48ead;>decltype</span><span>(cj) y = x;    </span><span style=color:#65737e;>//y的类型是const int&, y绑定到变量x
</span><span style=color:#b48ead;>decltype</span><span>(cj) z;    </span><span style=color:#65737e;>//错误：z是一个引用，必须初始化
</span></code></pre><p>引用从来都是作为其所指对象的同义词出现，只有在decltype处是个例外。<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。有些表达式向decltype返回一个引用类型，则该表达式的结果对象能作为一条赋值语句的左值：<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>42</span><span>, *p = &i, &r = i;
</span><span style=color:#b48ead;>decltype</span><span>(r + </span><span style=color:#d08770;>0</span><span>) b;    </span><span style=color:#65737e;>//正确：加法的结果是int
</span><span style=color:#b48ead;>decltype</span><span>(*p) c;        </span><span style=color:#65737e;>//错误：c是int&，必须初始化
</span></code></pre><p>decltype和auto的另一处重要区别是：decltype的结果类型与表达式<strong>形式</strong>密切相关。<p>如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。<pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>decltype</span><span>((i))     d;    </span><span style=color:#65737e;>//错误：d是int&，结果将是引用
</span><span style=color:#b48ead;>decltype</span><span>(i)     e;    </span><span style=color:#65737e;>//正确：e是一个int
</span></code></pre><p>==<strong>decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用</strong>==<h2 id=2-6-zi-ding-yi-shu-ju-jie-gou>2.6 自定义数据结构</h2><p>类以关键字struct开始，紧跟类名和类体。类体由花括号包围形成了一个新的作用域，类内部定义的名字可以与类外部定义的名字重复，但是在类内必须唯一。类体右侧的表示结束的花括号后必须写一个分号，和定义变量一个道理。<p>类的定义和对象的定义可以放一起，但是不推荐，这样将两种不同实体的定义混在一句语句里，一会定义类，一会定义变量。<p>C++11新标准规定，可以为数据成员提供一个类内初始值。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。<p>类内初始值的限制：可以放花括号，或者放在等号右边，<strong>不能</strong>使用圆括号。<p>用户可以使用C++语言提供的另一个关键字class来定义自己的数据结构。<h3 id=2-6-3-bian-xie-zi-ji-de-tou-wen-jian>2.6.3 编写自己的头文件</h3><p>函数体内部定义类，将受到一些限制。所以一般类不定义在函数体内。当在函数体外定义类时，在各个指定的源文件可能只有一处该类的定义，如果要在不同文件中使用同一个类，类的定义就必须保持一致。<p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。<p>头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。在书写类的时候，可以通过适当处理，使得多次包含同一个头文件的情况也能安全和正常地工作。<p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>，它由C++语言从C语言继承而来。<p>预处理器是编译之前执行的一段程序，可以部分地改变我们所写的程序。如：当预处理器看到#include标记时就会用指定的头文件的内容代替#include。<p>C++程序还会使用一项预处理功能是<strong>头文件保护符</strong>：依赖于预处理变量。预处理变量有两种状态：已定义和未定义。<ol><li>#define：指令把一个名字设为预处理变量<li>#ifdef：当且仅当变量已定义时为真<li>#ifndef：当且仅当变量未定义时为真<li>一旦检查结果为真，则执行后续操作，直至遇到#endif 指令为止<li>一旦检查结果不为真，编译器将忽略#ifndef（或#ifdef）到#endif之间的部分</ol><p><strong>预处理变量无视C++语言中关于作用域的规则</strong><p>为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>