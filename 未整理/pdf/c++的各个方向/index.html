<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「工作日还有多少天，休息日还剩几小时」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">

</div>

<div class="content-area">
	<div class="title">
		
	</div>
	
	<div class="page-date">
		2021-11-07
	</div>
	
	<div class="category-area">
		
			
		
	</div>
	
	<div class="content">
		<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602988 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 14pt;
    }
  </style>
</head>
<body>
<a name="9331"/>

<div>
<span><div><div><span style="font-size: 15px; color: unset; font-family: unset;">游戏引擎：</span></div><div><div><div><div style="min-width: 100%; position: relative;"><div style="background: rgb(246, 246, 246); -webkit-tap-highlight-color: rgba(18, 18, 18, 0); overflow: auto;"><div style="-webkit-box-pack: justify; justify-content: space-between; -webkit-box-align: start;"><div style="background: rgb(255, 255, 255); border-radius: 2px; box-shadow: rgba(18, 18, 18, 0.1) 0px 1px 3px; box-sizing: border-box; overflow: initial;"><div style="overflow: hidden;"><div style="font-size: 15px; margin: 0px 0px 1.4em;"><span style="font-size: 15px;">现在已经没有人自研引擎了。</span><span style="font-size: 15px; color: unset; font-family: unset;">学完了Dx12,写点玩具然后研究现有的，在工作中需要做出一定的改动时候能改的动就好。</span><span style="font-size: 12pt; background-color: transparent; color: unset; font-family: unset;">游戏开发（基于UE4的c++方向）,也需要大量的代码。</span></div><div style="margin: 0px 0px 1.4em;"><span style="font-size: 12pt; background-color: transparent; color: unset; font-family: unset;">Orge已死，勿念 </span><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/344717773/answer/816411033" style="font-size: 8pt;">https://www.zhihu.com/question/344717773/answer/816411033</a></div><div style="font-size: 15px; margin: 0px 0px 1.4em;"></div></div></div></div></div></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">基础设施和超大型软件应用领域</span></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">c++具有统治地位的方向，主要就是基础设施和超大型软件应用领域。</span></div><div><span style="font-size: 12pt;">    比如：</span><span style="font-size: 12pt; color: unset; font-family: unset;">数据库，编辑器，编译器，脚本引擎，虚拟机，排版软件，游戏引擎，应用程序框架，计算平台等。</span><span style="font-size: 12pt; color: unset; font-family: unset;">代表性的项目有，MySQL，VisualStudio，LLVM，V8，VMWare，Office／WPS，3DMAX，Qt，WebRTC，Tensorflow等</span></div><div><span style="font-size: 12pt;">    可以看出来，都不是小项目，源代码都是上百万行，甚至千万行的，并且都有很长的历史，有的多达30+年。</span><span style="font-size: 12pt; color: unset; font-family: unset;">这类项目采用C++一方面是历史惯性，一方面是C++的性能在这些特地领域的确有优势，比如C++和C 汇编混合调用的时候几乎没有额外开销，而Java的JNI，Golang的CGO都是有额外成本的。</span></div><div><br/></div><div><span style="font-size: 12pt;">    对于刚进入软件开发领域的年轻人来说 C++并不友好，新的工作机会的确在变少，而现有的项目需要的基本功和相关知识积累又非常高，不是初如职场的新人可以快速掌握的，除非你很聪明勤奋，又有很大决心去学习，比如 编译器，数据库领域，再聪明勤奋也要学很多年，而且要有丰富经验的业界前辈来指导。在这些领域C++本身不是问题，难的是领域相关知识技能。</span></div><div><br/></div><div><span style="font-size: 12pt;">    选择了C++就要断了速成和赚快钱的念头，要潜心研究慢慢积累，花5-10年去深入某个领域，这需要很大的决心毅力，别太在乎投入产出比。</span><span style="font-size: 12pt; color: unset; font-family: unset;">虽然我写了二十年C++，也用C++写了些大项目，但是我已经在逐步放弃C++了，最近一年里用得最多的是Golang，Python，Objective-c，Java。</span><span style="font-size: 12pt; color: unset; font-family: unset;">因为我的领域是应用开发，是面向广大最终用户的应用，这个领域越来越强调开发效率，对性能到不是那么介意，C++显然很难胜任。</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">    </span><span style="font-size: 12pt; color: unset; font-family: unset;">服务端的瓶颈已经不是计算性能了，而是传输、IO、伸缩性，并行度等</span><span style="font-size: 12pt; color: unset; font-family: unset;">游戏开发除非是引擎，业务逻辑剧情基本都是写脚本了，而除非是大公司有积累，否则也不会自己撸引擎。</span></div><hr/><div><span style="font-weight: bold;">图形引擎    </span></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/337194124" style="font-size: 8pt; font-weight: bold;">https://www.zhihu.com/question/337194124</a></div></div><div><br/></div><div><span style="font-size: 12pt;">首先需要考虑的是你想要应聘什么企业的什么岗位。然后看看这个岗位的JD（Job Description），看看其中的要求，然后根据这个结合你自己的特长考虑DEMO的内容。</span></div><div><span style="font-size: 12pt;">比如影视特效方向，那么可能结合影视特效制作软件进行演示效果会较好；</span></div><div><span style="font-size: 12pt;">如果是TA或者内容制作工具链方向，那么写DCC插件或者Unity/UE插件进行演示效果会较好；</span></div><div><span style="font-size: 12pt;">如果是</span><span style="font-size: 12pt; font-weight: bold;">大厂自研引擎或者图形优化方向</span><span style="font-size: 12pt;">，则展示对</span><span style="font-size: 12pt; font-weight: bold;">C/C++以及图形API的熟悉程度</span><span style="font-size: 12pt;">可能效果较好。</span></div><div><span style="font-size: 12pt;">总之</span><span style="font-size: 12pt; font-weight: bold;">正儿八经的图形学</span><span style="font-size: 12pt;">行当可能对新毕业的学生是不大友好的，</span><span style="font-size: 12pt; font-weight: bold;">重要岗位还是靠圈子里的脸熟</span><span style="font-size: 12pt;">，也就是推荐。所以新毕业的还是要以熟悉业界环境为首要任务，找个有实力的工作室跟个好的老师傅混几年再说。</span></div><div><span style="font-size: 12pt;">当然如果不纠结薪水和工作强度，也可以找诸如中国之星等优秀中小团队，然后到我这里来学主机游戏图形优化方面的知识。这样可以较早独立，今后进大厂也不会太难。只不过经济和工作强度方面压力可能很大，请结合自己的情况考虑。</span></div><div><span style="font-size: 12pt;">another: </span><span style="font-size: 12pt; color: rgb(18, 18, 18); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;">做software render和ray tracer两件套证明自己基础扎实，面试官也有东西问</span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-weight: bold;">编译器</span></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/362648120/answer/1660281076" style="font-size: 8pt;">https://www.zhihu.com/question/362648120/answer/1660281076</a></div><div><br/></div><div><span style="font-size: 12pt;">    “编译器”不是一个单一的东西，是一整个stack：最顶层是语言规范，然后才有了实现语言的前端。有语言无关硬件无关的中端（middle-end），还有硬件相关的后端。我来说一下我对</span><span style="font-size: 12pt; font-weight: bold;">工业界</span><span style="font-size: 12pt;">各部分的印象。</span></div><div><br/></div><div><span style="font-size: 12pt;">    语言规范是最杂乱无章的，因为这是一个社会问题多过一个技术问题，这是一个哪些公司跟哪些公司利益相关，哪些人跟哪些人的编程信条一致的问题。工业界语言的设计动机都非常务实，就是帮程序员省时间帮公司省钱。语言的媒体曝光率最高，因为各种语言程序员都能看懂个大概，语言对编程效率影响也最大。</span></div><div><br/></div><div><span style="font-size: 12pt;">    编译器前端本身是用软件工程实现语言，本身并没有太多玄机，但是很多给力的特性比如static analysis，large scale refactoring都需要前端支持。</span><span style="font-size: 12pt; font-weight: bold;">中端是最讲算法的部分，图的连通性，深度和广度优先搜索，强连通分量，最短路，拓扑排序这些基本算法全都用得上。</span><span style="font-size: 12pt;">后端思维方式是硬件思维，代码需要嵌入大量硬件相关的信息，并且有很多后端相关的优化。后端的优化相对中端更局部一些。</span></div><div><br/></div><div><span style="font-size: 12pt;">    这篇文章非常乱，但是大致可以抽出来这么几个点：</span></div><div><span style="font-size: 12pt;">1. 这篇文章关注的点在编程语言和编译器前端。</span></div><div><span style="font-size: 12pt;">2. 从计算机科学的角度去评价，工业界编程语言创新不多。</span></div><div><span style="font-size: 12pt;">3. 工业界编译器从业者很多没有计算机科学的学术思维。</span></div><div><span style="font-size: 12pt;">4. 王垠自己的问题。</span></div><div><br/></div><div><span style="font-size: 12pt;">    工业界语言创新不多是真的，而且这可以认为是by design。看这么一大票语言，确实搞来搞去无非是下面这几个特性集：类型系统，垃圾回收，dispatch（vtables，pattern matching，generics），代码复制（macros，templates，generics）。这未必是一个忧伤的结果，因为这些特性都是经过时间筛选下来的结果，教育成本最低，最佳实践最多，商业风险也低。“If it works, don't fix it”。采用较为激进的编程范式一来容易招不到人干活；二来万一语言激进的特性有设计方面的bug，步子太大扯着蛋，很伤business；三来tooling成本很高，能借用已有成果是最好的。很不幸工业界by definition不是做学术研究的。</span></div><div><br/></div><div><span style="font-size: 12pt;">    工业界编译器很多从业者没有计算机科学的学术思维也是真的。软件工程本来就是把大的东西拆得很散，使得每一部分能轻松维护。轻松到什么程度呢，就算不是科班出生的程序员，也能较轻松地维护代码。中端是所有部份中最需要算法和数据结构设计的，所以也最需要计算机科学的功底，也是ACM/ICPC程序员觉得最亲切的地方。后端很多代码在我眼里确实就是“跟猴子拍出来的一样”。当然我很喜欢后端的人玩，他们在硬件领域懂的东西比我多多了。有些后端程序员思维太过具体，我也只是摇头莞尔，不影响社交也不影响工作。</span></div><div><br/></div><div><span style="font-size: 12pt;">    这里我想特别抓出一个非典型：MLIR。MLIR社区里有学者，有工程师，也有硬件从业者。很多是做ML的，也有很多不做ML的。我现在就在做MLIR相关的工作，从做的事情到接触的人个人体验比LLVM好不少。LLVM对我来说过于无聊。MLIR目前只是个DSL工厂，但是给我一点希望，希望可以让PL学者好好研究新一代硬件，发明出崭新的编程语言来抽象当代硬件的方方面面：hierarchical memory space（e.g. cuda memory spaces，multi-device，multi-host），computation parallelism（e.g. multi-device，SPMD，SIMD）。</span></div><div><br/></div><div><span style="font-size: 12pt;">    编译器的问题在于，它要求的技能与常见的软件开发不太一样，如果做parser的话需要对形式语言有一定的了解，同时要求最好有PL相关背景。而做IR设计与优化又有很多学术界或者说是理论知识需要掌握，需要博览群书。最后做后端则要具备计算机体系结构，了解对应的硬件架构，进一步还能做软硬件协同。</span></div><hr/><div><br/></div></div><div>客户端Qt</div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/47128451/answer/179441362" style="font-size: 8pt;">https://www.zhihu.com/question/47128451/answer/179441362</a></div><div>主打嵌入式，客户端整体在缩水，对新人没前途了。且Qt跟不上naive体验。</div><hr/><div><b style="font-size: unset;"><br/></b></div><div><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">服务端开发线</span></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22608820/answer/1129193300" style="font-size: 8pt; font-family: unset;">https://www.zhihu.com/question/22608820/answer/1129193300</a></div></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/giantchen" style="font-size: 11pt; font-family: unset; font-weight: 600; text-decoration-line: none;">陈硕</a></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: 600;">    这两门课程该如何学？看哪些书？</span><span style="font-size: 11pt;">这里我告诉你一个通用的办法，去美国计算机系排名靠前的大学的课程主页，找到这两门课最近几年的课程大纲、讲义、参考书目、阅读材料、随堂练习、课后作业、编程实验、期末项目等，然后你就心里有数了。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: 600;">    注意分清知识的层次</span><span style="font-size: 11pt;">。就好比造汽车与开汽车的区别，我认为一个司机的技能主要体现在各种道路条件和天气状况下都能安全驾驶（城市道路、高速公路、乡间公路 X 晴、雨、雪、雾），平安到达目的地。作为一名司机，了解汽车运行的基本原理当然是好事，可以有助于更好地驾驶和排除一些常见故障。但不宜喧宾夺主，只要你不真正从事汽车设计工作，你再怎么研究发动机、传动、转向，也不可能比汽车厂的工程师强，毕竟这是人家的全职工作。而且钻研汽车构造超过一定程度之后，对开好车就没多大影响了，成了个人兴趣爱好。“有的人学着学着成了语言专家，反而忘了自己原本是要解决问题来的。”（语出孟岩</span> <a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/myan/article/details/3144661" rel="nofollow noreferrer" style="font-size: 11pt; text-decoration: none;" target="_blank">快速掌握一个语言最常用的50%</a><span style="font-size: 11pt;">）</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    对于并发编程来说，掌握 mutex、condition variable 的正确用法，避免误用（例如防止 busy-waiting 和 data race）、避免性能 pitfalls，是一般服务端程序员应该掌握的知识。而如何实现高效的 mutex 则是 libc 和 kernel 开发者应该关心的事，随着硬件的发展（CPU 与内存之间互联方式的改变、核数的增加），最优做法也随之改变。如果你不能持续跟进这一领域的发展，那么你深入钻研之后掌握的知识到了几年之后可能反而成为累赘，当年针对当时硬件的最优特殊做法（好比说定制了自己的 mutex 或 lock-free 数据结构）在几年后有可能反而会拖低性能。还不如按最清晰的方式写代码，利用好语言和库的现成同步设施，让编译器和 libc 的作者去操心“与时俱进”的事。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: 600;">    注意识别过时的知识。</span><span style="font-size: 11pt;">比方说</span><span style="font-size: 11pt; font-weight: 600;">《操作系统》</span><span style="font-size: 11pt;">讲磁盘IO调度往往会讲电梯算法，但是现在的磁盘普遍内置了这一功能（NCQ），无需操作系统操心了。如果你在一个比较好的学校，操作系统课程的老师应该能指出这些知识点，避免学生浪费精力；如果你全靠自学，我也没什么好办法，尽量用新版的书吧。类似的例子还有</span><span style="font-size: 11pt; font-weight: 600;">《计算机体系结构》</span><span style="font-size: 11pt;">中可能会讲 RISC CPU 流水线中的 delay slot，现在似乎也都废弃了。</span><span style="font-size: 11pt; font-weight: 600;">《计算机网络》</span><span style="font-size: 11pt;">中类似的情况也不少，首先是</span> <span style="font-size: 11pt; font-weight: bold;">OSI 七层模型已经被证明是扯淡的，现在国外流行的教材基本都按五层模型来讲（</span><a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Internet_protocol_suite%23Layer_names_and_number_of_layers_in_the_literature" rel="nofollow noreferrer" style="font-size: 11pt; font-weight: bold; text-decoration: none;" target="_blank">Internet protocol suite</a><span style="font-size: 11pt; font-weight: bold;">）</span><span style="font-size: 11pt;">，如果你的教材还郑重其事地讲 OSI （还描绘成未来的希望），扔了换一本吧。其次，局域网层面，以太网一家独大（几乎成了局域网的代名词），FDDI/Token ring/ATM 基本没啥公司在用了。就说以太网，现在也用不到 CSMA/CD 机制（因为 10M 的同轴电缆、10M/100M 的 hub 都过时了，交换机也早就普及了），因此碰撞检测算法要求“以太网的最小帧长大于最大传播延迟的二倍”这种知识点了解一下就行了。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    另外一点是 low level 优化的知识非常容易过时，编码时要避免过度拟合（overfitting）。比方说目前国内一些教科书（特别是大一第一门编程语言的教程）还在传授“乘除法比加减法慢、浮点数运算比整数运算慢、位运算最快”这种过时的知识。现代通用 CPU 上的实际情况是整数的加减法和乘法运算几乎一样快，整数除法慢很多；浮点数的加减法和乘法运算几乎和整数一样快，浮点数除法慢很多。因此用加减法代替乘法（或用位运算代替算术运算）不见得能提速，反而让代码难懂。而且现代编译器可以把除数为小整数的整数除法转变为乘法来做，无需程序员操心。（目前用浮点数乘法代替浮点数除法似乎还是值得一做的，例如除以10改为乘以0.1，因为浮点运算的特殊性（不满足结合律和分配率），阻止了编译器优化。）</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    类似的 low level 优化过时的例子是早年用汇编语言写了某流行图像格式的编解码器，但随着 CPU 微架构的发展，其并不比现代 C 语言（可能用上 SIMD）的版本更快，反而因为使用了 32-bit 汇编语言，导致往 64-bit 移植时出现麻烦。如果不能派人持续维护更新这个私有库，还不如用第三方的库呢。现在能用汇编语言写出比 C 语言更快的代码几乎只有一种可能：使用 CPU 的面向特定算法的新指令，例如 Intel 的新 CPU （将会）内置了 AES、CRC32、SHA1、SHA256 等算法的指令。不过主流的第三方库（例如 OpenSSL）肯定会用上这些手段，及时跟进即可，基本无需自己操刀。（再举一个例子，假如公司早先用汇编语言写了一个非常高效的大整数运算库，一直运转良好，原来写这个库的高人也升职或另谋高就了。Intel 在 2013 年发布了新微架构 Haswell，新增了 MULX 指令，可以进一步提高大整数乘法的效率</span> <a href="https://link.zhihu.com/?target=https%3A//gmplib.org/list-archives/gmp-devel/2013-August/003353.html" rel="nofollow noreferrer" style="font-size: 11pt; text-decoration: none;" target="_blank">GMP on Intel Haswell</a> <span style="font-size: 11pt;">，那么贵公司是否有人持续跟进这些 CPU 的进化，并及时更新这个大整数运算库呢？或者直接用开源的 GMP 库，让 GMP 的作者去操心这些事情？）</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: 600;">    如果你要记住结论，一定要同时记住前提和适用条件。</span><span style="font-size: 11pt;">在错误的场合使用原本正确的结论的搞笑例子举不胜举。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    最后一点小建议，服务端开发这几年已经普及 64-bit 多核硬件平台，因此在学习操作系统的时候，可以不必太关心单核上特有的做法（在单核时代，内核代码进入临界区的办法之一是关中断，但到了多核时代，这个做法就行不通了），也不必太花精力在 32-bit 平台上。特别是 32-bit x86 为了能支持大内存，不得已有很多 work around 的做法（困难在于 32-bit 地址空间不够将全部物理内存映射入内核），带来了额外的复杂性，这些做法当时有其积极意义，但现在去深入学似乎不太值得。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    关于项目，</span><span style="font-size: 11pt; font-weight: 600;">我出两个练手题目</span><span style="font-size: 11pt;">：</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><div><span style="font-size: 11pt;">    既然你是在校学生，而且编程语言和数据结构的基础还不错，我认为应该在《操作系统》和《计算机体系结构》这两门课上下功夫，然后才去读编程方面的 APUE、UNP 等书。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    下面简单谈谈我对学习这两门课的看法和建议，都是</span><span style="font-size: 11pt; font-weight: 600;">站在服务端程序员的角度，从实用主义（</span><span style="font-size: 11pt;">pragmatic</span><span style="font-size: 11pt; font-weight: 600;">）的立场出发</span><span style="font-size: 11pt;">而言的。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: 600;">    学习操作系统的目的</span><span style="font-size: 11pt;">，不是让你去发明自己操作系统内核，打败 Linux；也不是成为内核开发人员；而是理解操作系统为用户态进程提供了怎样的运行环境，作为程序员应该如何才能充分利用好这个环境，哪些做法是有益的，哪些是做无用功，哪些则是帮倒忙。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: 600;">    学习计算机体系结构的目的</span><span style="font-size: 11pt;">，不是让你去设计自己的 CPU（新的 ISA 或微架构），打败 Intel 和 ARM；也不是参与到 CPU 设计团队，改进现有的微架构；而是明白现代的处理器的能力与特性（例如流水线、多发射、分支预测、乱序执行等等指令级并行手段，内存局部性与 cache，多处理器的内存模型、能见度、重排序等等），在编程的时候通过适当组织代码和数据来发挥 CPU 的效能，避免 pitfalls。</span><a href="https://link.zhihu.com/?target=http%3A//www.lighterra.com/papers/modernmicroprocessors/" rel="nofollow noreferrer" style="font-size: 11pt; text-decoration: none;" target="_blank">Modern Microprocessors</a></div><div><br/></div><div><span style="font-size: 11pt; font-weight: 600;">    学习任何一门课程都要善于抓住主要矛盾、分清主次、突出重点</span><span style="font-size: 11pt;">，关键是掌握知识框架，学会以后真正有用的知识和技能，而不要把精力平均分配在一些琐事上。</span></div><div><span style="font-size: 11pt;">请允许我再次引用孟岩的观点：</span><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/myan/article/details/5877305" style="font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none;">http://</a><span style="font-size: 11pt;">blog.csdn.net/myan/arti</span><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/myan/article/details/5877305" style="font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none;">cle/details/5877305</a><span style="font-size: 11pt;">...</span></div><blockquote><div><span style="font-size: 11pt;">我（孟岩）主张，在具备基础之后，学习任何新东西，都要抓住主线，突出重点。对于关键理论的学习，要集中精力，速战速决。而旁枝末节和非本质性的知识内容，完全可以留给实践去零敲碎打。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">原因是这样的，任何一个高级的知识内容，其中都只有一小部分是有思想创新、有重大影响的，而其它很多东西都是琐碎的、非本质的。因此，集中学习时必须把握住真正重要那部分，把其它东西留给实践。对于重点知识，只有集中学习其理论，才能确保体系性、连贯性、正确性，而对于那些旁枝末节，只有边干边学能够让你了解它们的真实价值是大是小，才能让你留下更生动的印象。如果你把精力用错了地方，比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧，而对于真正重要的、思想性东西放在平时零敲碎打，那么肯定是事倍功半，甚至适得其反。</span></div><div><span style="font-size: 11pt;">因此我对于市面上绝大部分开发类图书都不满——它们基本上都是面向知识体系本身的，而不是面向读者的。总是把相关的所有知识细节都放在一堆，然后一堆一堆攒起来变成一本书。反映在内容上，就是毫无重点地平铺直叙，不分轻重地陈述细节，往往在第三章以前就用无聊的细节谋杀了读者的热情。</span></div><div><font style="font-size: 11pt;"><br/></font></div></blockquote><div><span style="font-size: 11pt;">    比如说操作系统，应该把精力主要放在进程管理与调度、内存管理、并发编程与同步、高效的IO等等，而不要过于投入到初始化（从 BIOS 加载引导扇区、设置 GDT、进入保护模式）这种一次性任务上。我发现国内讲 Linux 内核的书往往把初始化的细节放在前几章，而国外的书通常放附录，你可以体会一下。初始化对操作系统本身而言当然是重要的，但是对于在用户态写服务程序的人来说，弄清楚为什么要打开 PC 上的 A20 地址线真的有用处吗？（这不过是个历史包袱罢了。）</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    再比方说《计算机网络》，关键之一是理解如何在底层有丢包、重包、乱序的条件下设计出可靠的网络协议，这不算难。难一点的是这个可靠协议能达到“既能充分利用带宽，又能做到足够公平（并发连接大致平均分享带宽）”。而不是学会手算 CRC32，这更适合放到信息论或别的课程里去讲。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    1. 《Linux内核源码情景分析》上分析内核使用 GDT/LDT 表项的状况，得出进程数不超过 4090 的结论。如果你打算记住这个结论，一定要记住这是在 Linux 2.4.0 内核，32-bit Intel x86 平台上成立，新版的内核和其他硬件平台很可能不成立。看完书后千万不要张口就来“书上说 Linux 的最大进程数是 4090”。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    2. 一个 Linux 进程最多创建 300 余个线程，这个结论成立的条件是 3GB 用户空间，线程栈为 10M 或 8M。在 64-bit 下不成立。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    3. Reactor 模式只能支持不超过 64 个 handle，这个结论成立的条件是 Windows 下使用 WaitForMultipleObjects 函数实现的 WFMO_Reactor，对于 Linux 下使用 poll/epoll 实现的 Reactor 则无此限制。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    4. C++ STL 的 vector 容器在 clear() 之后不会释放内存，需要 swap(empty vector)，这是有意为之（C++11 里增加了 shrink_to_fit() 函数）。不要记成了所有 STL 容器都需要 swap(empty one) 来释放内存，事实上其他容器（map/set/list/deque）都只需要 clear() 就能释放内存。只有含reserve()/capacity() 成员函数的容器才需要用 swap 来释放空间，而 C++ 里只有 vector 和 string 这两个符合条件。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: 600;">一、多机数据处理</span><span style="font-size: 11pt;">。</span></div><div><span style="font-size: 11pt;">有 10 台机器，每台机器上保存着 10 亿个 64-bit 整数（不一定刚好 10 亿个，可能有上下几千万的浮动），一共约 100 亿个整数（其实一共也就 80GB 数据，不算大，选这个量级是考虑了 VPS 虚拟机的容量，便于实验）。编程求出：</span></div><div><span style="font-size: 11pt;">1. 这些数的平均数。</span></div><div><span style="font-size: 11pt;">2. 这些数的中位数。</span></div><div><span style="font-size: 11pt;">3. 出现次数最多的 100 万个数。</span></div><div><span style="font-size: 11pt;">*4. （附加题）对这 100 亿个整数排序，结果顺序存放到这 10 台机器上。</span></div><div><span style="font-size: 11pt;">*5. （附加健壮性要求）你的程序应该能正确应对输入数据的各种分布（均匀、正态、Zipf）。</span></div><div><span style="font-size: 11pt;">*6. （附加伸缩性要求）你的程序应该能平滑扩展到更多的机器，支持更大的数据量。比如 20 台机器、一共 200 亿个整数，或者 50 台机器、一共 500 亿个整数。</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: 600;">二、N-皇后问题的多机并行求解</span><span style="font-size: 11pt;">。</span></div><div><span style="font-size: 11pt;">利用多台机器求出 N-皇后问题有多少个解。（注意目前的世界纪录是 N = 26，</span><a href="https://link.zhihu.com/?target=http%3A//oeis.org/A000170" rel="nofollow noreferrer" style="font-size: 11pt; text-decoration: none;" target="_blank">A000170 - OEIS</a> <span style="font-size: 11pt;">）</span></div><div><span style="font-size: 11pt;">1. 8 皇后问题在单机上的运算时间是毫秒级，有 92 个解，编程实现之。</span></div><div><span style="font-size: 11pt;">2. 研究 N-皇后问题的并行算法，写一个单机多线程程序，争取达到线性加速比（以 CPU 核数计）。再设法将算法扩展到多机并行。</span></div><div><span style="font-size: 11pt;">3. 用 10 台 8 核的机器（一共 80 个 CPU cores），求解 19-皇后和 20-皇后问题，看看分别需要多少运行时间。你的方案能否平滑扩展到更多的机器？</span></div><div><span style="font-size: 11pt;">*4. （附加题）如果这 10 台机器的型号不一，有 8 核也有 16 核，有旧 CPU 也有更快的新 CPU，你该采用何种负载均衡策略，以求缩短求解问题的时间（至少比 plain round-robin 算法要好）？</span></div><div><span style="font-size: 11pt;">你可以用 Amazon EC2 或 Google GCE 来验证你的程序的正确性和性能，这两家的虚拟机都是按小时（甚至更短）收费，开 10 台虚拟机做一个下午的实验也花不了多少钱。</span></div></div><div><br/></div><div><br/></div><div><div><br/></div><hr/><div><span style="font-weight: bold;">游戏引擎</span></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24616737/answer/28520103" style="font-size: 8pt;">https://www.zhihu.com/question/24616737/answer/28520103</a></div></div><div><br/></div><div><div><span style="font-size: 12pt;">问题：</span></div><div><span style="font-size: 12pt;">PS：这里的游戏引擎暂时指图形模块，其他的声音，物理，网络，UI等等模块暂时不考虑。</span><span style="font-size: 12pt; color: unset; font-family: unset;">题猪一直自学编程，有c++、数据结构与算法 基础，现在正在自学DirectX9.0，（自然是看红龙书了），想着以后能从事游戏引擎开发相关的职业，敢问各位路过的大神提些宝贵的意见</span></div><div><span style="font-size: 12pt;">    Ⅰ：DirectX基础部分学好之后应该如何继续学习？直接看开源的游戏引擎？还是进一步深入学习DirectX可编程渲染流水线？还是看其他一些比如《Real Time 3D Terrain Engines Using C++ And DX9》、《Real-Time Rending》、《Game Engine Architecutre》等等相关书籍？还是自己写Demo？</span></div><div><span style="font-size: 12pt;">    Ⅱ：涉及游戏引擎开发的公司有哪些？（腾讯？网易？触控科技？），这些公司对游戏引擎开发的职位要求是什么？以及将来面试时应该如何应对？（把自己写的Demo给他看？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/yong-he-8" style="font-size: 12pt; font-weight: 600; text-decoration: none;">Yong He</a></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">    首先应该深度掌握渲染的基本原理，因此我非常同意其他答案关于先自己实现一个软件光栅化渲染器的建议，你应该按照最新的标准自己大概实现一遍DirectX(例如要支持tessellation, shader, MSAA, blending, anisotropic filtering, 正确处理各种corner case如退化三角形等情况)。实现的过程中请参考DirectX的specification以学习相关细节。这个文档可能是只对硬件vendor(卖家)公开，不过还是很容易获得的。实现软件光栅化还能极大地锻炼你的底层C++编码能力，并行程序设计能力和优化技巧，顺便还能把主流的GPU架构搞熟。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">    一旦搞清楚光栅化渲染的本质，你就能理解各种所谓“高级渲染技术”的精髓，基本上看paper只需几秒钟扫一扫图就能看懂了。这样一来短时间内就能理解大量算法和渲染架构(例如各种shadow map, AO, volumetric scattering, deferred lighting, forward+等等)。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">    当你对图形管线的本质以及各种可能的应用都了然于胸的时候，剩下的就是高层</span><span style="font-size: 12pt; font-weight: bold;">架构设计</span><span style="font-size: 12pt;">问题了。这个属于</span><span style="font-size: 12pt; font-weight: bold;">软件工程的范畴</span><span style="font-size: 12pt;">，没有捷径，只能通过</span><span style="font-size: 12pt; font-weight: bold;">大量试错来获得经验了(不停地重写)</span><span style="font-size: 12pt;">。{刚好就是chili做的事，大概也是SSS所谓的“正在写”}。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">    其实当你知道了这些所谓的技术之后，你会发现大部分都是肤浅的hack而已。现在引擎的重要课题不在于谁掌握了更牛逼的渲染技术，而在于谁能设计出更好的开发流水线，内容制作以及美工反馈才是最大的难题。前段时间和bungie的图形总管聊destiny的engine，他们表示任何新的技术他们都可以在两天内实现出来，但最大的难题是</span></div><div><span style="font-size: 12pt;">    </span></div><div><span style="font-size: 12pt;">    1)如何使这些新技术在各种情况下都能鲁棒地工作；而大部分时候都很好，偶尔会挂掉的技术都是不可取的；</span></div><div><span style="font-size: 12pt;">    2)如何构建好的工具让美工能够控制各种情况。举个例子，tessellation是个很酷的技术，但是应用到游戏中并不容易，因为</span></div><div><span style="font-size: 12pt;">        1)创建好的displacement map很困难; </span></div><div><span style="font-size: 12pt;">        2)一旦引入LOD，则牵动全身：如何保持场景在各个视角的一致性？如何让displacement geometry正确地与阴影、碰撞、贴花和可见性等系统交互？</span></div><div><span style="font-size: 12pt;">此外不同平台上还有很多底层优化问题，这里就不展开了。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/ztcore" style="font-size: 12pt; font-weight: 600; text-decoration: none;">仲唐</a></div><div style="margin:0px;"></div><div style="box-sizing: border-box; margin: 10px 0px -4px; min-width: 0px; color: rgb(133, 144, 166);"></div><div><span style="font-size: 12pt;">我们公司引擎部门新员工，一般会有两个入门练习：</span></div><div><span style="font-size: 12pt;">一是只用类似DrawPixel的函数，实现一个软件光栅化。</span></div><div><span style="font-size: 12pt;">二是使用自家引擎做一个完整游戏。可以比较简单，但必须完整。</span></div><div><span style="font-size: 12pt;">一个去鹅厂的小伙伴也做过类似跑酷类手游作为练手。</span></div><div><span style="font-size: 12pt;">所以我觉得，从学习的角度，一边做游戏，一边做个玩具引擎，并不冲突。</span></div><div><span style="font-size: 12pt;">做一个自己的引擎出来，满足技术好奇心，也能试验想法；</span></div><div><span style="font-size: 12pt;">用一个开源图形引擎做一个类型的游戏，能了解组成部分和主要需求。了解</span></div><div><span style="font-size: 12pt;">楼上有好多关于做游戏还是做引擎的讨论，都是有道理的。</span></div><div><span style="font-size: 12pt;">如</span><a href="https://www.zhihu.com/people/0effe9e423faad125fa9c63418dd288a" style="font-size: 12pt; font-family: unset; text-decoration-line: none;" target="_blank">@张静vinjn</a><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; color: unset; font-family: unset;">等所说，如果没做过一个完整的游戏，直接只做引擎，学习的效率和引擎的质量都不会太高。</span></div><div><span style="font-size: 12pt;">但在很多人心里，会把引擎开发的这个工作神话。这种时候自己做一个引擎，对提高自己的信心会有帮助。大部分贬低引擎开发工作的人，至少都是有能撸一个的底气的（且不说质量）。</span></div><hr/><div><span style="font-size: 12pt;">    所以对两个方面，我都推荐一些自己感觉不错的资料:</span></div><div><span style="font-size: 12pt;">    游戏逻辑方面：推荐一个网站，</span> <a href="https://link.zhihu.com/?target=http%3A//gameprogrammingpatterns.com/" rel="nofollow noreferrer" style="font-size: 12pt; text-decoration: none;" target="_blank">Game Programming Patterns</a><span style="font-size: 12pt;">，作者把自己的书放github上，供读者提意见。</span></div><div><span style="font-size: 12pt;">    引擎架构方面：Game Engine Architecture，这本得看中文翻译的。</span></div><div><span style="font-size: 12pt;">    图形引擎方面，主要是算法和API，引擎架构抄一套别人的。</span></div><div><span style="font-size: 12pt;">    图形基础算法书籍：在lz的基础上，推荐一个3D Game Engine Design，里面的3D算法和原理讲解很详细，可惜有点老。</span></div><div><span style="font-size: 12pt;">    高级图形技术：除了Real Time Rendering 3和GPU Pro系列以外，可以跟KlayGE和OpenGPU。这个方向量力而行，国内现在的行情是转手游的多，一些复杂的效果研究太深入也可能发挥不了。</span></div><div><span style="font-size: 12pt;">软件光栅化可以简单理解为，只给你一个画点的函数，你需要用C++实现一个三维物体显示的过程。一般这个工作是由Direct3D/OpenGL的驱动实现来做的。</span></div><div><span style="font-size: 12pt;">这个工作可以做的很难，也可以很简单。我们公司貌似所有客户端程序都会做这个，但要求跟老大有关。</span></div><div><span style="font-size: 12pt;">最基本就是实现一个固定管线，包括顶点坐标的矩阵变化，画线，三角形填充光栅化算法，裁剪，Gouround光照，纹理坐标插值，ZBuffer等等。</span></div><div><span style="font-size: 12pt;">要做好点，就可以把一个引擎Renderer部分的借口都实现了，用C++写个VS/PS，跟D3D/OpenGL平级。</span></div></div><div><br/></div><hr/><div><span style="font-size: 12pt;">图学或是游戏引擎相关的工作通常不是给你的.</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="-en-paragraph:true;"><font style="font-size: 12pt;"><span style="font-size: 12pt;-en-paragraph:true;">    想走游戏方面的程式</span><span style="font-size: 12pt;-en-paragraph:true;">设计师，很多是主修Computer Graphics的，在美国念到的Program可能也是教Computer Graphics或是被要求在分组Game Project负责这一块。</span><span style="font-size: 12pt;-en-paragraph:true;">但一般AAA级的公司，其自制游戏引擎与渲染器的复杂程度，刚出学校的新鲜人除非</span><a target="_blank" rel="noopener" href="http://jasperbekkers.nl/" style="font-size: 12pt;-en-paragraph:true;">天赋异禀</a><span style="font-size: 12pt;-en-paragraph:true;">，否则是很难驾驭的。</span></font></div><div style="-en-paragraph:true;"><font style="font-size: 12pt;"><span style="font-size: 12pt;-en-paragraph:true;">    而小一些的工作室现在除非原有的引擎相当稳固，否则大多已经放弃自制引擎，投入Unreal或是Unity的怀抱了。</span><span style="font-size: 12pt;-en-paragraph:true;">新鲜人在那能拿到最接近图学的工作往往是在这些引擎框架下撰写微调Shader 。</span><span style="font-size: 12pt;-en-paragraph:true;">其他的很多是转为负责Gameplay Logic或是UI 、工具开发这些跟图学无关的职位，等待有一天能转回去。</span><span style="font-size: 12pt;-en-paragraph:true;">并不是说念了Computer Graphics就一定能找到相应发挥所长的职位，同样的在动画界也有不少Computer Graphics新鲜人是被转职成Pipeline Engineer ，做的是档案系统管理跟伺服器维护。</span></font></div><div><br/></div><hr/><div><br/></div></div><div><b>什么是自己写的代码</b></div><div><br/></div><div>手撸redis是个不错的练习方法，两万多行代码，说多不多，一个人就能掌控，适合练手，<span style="color: unset; font-family: unset; font-size: unset;">可以手撸lua虚拟机， 一万多行代码，连带标准库</span></div><div><br/></div><div>怎么个撸法，架构设计抄redis的，然后自己对着接口填实现嘛？</div><div><br/></div><div>反正是练手,就自己写一个,Redis lua都无所谓了,自己写出来之后再和人家的对比下,不就学到很多了吗，<span style="color: unset; font-family: unset; font-size: unset;">我觉得可以先写个思维导图,列出有啥功能,接口，然后一个一个实现，</span><span style="color: unset; font-family: unset; font-size: unset;">前置知识应该是socket,存储io和内存管理啥的吧..</span></div></span>
</div></body></html> 
	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>