<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/C++/book note/Effective C++/item3-jin-ke-neng-shi-yong-const/">Item3-尽可能使用const</a></h1><div class=post-meta-inline><span class=post-date> 2021-01-06 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/effective-c/>#Effective C++</a></span><div class=post-content><p>Item 3: 尽可能使用 const<p>const 指定一个“不该被改动”的对象，编译器会强制实施这项约束。<h2 id=const-yu-zhi-zhen>const 与指针</h2><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>char</span><span> greeting[] = "</span><span style=color:#a3be8c;>Hello</span><span>";</span><span>
</span><span style=color:#b48ead;>char</span><span>* p = greeting;	</span><span style=color:#65737e;>//@ non-const data,non-const pointer</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>const char</span><span>* p = greeting;	</span><span style=color:#65737e;>//@ non-const pointer,const data</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>char</span><span>* </span><span style=color:#b48ead;>const</span><span> p = greeting;	</span><span style=color:#65737e;>//@ const pointer,non-const data</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>const char</span><span>* </span><span style=color:#b48ead;>const</span><span> p = greeting; </span><span style=color:#65737e;>//@ const pointer,const data</span><span style=color:#65737e;>
</span></code></pre><ul><li>const 出现在 <code>*</code> 左边，则指针指向的内容是 const。<li>const 出现在 <code>*</code> 右边，则指针本身是 const。<li>const 出现在 <code>*</code> 两边，两者都是 const。</ul><blockquote><p>C++ Primer 5th ：<strong>弄清楚声明的含义：从右向左阅读，离变量名最近的对变量有直接影响，其余部分确定对象的类型</strong>。</blockquote><p>当指针指向的内容是常量时，将 const 放在类型前和放在类型后是没有区别的：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>//@ 等价的形式</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>f1</span><span>(</span><span style=color:#b48ead;>const</span><span> Widget *</span><span style=color:#bf616a;>pw</span><span>);	</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>f1</span><span>(Widget </span><span style=color:#b48ead;>const </span><span>*</span><span style=color:#bf616a;>pw</span><span>);	</span><span>
</span></code></pre><h3 id=bian-yu-bu-bian>变与不变</h3><p>当指针指向的内容是常量时，表示无法通过指针修改变量的值，但是可以通过其它方式修改指针指向变量的值：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int</span><span> a = </span><span style=color:#d08770;>1</span><span>;</span><span>
</span><span style=color:#b48ead;>const int </span><span>*p = &a;</span><span>
</span><span>cout << *p << endl;	</span><span style=color:#65737e;>//@ 1</span><span style=color:#65737e;>
</span><span>*p = </span><span style=color:#d08770;>2</span><span>;	</span><span style=color:#65737e;>//@ error, data is const</span><span style=color:#65737e;>
</span><span>a = </span><span style=color:#d08770;>2</span><span>;</span><span>
</span><span>cout << *p << endl;	</span><span style=color:#65737e;>//@ 2</span><span style=color:#65737e;>
</span></code></pre><p>指针本身是常量，表示指针表示的地址是固定的，但是其指向的内容是可以改变的：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>int</span><span> a = </span><span style=color:#d08770;>1</span><span>, b = </span><span style=color:#d08770;>2</span><span>;</span><span>
</span><span style=color:#b48ead;>int</span><span>* </span><span style=color:#b48ead;>const</span><span> p = &a;</span><span>
</span><span>cout << *p << endl;	</span><span style=color:#65737e;>//@ 1</span><span style=color:#65737e;>
</span><span>p = &b;	</span><span style=color:#65737e;>//@ error, pointer is const</span><span style=color:#65737e;>
</span><span>*p = b;</span><span>
</span><span>cout << *p << endl;	</span><span style=color:#65737e;>//@ 2</span><span style=color:#65737e;>
</span></code></pre><h2 id=const-yu-die-dai-qi>const 与迭代器</h2><p>STL 迭代器以指针为原型，所以 iterator 的作用就像个 T* 指针。声明一个 iterator 为 const 就类似于声明一个 pointer 为 const（也就是说，声明一个 T* const pointer）：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>std::vector<</span><span style=color:#b48ead;>int</span><span>> vec;</span><span>
</span><span>
</span><span style=color:#b48ead;>const</span><span> std::vector<</span><span style=color:#b48ead;>int</span><span>>::iterator iter = vec.</span><span style=color:#bf616a;>begin</span><span>();</span><span>
</span><span>*iter = </span><span style=color:#d08770;>10</span><span>;	</span><span style=color:#65737e;>//@ ok,change what the iterator point to</span><span style=color:#65737e;>
</span><span>iter++;		</span><span style=color:#65737e;>//@ error,iter is const</span><span style=color:#65737e;>
</span><span>
</span><span>std::vector<</span><span style=color:#b48ead;>int</span><span>>::const_iterator cIter =  vec.</span><span style=color:#bf616a;>begin</span><span>();</span><span>
</span><span>*cIter = </span><span style=color:#d08770;>10</span><span>;	</span><span style=color:#65737e;>//@ error,*cIter is const</span><span style=color:#65737e;>
</span><span>++cIter;		</span><span style=color:#65737e;>//@ ok,change cIter</span><span style=color:#65737e;>
</span></code></pre><h2 id=const-yu-han-shu>const 与函数</h2><p>const 可以用在函数返回值，函数的个别参数，对于成员函数，还可以用于整个函数。<h3 id=han-shu-fan-hui-const-value>函数返回 const value</h3><p>令函数返回一个常量值，往往可以在不放弃安全性和高效性的前提下降低因客户错误而造成的意外。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Rational</span><span style=color:#eff1f5;>{</span><span>...</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span><span style=color:#b48ead;>const</span><span> Rational </span><span style=color:#8fa1b3;>operator*</span><span>(</span><span style=color:#b48ead;>const</span><span> Rational& </span><span style=color:#bf616a;>lhs</span><span>,</span><span style=color:#b48ead;>const</span><span> Rational& </span><span style=color:#bf616a;>rhs</span><span>);</span><span>
</span><span>
</span><span>Rational a,b,c;</span><span>
</span><span>...</span><span>
</span><span>(a * b) = c;	</span><span style=color:#65737e;>//为两个数的乘积赋值，将返回值声明为const 可以避免此问题</span><span style=color:#65737e;>
</span></code></pre><h3 id=const-cheng-yuan-han-shu>const 成员函数</h3><ul><li>声明 const 成员函数是为了确认哪些方法可以通过常量对象来访问<li>使 class 接口比较容易被理解，容易知道哪个函数可以改动对象而哪个函数不行<li>常量对象只能调用常量方法， 非常量对象<strong>优先调用</strong>非常量方法，如不存在会调用同名常量方法<li>常量成员函数也可以在类声明外定义，但声明和定义都需要指定 const 关键字<li>成员方法添加常量限定符属于函数重载，这是C++的一个重要特性</ul><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>TextBlock </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span>...  </span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#65737e;>//@ operator[] for const objects</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>const char</span><span>& </span><span style=color:#8fa1b3;>operator[]</span><span style=color:#eff1f5;>(std::size_t </span><span style=color:#bf616a;>position</span><span style=color:#eff1f5;>) </span><span style=color:#b48ead;>const  </span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  { </span><span style=color:#b48ead;>return</span><span style=color:#eff1f5;> text[position]; }                          </span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#65737e;>//@ operator[] for non-const objects</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>char</span><span>& </span><span style=color:#8fa1b3;>operator[]</span><span style=color:#eff1f5;>(std::size_t </span><span style=color:#bf616a;>position</span><span style=color:#eff1f5;>)           </span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  { </span><span style=color:#b48ead;>return</span><span style=color:#eff1f5;> text[position]; }                          </span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>private</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>   std::string text;</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span><span>
</span><span style=color:#65737e;>//@ 使用</span><span style=color:#65737e;>
</span><span>TextBlock </span><span style=color:#8fa1b3;>tb</span><span>("</span><span style=color:#a3be8c;>Hello</span><span>");</span><span>
</span><span>std::cout << tb[</span><span style=color:#d08770;>0</span><span>];	</span><span style=color:#65737e;>//@ calls non-const TextBlock::operator[]</span><span style=color:#65737e;>
</span><span>                                       </span><span>
</span><span style=color:#b48ead;>const</span><span> TextBlock </span><span style=color:#8fa1b3;>ctb</span><span>("</span><span style=color:#a3be8c;>World</span><span>");</span><span>
</span><span>std::cout << ctb[</span><span style=color:#d08770;>0</span><span>];  </span><span style=color:#65737e;>//@ calls const TextBlock::operator[]</span><span style=color:#65737e;>
</span></code></pre><p>真实程序中 const 对象大多用于 <code>passed by pointer-to-const </code>或<code>passed by reference-to-const</code>：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>print</span><span>(</span><span style=color:#b48ead;>const</span><span> TextBlock& </span><span style=color:#bf616a;>ctb</span><span>)       </span><span style=color:#65737e;>// in this function, ctb is const</span><span style=color:#65737e;>
</span><span>{</span><span>
</span><span>  std::cout << ctb[</span><span style=color:#d08770;>0</span><span>];                 </span><span style=color:#65737e;>// calls const TextBlock::operator[]</span><span style=color:#65737e;>
</span><span>  ...</span><span>
</span><span>}</span><span>
</span></code></pre><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#65737e;>//@ 对 const 和 non-const 的 TextBlocks 做不同的操作</span><span style=color:#65737e;>
</span><span>std::cout << tb[</span><span style=color:#d08770;>0</span><span>];   </span><span style=color:#65737e;>//@ fine — reading a non-const TextBlock</span><span style=color:#65737e;>
</span><span>tb[</span><span style=color:#d08770;>0</span><span>] = '</span><span style=color:#a3be8c;>x</span><span>';         </span><span style=color:#65737e;>//@ fine — writing a non-const TextBlock</span><span style=color:#65737e;>
</span><span>std::cout << ctb[</span><span style=color:#d08770;>0</span><span>]; </span><span style=color:#65737e;>//@ fine — reading a const TextBlock</span><span style=color:#65737e;>
</span><span>ctb[</span><span style=color:#d08770;>0</span><span>] = '</span><span style=color:#a3be8c;>x</span><span>';       </span><span style=color:#65737e;>//@ error! — writing a const TextBlock</span><span style=color:#65737e;>
</span></code></pre><p>错误只与 operator[] 返回类型有关，而 operator[] 调用动作自身没问题。<p>如果 non-const 版本的 operator[] 返回一个char而不是一个char引用，则下面语句将无法编译通过：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span>tb[</span><span style=color:#d08770;>0</span><span>] = '</span><span style=color:#a3be8c;>x</span><span>';	</span><span style=color:#65737e;>//返回一个右值，企图为一个右值赋值</span><span style=color:#65737e;>
</span></code></pre><h3 id=bitwise-constness-he-logical-constness>bitwise constness 和 logical constness</h3><p><strong>（比特常量和逻辑常量）</strong><p>比特常量：成员函数只有在不更改对象内的任何非静态成员变量，那该函数是const的，即不更改对象内任何一个 bit。比特常量是C++ 对常量性（constness）的定义。<p>不幸的是，许多成员函数虽然不具备 const 性质，却能通过 bitwise测试：一个更改了“指针所指物”的成员函数不能算const，但如果只有指针（而非其所指物）隶属于对象，则称此函数为 bitwise const 不会引发编译器异议。<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>CTextBlock </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>char</span><span>& </span><span style=color:#8fa1b3;>operator[]</span><span style=color:#eff1f5;>(std::size_t </span><span style=color:#bf616a;>position</span><span style=color:#eff1f5;>) </span><span style=color:#b48ead;>const   </span><span style=color:#65737e;>// inappropriate (but bitwise</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  { </span><span style=color:#b48ead;>return</span><span style=color:#eff1f5;> pText[position]; }                    </span><span style=color:#65737e;>// const) declaration of</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>                                                 </span><span style=color:#65737e;>// operator[]</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>private</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#eff1f5;>pText;</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span></code></pre><p>看看 operator[] 的实现，它并没有使用任何手段改变 pText。结果，编译器愉快地生成了 operator[] 的代码，因为毕竟对所有编译器而言，它都是 bitwise const 的，但是我们看看会发生什么：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>const</span><span> CTextBlock </span><span style=color:#8fa1b3;>cctb</span><span>("</span><span style=color:#a3be8c;>Hello</span><span>");   </span><span style=color:#65737e;>//@ declare constant object</span><span style=color:#65737e;>
</span><span style=color:#b48ead;>char </span><span>*pc = &cctb[</span><span style=color:#d08770;>0</span><span>];  </span><span style=color:#65737e;>//@ call the const operator[] to get a pointer to cctb's data</span><span style=color:#65737e;>
</span><span>*pc = '</span><span style=color:#a3be8c;>J</span><span>'; </span><span style=color:#65737e;>//@ cctb now has the value "Jello"</span><span style=color:#65737e;>
</span></code></pre><p>这里确实出了问题，你创建一个常量对象并设以某值，然后你只是用它调用了 const 成员函数，但是你还是改变了它的值！<p>这种情况导出所谓的 logical constness（逻辑常量）：一个 const 成员函数可以修改它所处理的对象内的某些 bits，但只有在客户端侦测不到的情况下才得如此。<p>const 成员函数修改对象内容对对象而言虽然可以接受，但编译器不同意，此时需要 mutable 限定符：mutable 释放掉non-static 成员变量的 bitwise constness 约束：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>CTextBlock </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  std::size_t </span><span style=color:#8fa1b3;>length</span><span style=color:#eff1f5;>() </span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;>;</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>private</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>char </span><span>*</span><span style=color:#eff1f5;>pText;</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>mutable</span><span style=color:#eff1f5;> std::size_t textLength;	</span><span style=color:#65737e;>//这些成员变量可能总是会被更改</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>mutable bool</span><span style=color:#eff1f5;> lengthIsValid;		</span><span style=color:#65737e;>//即使在const 成员函数内</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>}</span><span>;    </span><span>
</span><span>
</span><span>std::size_t CTextBlock::</span><span style=color:#8fa1b3;>length</span><span>() </span><span style=color:#b48ead;>const</span><span>
</span><span>{</span><span>
</span><span>  </span><span style=color:#b48ead;>if </span><span>(!lengthIsValid) {</span><span>
</span><span>    textLength = std::</span><span style=color:#96b5b4;>strlen</span><span>(pText);      </span><span style=color:#65737e;>//now fine</span><span style=color:#65737e;>
</span><span>    lengthIsValid = </span><span style=color:#d08770;>true</span><span>;                 </span><span style=color:#65737e;>//also fine</span><span style=color:#65737e;>
</span><span>  }</span><span>
</span><span>
</span><span>  </span><span style=color:#b48ead;>return</span><span> textLength;</span><span>
</span><span>}</span><span>
</span></code></pre><h3 id=zai-const-he-non-const-cheng-yuan-han-shu-zhong-bi-mian-zhong-fu>在 const 和 non-const 成员函数中避免重复</h3><pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>TextBlock </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>const char</span><span>& </span><span style=color:#8fa1b3;>operator[]</span><span style=color:#eff1f5;>(std::size_t </span><span style=color:#bf616a;>position</span><span style=color:#eff1f5;>) </span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span>...	</span><span style=color:#65737e;>//边界检验（bounds checking）</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>    </span><span>... </span><span style=color:#65737e;>//日志访问数据（log access data）</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>    </span><span>... </span><span style=color:#65737e;>//检验数据完整性（verify data integrity）</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>return</span><span style=color:#eff1f5;> text[position];</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  }</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>char</span><span>& </span><span style=color:#8fa1b3;>operator[]</span><span style=color:#eff1f5;>(std::size_t </span><span style=color:#bf616a;>position</span><span style=color:#eff1f5;>)</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span>...	</span><span style=color:#65737e;>//边界检验（bounds checking）</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>    </span><span>... </span><span style=color:#65737e;>//日志访问数据（log access data）</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>    </span><span>... </span><span style=color:#65737e;>//检验数据完整性（verify data integrity）</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>return</span><span style=color:#eff1f5;> text[position];</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  }</span><span style=color:#eff1f5;>
</span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>private：</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    std::string text;</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span></code></pre><p>代码重复伴随着编译时间、维护、代码膨胀等问题。<p>真正需要的是一次 operator[] 功能实现，然后使用它两次，即必须令其中一个调用另一个。<p>运用 const 成员函数实现了其 non-const 成员函数：<pre class=language-cpp data-lang=cpp style=background-color:#2b303b;color:#c0c5ce;><code class=language-cpp data-lang=cpp><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>TextBlock </span><span style=color:#eff1f5;>{</span><span style=color:#eff1f5;>
</span><span style=color:#b48ead;>public</span><span style=color:#eff1f5;>:</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>const char</span><span>& </span><span style=color:#8fa1b3;>operator[]</span><span style=color:#eff1f5;>(std::size_t </span><span style=color:#bf616a;>position</span><span style=color:#eff1f5;>) </span><span style=color:#b48ead;>const     </span><span style=color:#65737e;>// same as before</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>return</span><span style=color:#eff1f5;> text[position];</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  }</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>char</span><span>& </span><span style=color:#8fa1b3;>operator[]</span><span style=color:#eff1f5;>(std::size_t </span><span style=color:#bf616a;>position</span><span style=color:#eff1f5;>)         </span><span style=color:#65737e;>// now just calls const op[]</span><span style=color:#65737e;>
</span><span style=color:#eff1f5;>  {</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>return </span><span>const_cast</span><span style=color:#eff1f5;><</span><span style=color:#b48ead;>char</span><span>&</span><span style=color:#eff1f5;>>(</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>        </span><span>static_cast</span><span style=color:#eff1f5;><</span><span style=color:#b48ead;>const</span><span style=color:#eff1f5;> TextBlock</span><span>&</span><span style=color:#eff1f5;>>(</span><span>*</span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>)[position]);</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>  }</span><span style=color:#eff1f5;>
</span><span>...</span><span style=color:#eff1f5;>
</span><span style=color:#eff1f5;>}</span><span>;</span><span>
</span></code></pre><ul><li><code>*this</code> 的类型是 TextBlock ，先把它强制隐式转换为 const TextBlock，这样才能调用常量方法。<li>调用 <code>operator[](size_t) const</code> ，得到的返回值类型为 const char&。<li>把返回值去掉 const 属性，得到类型为 char& 的返回值。</ul><p>反之，运用 non-const 成员函数实现了其 const 成员函数是错误的，const成员函数承诺绝不改变其对象的逻辑状态，而 non-const 成员函数没有这般承诺。<p>non-const成员函数本身就可以对对象做任何动作，因此以static_cast处理<code>*this</code>并不存在风险。<h2 id=zong-jie>总结</h2><ul><li>将某些东西声明为 const 可帮助编译器侦测出错误用法</ul><ul><li>const 与指针： <ul><li>const 在前表示指针指向的内容是常量<li><code>*</code>号在前表示指针本身是常量</ul><li>const 与迭代器： <ul><li>const 修饰迭代器时表示迭代器本身是常量<li>迭代器指向的内容是常量时应该使用 const_iterator</ul><li>const 与函数 <ul><li>函数返回值为 const 可以避免一些意外赋值的情况发生<li>尽可能的将函数参数声明为 const<li>常量对象只能调用常量方法， 非常量对象优先调用非常量方法，如不存在会调用同名常量方法<li>如果一个方法不改变对象的任何非静态变量，那么该方法是常量方法<li>mutable 限定符对于即使是 const 的对象也可以做修改<li>当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本可以避免代码重复</ul></ul><ul><li>编译器强制实施 bitwise constness，但编写程序时应该使用“概念上的常量性”</ul></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>