<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a><li><a href=https://modao.site/about>About Me</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/book note/Unix网络编程-笔记/unixwang-luo-bian-cheng-di-8zhang/">Unix网络编程-第8章 基本UDP套接字编程</a></h1><div class=post-meta-inline><span class=post-date> 2019-12-30 </span></div><div class=post-content><p>第8章 基本UDP套接字编程<h2 id=8-1-gai-shu>8.1 概述</h2><p>UDP是无连接不可靠的数据报协议，非常不同于TCP提供的面向连接的可靠字节流。<p>有些场合确实适合使用UDP，常见的应用程序有：<ul><li>DNS：域名系统<li>NFS：网络文件系统<li>SNMP：简单网络管理协议</ul><p><img alt=image-20200815203716894 src=image-20200815203716894.png><h2 id=8-2-recvfromhe-sendtohan-shu>8.2 recvfrom和sendto函数</h2><p>类似于标准的read和write函数，不过需要三个额外的参数：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span><</span><span style=color:#a3be8c;>sys/socket.h</span><span>>
</span><span style=color:#65737e;>//成功则均返回读或写的字节数，出错返回-1
</span><span>ssize_t </span><span style=color:#8fa1b3;>recvfrom</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>buff</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>flags</span><span>,
</span><span>                </span><span style=color:#b48ead;>struct</span><span> sockadd *</span><span style=color:#bf616a;>from</span><span>, socklen_t *</span><span style=color:#bf616a;>addrlen</span><span>);
</span><span>ssize_t </span><span style=color:#8fa1b3;>sendto</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, </span><span style=color:#b48ead;>void </span><span>*</span><span style=color:#bf616a;>buff</span><span>, size_t </span><span style=color:#bf616a;>nbytes</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>flags</span><span>,
</span><span>              </span><span style=color:#b48ead;>const struct</span><span> sockaddr *</span><span style=color:#bf616a;>to</span><span>, socklen_t </span><span style=color:#bf616a;>addrlen</span><span>);
</span></code></pre><ul><li><p>前三个参数sockfd、buff和nbytes等同于read和write函数的三个参数：描述符、指向读入或写出缓冲区的指针和读写字节数。</p><li><p>flags总是置0</p><li><p>sendto的to参数指向一个含有数据报接收者的协议地址（例如IP地址及端口号）的套接字地址结构，大小由addrlen参数指定（<strong>是一个整数值</strong>）</p><li><p>recvfrom的from参数指向一个将由该函数在返回时填写数据报发送者的协议地址（例如IP地址及端口号）的套接字地址结构，该套接字地址中填写的字节数存放在addrlen参数所指的整数中返回给调用者（<strong>是一个指向整数值的指针（值-结果传参）</strong>）</p></ul><blockquote><p>recvfrom最后两个参数类似accept最后两个参数：返回时其中套接字地址结构内容告诉我们是谁发送了数据报（UPD情况下）或是谁发起了连接（TCP情况下）。<p>sendto的最后两个参数类似于connect最后两个参数：调用时其中套接字地址结构被我们填入数据报发往（UDP情况下）或与之建立连接（TCP情况下）的协议地址</blockquote><p>**写一个长度为0的数据报是可行的。**在UDP情况下，会形成一个只包含IP首部和UDP首部而没有数据的IP数据报，即recvfrom返回0值是可接受的。<p>UDP是无连接的，不存在关闭连接之类的事情。<h2 id=8-3-udphui-she-fu-wu-qi-cheng-xu-mainhan-shu>8.3 UDP回射服务器程序：main函数</h2><p><img alt=image-20200815211416476 src=image-20200815211416476.png><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>int
</span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char </span><span>**</span><span style=color:#bf616a;>argv</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>                    sockfd;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr_in     servaddr, cliaddr;
</span><span>
</span><span>    </span><span style=color:#65737e;>//通过指定SOCK_DGRAM，创建一个UDP套接字
</span><span>    sockfd = </span><span style=color:#bf616a;>Socket</span><span>(AF_INET, SOCK_DGRAM, </span><span style=color:#d08770;>0</span><span>);
</span><span>
</span><span>    </span><span style=color:#bf616a;>bzero</span><span>(&servaddr, sizeof(servaddr));
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_family      </span><span>= AF_INET;
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_addr</span><span>.</span><span style=color:#bf616a;>s_addr </span><span>= </span><span style=color:#bf616a;>htonl</span><span>(INADDR_ANY);
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_port        </span><span>= </span><span style=color:#bf616a;>htons</span><span>(SERV_PORT);
</span><span>
</span><span>    </span><span style=color:#bf616a;>Bind</span><span>(sockfd, (SA *) &servaddr, sizeof(servaddr));
</span><span>
</span><span>    </span><span style=color:#bf616a;>dg_echo</span><span>(sockfd, (SA *) &cliaddr, sizeof(cliaddr));
</span><span>}
</span></code></pre><h2 id=8-4-udphui-shou-fu-wu-qi-cheng-xu-dg-echohan-shu>8.4 UDP回收服务器程序：dg_echo函数</h2><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>void
</span><span style=color:#8fa1b3;>dg_echo</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, SA *</span><span style=color:#bf616a;>pcliaddr</span><span>, socklen_t </span><span style=color:#bf616a;>clilen</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>            n;
</span><span>    socklen_t      len;
</span><span>    </span><span style=color:#b48ead;>char</span><span>           mesg[MAXLINE];
</span><span>
</span><span>    </span><span style=color:#65737e;>//迭代服务器，永不终止，无连接
</span><span>    </span><span style=color:#b48ead;>for </span><span>( ; ; ) {
</span><span>        len = clilen;
</span><span>        n = </span><span style=color:#bf616a;>Recvfrom</span><span>(sockfd, mesg, MAXLINE, </span><span style=color:#d08770;>0</span><span>, pcliaddr, &len);
</span><span>
</span><span>        </span><span style=color:#bf616a;>Sendto</span><span>(sockfd, mesg, n, </span><span style=color:#d08770;>0</span><span>, pcliaddr, len);
</span><span>    }
</span><span>}
</span></code></pre><p>大多数TCP服务器是并发的，大多数UDP服务器是迭代的。每个UDP套接字都有一个接收缓冲区，到达该套接字的每个数据报都进入这个套接字接收缓冲区，当进程调用recvfrom函数时，缓冲区中的下一个数据报以FIFO顺序返回给进程。<blockquote><p>dg_echo函数是协议无关的：调用者分配一个正确大小的套接字地址结构，将其地址指针和大小传参给dg_echo，dg_echo绝不查看该结构的内容，而是把一个指向该结构的指针传递给recvfrom和sendto。</blockquote><p><img alt=image-20200815212534596 src=image-20200815212534596.png><p><img alt=image-20200815212550160 src=image-20200815212550160.png><h2 id=8-5-udphui-she-ke-hu-cheng-xu-mainhan-shu>8.5 UDP回射客户程序：main函数</h2><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>int
</span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char </span><span>**</span><span style=color:#bf616a;>argv</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>                    sockfd;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr_in     servaddr;
</span><span>
</span><span>    </span><span style=color:#b48ead;>if </span><span>(argc != </span><span style=color:#d08770;>2</span><span>)
</span><span>        </span><span style=color:#bf616a;>err_quit</span><span>("</span><span style=color:#a3be8c;>usage: udpcli &LTIPaddress></span><span>");
</span><span>
</span><span>    </span><span style=color:#bf616a;>bzero</span><span>(&servaddr, sizeof(servaddr));
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_family </span><span>= AF_INET;
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_port </span><span>= </span><span style=color:#bf616a;>htons</span><span>(SERV_PORT);
</span><span>    </span><span style=color:#bf616a;>Inet_pton</span><span>(AF_INET, argv[</span><span style=color:#d08770;>1</span><span>], &servaddr.</span><span style=color:#bf616a;>sin_addr</span><span>);
</span><span>
</span><span>    sockfd = </span><span style=color:#bf616a;>Socket</span><span>(AF_INET, SOCK_DGRAM, </span><span style=color:#d08770;>0</span><span>);
</span><span>
</span><span>    </span><span style=color:#bf616a;>dg_cli</span><span>(stdin, sockfd, (SA *) &servaddr, sizeof(servaddr));
</span><span>
</span><span>    </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span><span>}
</span></code></pre><h2 id=8-6-udphui-she-ke-hu-cheng-xu-dg-clihan-shu>8.6 UDP回射客户程序：dg_cli函数</h2><p>dg_cli函数也是协议无关的，不过main函数都是协议相关的。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>void
</span><span style=color:#8fa1b3;>dg_cli</span><span>(FILE *</span><span style=color:#bf616a;>fp</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, </span><span style=color:#b48ead;>const</span><span> SA *</span><span style=color:#bf616a;>pservaddr</span><span>, socklen_t </span><span style=color:#bf616a;>servlen</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>     n;
</span><span>    </span><span style=color:#b48ead;>char</span><span>    sendline[MAXLINE], recvline[MAXLINE + </span><span style=color:#d08770;>1</span><span>];
</span><span>
</span><span>    </span><span style=color:#b48ead;>while </span><span>(</span><span style=color:#bf616a;>Fgets</span><span>(sendline, MAXLINE, fp) != </span><span style=color:#d08770;>NULL</span><span>) {
</span><span>
</span><span>        </span><span style=color:#65737e;>//首次调用sendto时没有绑定一个本地接口，内核在此时为它选择一个临时端口
</span><span>        </span><span style=color:#bf616a;>Sendto</span><span>(sockfd, sendline, </span><span style=color:#96b5b4;>strlen</span><span>(sendline), </span><span style=color:#d08770;>0</span><span>, pservaddr, servlen);
</span><span>
</span><span>        </span><span style=color:#65737e;>//最后两个参数是空指针，表示并不关心应答数据报由谁发送
</span><span>        </span><span style=color:#65737e;>//任何接收的数据报均被认为是服务器的内容
</span><span>        n = </span><span style=color:#bf616a;>Recvfrom</span><span>(sockfd, recvline, MAXLINE, </span><span style=color:#d08770;>0</span><span>, </span><span style=color:#d08770;>NULL</span><span>, </span><span style=color:#d08770;>NULL</span><span>);
</span><span>
</span><span>        recvline[n] = </span><span style=color:#d08770;>0</span><span>;    </span><span style=color:#65737e;>/* null terminate */
</span><span>        </span><span style=color:#bf616a;>Fputs</span><span>(recvline, stdout);
</span><span>    }
</span><span>}
</span></code></pre><h2 id=8-7-shu-ju-bao-de-diu-shi>8.7 数据报的丢失</h2><p>UDP客户/服务器例子是不可靠的：如果客户数据报到达服务器，但是服务器的应答丢失了，则客户将永远阻塞于dg_cli函数的recvfrom调用，等待一个永远不会到达的服务器应答。<p>防止永久阻塞的一般方法是给客户的recvfrom调用设置一个超时，但是这并不是完整的解决办法。<h2 id=8-8-yan-zheng-jie-shou-dao-de-xiang-ying>8.8 验证接收到的响应</h2><p>知道客户临时端口的任何进程都可以往客户发送数据报，而这些数据报会与正常的服务器应答混杂。<p>通过在dg_cli函数的recvfrom调用中，通知内核返回数据报发送者的地址，通过比较recvfrom在值-结果传参中返回的长度，然后用memcmp比较套接字地址结构本身，验证接收到的响应。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>void
</span><span style=color:#8fa1b3;>dg_cli</span><span>(FILE *</span><span style=color:#bf616a;>fp</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, </span><span style=color:#b48ead;>const</span><span> SA *</span><span style=color:#bf616a;>pservaddr</span><span>, socklen_t </span><span style=color:#bf616a;>servlen</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>                    n;
</span><span>    </span><span style=color:#b48ead;>char</span><span>                sendline[MAXLINE], recvline[MAXLINE + </span><span style=color:#d08770;>1</span><span>];
</span><span>    socklen_t              len;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr        *preply_addr;
</span><span>
</span><span>    preply_addr = </span><span style=color:#bf616a;>Malloc</span><span>(servlen);
</span><span>
</span><span>    </span><span style=color:#b48ead;>while </span><span>(</span><span style=color:#bf616a;>Fgets</span><span>(sendline, MAXLINE, fp) != </span><span style=color:#d08770;>NULL</span><span>) {
</span><span>
</span><span>        </span><span style=color:#bf616a;>Sendto</span><span>(sockfd, sendline, </span><span style=color:#96b5b4;>strlen</span><span>(sendline), </span><span style=color:#d08770;>0</span><span>, pservaddr, servlen);
</span><span>
</span><span>        len = servlen;
</span><span>        n = </span><span style=color:#bf616a;>Recvfrom</span><span>(sockfd, recvline, MAXLINE, </span><span style=color:#d08770;>0</span><span>, preply_addr, &len);
</span><span>        </span><span style=color:#b48ead;>if </span><span>(len != servlen || </span><span style=color:#96b5b4;>memcmp</span><span>(pservaddr, preply_addr, len) != </span><span style=color:#d08770;>0</span><span>) {
</span><span>            </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>reply from </span><span style=color:#d08770;>%s</span><span style=color:#a3be8c;> (ignored)</span><span style=color:#96b5b4;>\n</span><span>",
</span><span>                    </span><span style=color:#bf616a;>Sock_ntop</span><span>(preply_addr, len));
</span><span>            </span><span style=color:#b48ead;>continue</span><span>;
</span><span>        }
</span><span>
</span><span>        recvline[n] = </span><span style=color:#d08770;>0</span><span>;    </span><span style=color:#65737e;>/* null terminate */
</span><span>        </span><span style=color:#bf616a;>Fputs</span><span>(recvline, stdout);
</span><span>    }
</span><span>}
</span></code></pre><p>如果服务器运行在只有单个IP的主机上，那么新版的客户将正常工作，如果服务器主机是多宿的，该客户可能失败：发送到服务器数据的地址和接收服务器数据的地址可能不同。<p>解决办法：<ul><li>将返回的IP地址通过DNS中查找服务器主机的名字来验证主机的域名<li>为服务器每个IP绑定一个套接字，在所有套接字上使用select，使应答的套接字上绑定的IP地址就是客户请求的目的IP地址</ul><h2 id=8-9-fu-wu-qi-jin-cheng-wei-yun-xing>8.9 服务器进程未运行</h2><p>服务器进程不启动的情况下，客户永远阻塞在它的recvfrom调用，等待一个永不出现的服务器应答：<ul><li>客户主机进行ARP请求后获取服务器地址<li>客户发送数据后，返回“端口不可达”的ICMP消息，但该消息不会返回给客户进程</ul><p>这个ICMP错误称为<strong>异步错误</strong>，该错误由sendto引起，但是sendto本身却成功返回。UDP输出操作成功后仅仅返回表示在接口输出队列中具有存放所形成IP数据报的空间，该ICMP错误直到后来才返回，故称其为异步。<p>一个基本的规则：对于一个UDP套接字，由它引起的异步错误却并不返回给它，除非它已连接。ICMP出错信息包含引起错误的数据报的IP首部和UDP首部，而recvfrom可以返回的信息只有errno值，没法返回出错数据报的目的IP地址和目的UDP端口号，因此做出决定：仅在进程已将其UDP套接字连接到恰恰一个对端后，这些异步错误才返回给进程。<blockquote><p>只要SO_BSDCOMPAT套记者选项没有开启，Linux甚至对未连接的套接字也返回大多数ICMP “destination unreachable”错误。</blockquote><h2 id=8-10-udpcheng-xu-li-zi-xiao-jie>8.10 UDP程序例子小结</h2><p><img alt=image-20200816101704301 src=image-20200816101704301.png><ul><li>客户临时端口是在第一次调用sendto时一次性选定，不能改变<li>客户的IP地址可以随客户发送的每个UDP数据报而变动</ul><p><img alt=image-20200816101727333 src=image-20200816101727333.png><ul><li>对于UDP套接字来是，目的IP地址只能通过为IPv4设置IP_RECVDSTADDR套接字选项（或为IPv6设置IPV6_PKTINFO套接字选项）然后调用recvmsg取得。</ul><h2 id=8-11-udpde-connecthan-shu>8.11 UDP的connect函数</h2><p>UDP套接字的connect没有三路握手过程，内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回到调用进程：<ul><li>未连接UDP套接字，新创建的UDP套接字默认如此<li>已连接UDP套接字，对UDP套接字调用connect的结果</ul><p>已连接UDP套接字对比默认的未连接套接字的三个变化：<ul><li><p>不能给输出操作指定目的IP地址和端口号，而是改用write或send</p> <ul><li>不使用sendto<li>使用sendto，但是不能指定目的地址，sendto的第五个参数为空指针，第六个参数为0</ul> <blockquote><p>POSIX规范指出当第五个参数是空指针时，第六个参数的取值就不再考虑</blockquote><li><p>不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</p> <ul><li>准确说是仅能与一个IP地址交换数据报，可能connect到多播或广播地址</ul><li><p>已连接UDP套接字的异步错误会返回给它们所在的进程，而未连接UDP套接字不接受任何异步错误</p></ul><p><img alt=image-20200816103351241 src=image-20200816103351241.png><p><img alt=image-20200816103527775 src=image-20200816103527775.png><p>UDP客户进程或服务进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect，调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信（如TFTP），这种情况下，客户和服务器都可能调用connect。<h3 id=8-11-1-gei-yi-ge-udptao-jie-zi-duo-ci-diao-yong-connect>8.11.1 给一个UDP套接字多次调用connect</h3><p>一个已连接UDP套接字的进程可由下列两个目的再次调用connect：<ul><li>指定新的IP地址和端口号 <ul><li>TCP套接字connect只能调用一次</ul><li>断开套接字 <ul><li>为了断开一个已连接UDP套接字，我们再次调用connect时把套接字地址结构的地址族成员（对于IPv4为sin_family，对于IPv6为sin6_family）设置为AF_UNSPEC，这样做可能会返回一个EAFNOSUPPORT错误，不过没关系<li>有些系统可以用空的套接字地址结构指针调用connect，POSIX规范和BSD手册只是提示必须使用一个空地址而没有提到出错返回值。最便于移植的解决办法是：<strong>清零一个地址结构后把它的地址族成员设置为AF_UNSPEC，再把它传递给connect</strong></ul></ul><h3 id=8-11-2-xing-neng>8.11.2 性能</h3><p>在一个未连接UDP套接字上给两个数据报调用sendto函数涉及6个步骤（源自Berkeley内核）：<ul><li>连接套接字（第一次很可能搜索路由表）<li>输出第一个数据报<li>断开套接字连接<li>连接套接字（第二次的目的地址可能等同第一次，则无需搜索路由表）<li>输出第二个数据报<li>断开套接字连接</ul><p>当应用进程知道自己要给同一目的地址发送多个数据报时，显示连接套接字效率更高，调用connect后调用两次write涉及内核的执行步骤如下：<ul><li>连接套接字<li>输出第一个数据报<li>输出第二个数据报</ul><h2 id=8-12-dg-clihan-shu-xiu-ding-ban>8.12 dg_cli函数（修订版）</h2><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>void
</span><span style=color:#8fa1b3;>dg_cli</span><span>(FILE *</span><span style=color:#bf616a;>fp</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, </span><span style=color:#b48ead;>const</span><span> SA *</span><span style=color:#bf616a;>pservaddr</span><span>, socklen_t </span><span style=color:#bf616a;>servlen</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>            n;
</span><span>    </span><span style=color:#b48ead;>char</span><span>        sendline[MAXLINE], recvline[MAXLINE + </span><span style=color:#d08770;>1</span><span>];
</span><span>
</span><span>    </span><span style=color:#bf616a;>Connect</span><span>(sockfd, (SA *) pservaddr, servlen);
</span><span>
</span><span>    </span><span style=color:#b48ead;>while </span><span>(</span><span style=color:#bf616a;>Fgets</span><span>(sendline, MAXLINE, fp) != </span><span style=color:#d08770;>NULL</span><span>) {
</span><span>
</span><span>        </span><span style=color:#bf616a;>Write</span><span>(sockfd, sendline, </span><span style=color:#96b5b4;>strlen</span><span>(sendline));
</span><span>
</span><span>        n = </span><span style=color:#bf616a;>Read</span><span>(sockfd, recvline, MAXLINE);
</span><span>
</span><span>        recvline[n] = </span><span style=color:#d08770;>0</span><span>;    </span><span style=color:#65737e;>/* null terminate */
</span><span>        </span><span style=color:#bf616a;>Fputs</span><span>(recvline, stdout);
</span><span>    }
</span><span>}
</span></code></pre><p>函数不查看传递给connect的套接字地址结构的内容，仍是协议无关的。<h2 id=8-13-udpque-fa-liu-liang-kong-zhi>8.13 UDP缺乏流量控制</h2><p><strong>UDP套接字接收缓冲区</strong>：由UDP给某个特定套接字排队的UDP数据报数目受限于该套接字接收缓冲区的大小，可以使用SO_RCVBUF套接字选项修改改制。<p>增加流量控制的UDP示例：<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>#define    </span><span>NDG        </span><span style=color:#d08770;>2000    </span><span style=color:#65737e;>/* datagrams to send */
</span><span style=color:#b48ead;>#define    </span><span>DGLEN    </span><span style=color:#d08770;>1400    </span><span style=color:#65737e;>/* length of each datagram */
</span><span>
</span><span style=color:#b48ead;>void
</span><span style=color:#8fa1b3;>dg_cli</span><span>(FILE *</span><span style=color:#bf616a;>fp</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, </span><span style=color:#b48ead;>const</span><span> SA *</span><span style=color:#bf616a;>pservaddr</span><span>, socklen_t </span><span style=color:#bf616a;>servlen</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>        i;
</span><span>    </span><span style=color:#b48ead;>char</span><span>    sendline[DGLEN];
</span><span>
</span><span>    </span><span style=color:#b48ead;>for </span><span>(i = </span><span style=color:#d08770;>0</span><span>; i < NDG; i++) {
</span><span>        </span><span style=color:#bf616a;>Sendto</span><span>(sockfd, sendline, DGLEN, </span><span style=color:#d08770;>0</span><span>, pservaddr, servlen);
</span><span>    }
</span><span>}
</span></code></pre><pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>static void    </span><span style=color:#8fa1b3;>recvfrom_int</span><span>(</span><span style=color:#bf616a;>int</span><span>);
</span><span style=color:#b48ead;>static int</span><span>    count;
</span><span>
</span><span style=color:#b48ead;>void
</span><span style=color:#8fa1b3;>dg_echo</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>sockfd</span><span>, SA *</span><span style=color:#bf616a;>pcliaddr</span><span>, socklen_t </span><span style=color:#bf616a;>clilen</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>            n;
</span><span>    socklen_t      len;
</span><span>    </span><span style=color:#b48ead;>char</span><span>           mesg[MAXLINE];
</span><span>
</span><span>    </span><span style=color:#bf616a;>Signal</span><span>(SIGINT, recvfrom_int);
</span><span>
</span><span>    n = </span><span style=color:#d08770;>220 </span><span>* </span><span style=color:#d08770;>1024</span><span>;
</span><span>    </span><span style=color:#bf616a;>Setsockopt</span><span>(sockfd, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n));
</span><span>
</span><span>    </span><span style=color:#b48ead;>for </span><span>( ; ; ) {
</span><span>        len = clilen;
</span><span>        </span><span style=color:#bf616a;>Recvfrom</span><span>(sockfd, mesg, MAXLINE, </span><span style=color:#d08770;>0</span><span>, pcliaddr, &len);
</span><span>
</span><span>        count++;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#b48ead;>static void
</span><span style=color:#8fa1b3;>recvfrom_int</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>signo</span><span>)
</span><span>{
</span><span>    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#96b5b4;>\n</span><span style=color:#a3be8c;>received </span><span style=color:#d08770;>%d</span><span style=color:#a3be8c;> datagrams</span><span style=color:#96b5b4;>\n</span><span>", count);
</span><span>    </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span><span>}
</span></code></pre><h2 id=8-14-udpzhong-de-wai-chu-jie-kou-de-que-ding>8.14 udp中的外出接口的确定</h2><p>已连接UDP套接字还可以用来确定用于某个特定目的地址的外出接口。因为connect函数应用到UDP套接字时有一个副作用：内核选择本地IP地址（未使用bind），这个本地IP地址通过为目的地址搜索路由表得到外出接口，然后选用该接口的主IP地址而选定。<p>在UDP套接字上调用connect并不给对端主机发送任何信息，它完全是一个本地操作，只是保存对端的IP地址和端口号。<p>在一个未绑定端口号的UDP套接字上调用connect同时也给该套接字指派一个临时端口。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>//使用connect来确定输出接口的UDP程序
</span><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>int
</span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char </span><span>**</span><span style=color:#bf616a;>argv</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>                        sockfd;
</span><span>    socklen_t                  len;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr_in         cliaddr, servaddr;
</span><span>
</span><span>    </span><span style=color:#b48ead;>if </span><span>(argc != </span><span style=color:#d08770;>2</span><span>)
</span><span>        </span><span style=color:#bf616a;>err_quit</span><span>("</span><span style=color:#a3be8c;>usage: udpcli &LTIPaddress></span><span>");
</span><span>
</span><span>    sockfd = </span><span style=color:#bf616a;>Socket</span><span>(AF_INET, SOCK_DGRAM, </span><span style=color:#d08770;>0</span><span>);
</span><span>
</span><span>    </span><span style=color:#bf616a;>bzero</span><span>(&servaddr, sizeof(servaddr));
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_family </span><span>= AF_INET;
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_port </span><span>= </span><span style=color:#bf616a;>htons</span><span>(SERV_PORT);
</span><span>    </span><span style=color:#bf616a;>Inet_pton</span><span>(AF_INET, argv[</span><span style=color:#d08770;>1</span><span>], &servaddr.</span><span style=color:#bf616a;>sin_addr</span><span>);
</span><span>
</span><span>    </span><span style=color:#bf616a;>Connect</span><span>(sockfd, (SA *) &servaddr, sizeof(servaddr));
</span><span>
</span><span>    len = sizeof(cliaddr);
</span><span>    </span><span style=color:#bf616a;>Getsockname</span><span>(sockfd, (SA *) &cliaddr, &len);
</span><span>    </span><span style=color:#96b5b4;>printf</span><span>("</span><span style=color:#a3be8c;>local address </span><span style=color:#d08770;>%s</span><span style=color:#96b5b4;>\n</span><span>", </span><span style=color:#bf616a;>Sock_ntop</span><span>((SA *) &cliaddr, len));
</span><span>
</span><span>    </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span><span>}
</span></code></pre><h2 id=8-15-shi-yong-selecthan-shu-de-tcphe-udphui-she-fu-wu-qi-cheng-xu>8.15 使用select函数的tcp和udp回射服务器程序</h2><p>将并发TCP回射服务器程序与迭代UDP回射服务器程序组合成单个使用select来复用TCP和UDP套接字的服务器程序。<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#65737e;>/* include udpservselect01 */
</span><span style=color:#b48ead;>#include    </span><span>"</span><span style=color:#a3be8c;>unp.h</span><span>"
</span><span>
</span><span style=color:#b48ead;>int
</span><span style=color:#8fa1b3;>main</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span>, </span><span style=color:#b48ead;>char </span><span>**</span><span style=color:#bf616a;>argv</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead;>int</span><span>                    listenfd, connfd, udpfd, nready, maxfdp1;
</span><span>    </span><span style=color:#b48ead;>char</span><span>                   mesg[MAXLINE];
</span><span>    pid_t                  childpid;
</span><span>    fd_set                 rset;
</span><span>    ssize_t                n;
</span><span>    socklen_t              len;
</span><span>    </span><span style=color:#b48ead;>const int</span><span>              on = </span><span style=color:#d08770;>1</span><span>;
</span><span>    </span><span style=color:#b48ead;>struct</span><span> sockaddr_in     cliaddr, servaddr;
</span><span>    </span><span style=color:#b48ead;>void                   </span><span style=color:#bf616a;>sig_chld</span><span>(</span><span style=color:#b48ead;>int</span><span>);
</span><span>
</span><span>        </span><span style=color:#65737e;>/* create listening TCP socket */
</span><span>    listenfd = </span><span style=color:#bf616a;>Socket</span><span>(AF_INET, SOCK_STREAM, </span><span style=color:#d08770;>0</span><span>);
</span><span>
</span><span>    </span><span style=color:#bf616a;>bzero</span><span>(&servaddr, sizeof(servaddr));
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_family      </span><span>= AF_INET;
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_addr</span><span>.</span><span style=color:#bf616a;>s_addr </span><span>= </span><span style=color:#bf616a;>htonl</span><span>(INADDR_ANY);
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_port        </span><span>= </span><span style=color:#bf616a;>htons</span><span>(SERV_PORT);
</span><span>
</span><span>    </span><span style=color:#65737e;>//设置SO_REUSEADDR套接字选项防止该端口上已有连接存在
</span><span>    </span><span style=color:#bf616a;>Setsockopt</span><span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
</span><span>    </span><span style=color:#bf616a;>Bind</span><span>(listenfd, (SA *) &servaddr, sizeof(servaddr));
</span><span>
</span><span>    </span><span style=color:#bf616a;>Listen</span><span>(listenfd, LISTENQ);
</span><span>
</span><span>        </span><span style=color:#65737e;>/* create UDP socket */
</span><span>    udpfd = </span><span style=color:#bf616a;>Socket</span><span>(AF_INET, SOCK_DGRAM, </span><span style=color:#d08770;>0</span><span>);
</span><span>
</span><span>    </span><span style=color:#bf616a;>bzero</span><span>(&servaddr, sizeof(servaddr));
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_family      </span><span>= AF_INET;
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_addr</span><span>.</span><span style=color:#bf616a;>s_addr </span><span>= </span><span style=color:#bf616a;>htonl</span><span>(INADDR_ANY);
</span><span>    servaddr.</span><span style=color:#bf616a;>sin_port        </span><span>= </span><span style=color:#bf616a;>htons</span><span>(SERV_PORT);
</span><span>
</span><span>    </span><span style=color:#bf616a;>Bind</span><span>(udpfd, (SA *) &servaddr, sizeof(servaddr));
</span><span style=color:#65737e;>/* end udpservselect01 */
</span><span>
</span><span style=color:#65737e;>/* include udpservselect02 */
</span><span>    </span><span style=color:#65737e;>//给SIGCHLD建立信号处理程序，因为TCP连接将由某个子进程处理
</span><span>    </span><span style=color:#bf616a;>Signal</span><span>(SIGCHLD, sig_chld);    </span><span style=color:#65737e;>/* must call waitpid() */
</span><span>
</span><span>    </span><span style=color:#bf616a;>FD_ZERO</span><span>(&rset);
</span><span>    maxfdp1 = </span><span style=color:#bf616a;>max</span><span>(listenfd, udpfd) + </span><span style=color:#d08770;>1</span><span>;
</span><span>    </span><span style=color:#b48ead;>for </span><span>( ; ; ) {
</span><span>        </span><span style=color:#bf616a;>FD_SET</span><span>(listenfd, &rset);
</span><span>        </span><span style=color:#bf616a;>FD_SET</span><span>(udpfd, &rset);
</span><span>        </span><span style=color:#b48ead;>if </span><span>( (nready = </span><span style=color:#bf616a;>select</span><span>(maxfdp1, &rset, </span><span style=color:#d08770;>NULL</span><span>, </span><span style=color:#d08770;>NULL</span><span>, </span><span style=color:#d08770;>NULL</span><span>)) < </span><span style=color:#d08770;>0</span><span>) {
</span><span>            </span><span style=color:#b48ead;>if </span><span>(errno == EINTR)
</span><span>                </span><span style=color:#b48ead;>continue</span><span>;        </span><span style=color:#65737e;>/* back to for() */
</span><span>            </span><span style=color:#b48ead;>else
</span><span>                </span><span style=color:#65737e;>//sig_chld信号处理程序可能会中断select调用，需要处理EINTR错误
</span><span>                </span><span style=color:#bf616a;>err_sys</span><span>("</span><span style=color:#a3be8c;>select error</span><span>");
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#bf616a;>FD_ISSET</span><span>(listenfd, &rset)) {
</span><span>            len = sizeof(cliaddr);
</span><span>            connfd = </span><span style=color:#bf616a;>Accept</span><span>(listenfd, (SA *) &cliaddr, &len);
</span><span>    
</span><span>            </span><span style=color:#b48ead;>if </span><span>( (childpid = </span><span style=color:#bf616a;>Fork</span><span>()) == </span><span style=color:#d08770;>0</span><span>) {    </span><span style=color:#65737e;>/* child process */
</span><span>                </span><span style=color:#bf616a;>Close</span><span>(listenfd);    </span><span style=color:#65737e;>/* close listening socket */
</span><span>                </span><span style=color:#bf616a;>str_echo</span><span>(connfd);    </span><span style=color:#65737e;>/* process the request */
</span><span>                </span><span style=color:#96b5b4;>exit</span><span>(</span><span style=color:#d08770;>0</span><span>);
</span><span>            }
</span><span>            </span><span style=color:#bf616a;>Close</span><span>(connfd);            </span><span style=color:#65737e;>/* parent closes connected socket */
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#bf616a;>FD_ISSET</span><span>(udpfd, &rset)) {
</span><span>            len = sizeof(cliaddr);
</span><span>            n = </span><span style=color:#bf616a;>Recvfrom</span><span>(udpfd, mesg, MAXLINE, </span><span style=color:#d08770;>0</span><span>, (SA *) &cliaddr, &len);
</span><span>
</span><span>            </span><span style=color:#bf616a;>Sendto</span><span>(udpfd, mesg, n, </span><span style=color:#d08770;>0</span><span>, (SA *) &cliaddr, len);
</span><span>        }
</span><span>    }
</span><span>}
</span><span style=color:#65737e;>/* end udpservselect02 */
</span><span>
</span></code></pre></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 modao</span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>