<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>Programming-Language</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://modao.site/算法与数据结构/algorithm/suan-fa-pai-xu/>算法-排序</a></h1><div class=post-meta-inline><span class=post-date> 2020-06-14 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/algorithm/>#Algorithm</a></span><div class=post-content><p>学习并记录下排序算法，方便回顾。<p>排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性 ---|---|---|---|+++ 冒泡排序| O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定 选择排序| O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|数组不稳定、链表稳定 插入排序| O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定 快速排序| O(n<em>log<sub>2</sub>n) | O(n<sup>2</sup>) | O(log<sub>2</sub>n) | 不稳定 堆排序| O(n</em>log<sub>2</sub>n)|O(n<em>log<sub>2</sub>n)|O(1)|不稳定 归并排序| O(n</em>log<sub>2</sub>n) | O(n<em>log<sub>2</sub>n)|O(n)|稳定 希尔排序| O(n</em>log<sup>2</sup>n)|O(n<sup>2</sup>)|O(1)|不稳定 计数排序 | O(n+m)|O(n+m)|O(n+m)|稳定 桶排序 | O(n)|O(n)|O(m)|稳定 基数排序| O(k*n)|O(n<sup>2</sup>)| |稳定<blockquote><ul><li>均按从小到大排列<li>k：代表数值中的 “数位” 个数<li>n：代表数据规模<li>m：代表数据的最大值减最小值<li>来自：<a href=https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95>wikipedia . 排序算法</a></ul></blockquote><h2 id=mou-pao-pai-xu>冒泡排序</h2><p><strong>N</strong>个元素进行排序，总共需要<strong>N-1</strong>趟排序，第<strong>i</strong>趟需要排序的次数为<strong>N-i</strong>。($1 \leq i \leq N-1$）<p>思路：<ol><li>第<strong>i</strong>趟，比较前<strong>N-i-1</strong>个元素，<strong>比较相邻元素</strong><li>比较第1个和第2个元素，将值小的放前面，值大的放后面<li>比较第2个和第3个元素，……，比较<strong>N-i</strong>次<li>每一趟比较都会将最大值放每一趟的最后面，实现将值大的元素冒泡到最后面【第i趟将第i大值存放到倒数第i位】</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//普通冒泡排序
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>BubbleSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < len - </span><span style=color:#d08770;>1</span><span>; ++i){
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = </span><span style=color:#d08770;>0</span><span>; j < len - </span><span style=color:#d08770;>1 </span><span>- i; ++j){
</span><span>            </span><span style=color:#b48ead;>if </span><span>(v[j] > v[j + </span><span style=color:#d08770;>1</span><span>])
</span><span>                </span><span style=color:#bf616a;>swap</span><span>(v[j], v[j + </span><span style=color:#d08770;>1</span><span>]);
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return</span><span>;
</span><span>}
</span><span style=color:#65737e;>//优化：当有一趟比较过程中一次交换都没出现，则说明当前已经是有序状态，排序结束
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>BubbleSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < len - </span><span style=color:#d08770;>1</span><span>; ++i){
</span><span>        </span><span style=color:#b48ead;>bool</span><span> flag = </span><span style=color:#d08770;>true</span><span>;
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = </span><span style=color:#d08770;>0</span><span>; j < len - </span><span style=color:#d08770;>1 </span><span>- i; ++j){
</span><span>            </span><span style=color:#b48ead;>if </span><span>(v[j] > v[j + </span><span style=color:#d08770;>1</span><span>]){
</span><span>                </span><span style=color:#bf616a;>swap</span><span>(v[j], v[j + </span><span style=color:#d08770;>1</span><span>]);
</span><span>                flag = </span><span style=color:#d08770;>false</span><span>;
</span><span>            }
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>if</span><span>(flag)</span><span style=color:#b48ead;>return</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return</span><span>;
</span><span>}
</span><span style=color:#65737e;>//放个参数是数组的
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>BubbleSort</span><span>(</span><span style=color:#b48ead;>int </span><span>*</span><span style=color:#bf616a;>a</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = sizeof a / sizeof *a;
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < len - </span><span style=color:#d08770;>1</span><span>; ++i){
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = </span><span style=color:#d08770;>0</span><span>; j < len - </span><span style=color:#d08770;>1 </span><span>- i; ++j){
</span><span>            </span><span style=color:#b48ead;>if </span><span>(v[j] > v[j + </span><span style=color:#d08770;>1</span><span>])
</span><span>                </span><span style=color:#bf616a;>swap</span><span>(v[j], v[j + </span><span style=color:#d08770;>1</span><span>]);
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return</span><span>;
</span><span>}
</span><span>
</span></code></pre><h2 id=xuan-ze-pai-xu>选择排序</h2><p><strong>N</strong>个元素进行排序，总共需要<strong>N-1</strong>次选择，将第<strong>i</strong>次选择的结果作为第<strong>i</strong>个元素。($1 \leq i \leq N-1$）<p>思路：<ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾<li>以此类推，直到所有元素均排序完毕</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>SelectionSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> min_index, len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < len - </span><span style=color:#d08770;>1</span><span>; ++i){
</span><span>        min_index = i;
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = i + </span><span style=color:#d08770;>1</span><span>; j < len; ++j){
</span><span>            </span><span style=color:#b48ead;>if</span><span>(v[j] < v[min_index])min_index = j;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>if</span><span>(i != min_index)
</span><span>            </span><span style=color:#bf616a;>swap</span><span>(v[i], v[min_index]);
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return</span><span>;
</span><span>}
</span></code></pre><h2 id=cha-ru-pai-xu>插入排序</h2><p>思路：<ol><li>从第一个元素开始，该元素可以认定为已经被排序，其他元素均认为未排序<li>取下未排序的第一个元素a，在已经排序的元素序列中从后向前扫描，将扫描到的已排序元素b与a比较 <ol><li>a > b，将a元素后移一位，b存于a原来的位置<li>a <= b，则b已经存放于a后面，不必移位</ol><li>重复第2步骤直到全部排序完成</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>InsertSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>1</span><span>; i < len; ++i){
</span><span>        </span><span style=color:#b48ead;>int</span><span> temp = v[i];
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = i - </span><span style=color:#d08770;>1</span><span>; j >= </span><span style=color:#d08770;>0</span><span>; --j){
</span><span>            </span><span style=color:#b48ead;>if</span><span>(v[j] > temp){
</span><span>                v[j + </span><span style=color:#d08770;>1</span><span>] = v[j];
</span><span>                v[j] = temp;
</span><span>            }
</span><span>            </span><span style=color:#b48ead;>else break</span><span>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h2 id=kuai-su-pai-xu>快速排序</h2><p>递归的思路：<ol><li>选取第一个数作为基准<li>将比基准小的数交换到前面，比基准大的数交换到后面<li>对左右区间重复第2步，直到各个区间只有一个数</ol><p>迭代的思路：<ol><li>将需要快排的区间压栈<li>如果栈里的区间不为空，从栈里取出最末尾的区间 <ol><li>区间大小为0或1，则不进行快排<li>进行快排，产生两个子区间</ol><li>将快排结果的两个子区间压栈</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//递归
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>QuickSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>low</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>high</span><span>){
</span><span>    </span><span style=color:#b48ead;>if</span><span>(low >= high)	</span><span style=color:#65737e;>//表明数据只有一个元素了，排序完成
</span><span>        </span><span style=color:#b48ead;>return</span><span>;
</span><span>    </span><span style=color:#b48ead;>int</span><span> first = low;
</span><span>    </span><span style=color:#b48ead;>int</span><span> last = high;
</span><span>    </span><span style=color:#b48ead;>int</span><span> key = v[first];
</span><span>    
</span><span>    </span><span style=color:#b48ead;>while</span><span>(first < last){
</span><span>        </span><span style=color:#65737e;>//从后往前找，将小于基准的移到前面
</span><span>        </span><span style=color:#b48ead;>while</span><span>(first < last && v[last] >= key)
</span><span>            --last;
</span><span>        </span><span style=color:#65737e;>//判断前面的循环是因为v[last] >= key而退出来的
</span><span>        </span><span style=color:#b48ead;>if</span><span>(first < last)
</span><span>            v[first++] = v[last];
</span><span>        
</span><span>        </span><span style=color:#65737e;>//从前往后找，将大于基准的移到后面
</span><span>        </span><span style=color:#b48ead;>while</span><span>(first < last && v[first] <= key)
</span><span>            ++first;
</span><span>        </span><span style=color:#65737e;>//判断前面的循环是因为v[first] <= key而退出来的
</span><span>        </span><span style=color:#b48ead;>if</span><span>(first < last)
</span><span>            v[last--] = v[first];
</span><span>    }
</span><span>    </span><span style=color:#65737e;>//将基准归位
</span><span>    v[first] = key;
</span><span>    </span><span style=color:#65737e;>//对子区间递归
</span><span>    </span><span style=color:#bf616a;>QuickSort</span><span>(v, low, first - </span><span style=color:#d08770;>1</span><span>);
</span><span>    </span><span style=color:#bf616a;>QuickSort</span><span>(v, first + </span><span style=color:#d08770;>1</span><span>, high);
</span><span>}
</span><span>
</span><span style=color:#65737e;>//迭代
</span><span style=color:#b48ead;>struct </span><span>Range{
</span><span>    </span><span style=color:#b48ead;>int</span><span> first, last;
</span><span>    </span><span style=color:#8fa1b3;>Range</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>f </span><span>= </span><span style=color:#d08770;>0</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>l </span><span>= </span><span style=color:#d08770;>0</span><span>):</span><span style=color:#bf616a;>first</span><span>(f), </span><span style=color:#bf616a;>last</span><span>(l){}
</span><span>};
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>QuickSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>low</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>high</span><span>){
</span><span>    </span><span style=color:#b48ead;>if</span><span>(low >= high)	</span><span style=color:#65737e;>//表明数据只有一个元素了，排序完成
</span><span>        </span><span style=color:#b48ead;>return</span><span>;
</span><span>    </span><span style=color:#b48ead;>const </span><span>size_t len = high - low + </span><span style=color:#d08770;>1</span><span>;
</span><span>    Range r[len];
</span><span>    </span><span style=color:#b48ead;>int</span><span> p = </span><span style=color:#d08770;>0</span><span>;
</span><span>    r[p++] = </span><span style=color:#bf616a;>Range</span><span>(low, high);
</span><span>    </span><span style=color:#b48ead;>while</span><span>(p){
</span><span>        Range temp = r[--p];
</span><span>        </span><span style=color:#b48ead;>if</span><span>(temp.</span><span style=color:#bf616a;>first </span><span>>= temp.</span><span style=color:#bf616a;>last</span><span>){
</span><span>            </span><span style=color:#b48ead;>continue</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>int</span><span> key = v[temp.</span><span style=color:#bf616a;>first</span><span>];
</span><span>        </span><span style=color:#b48ead;>int</span><span> left = temp.</span><span style=color:#bf616a;>first</span><span>, right = temp.</span><span style=color:#bf616a;>last</span><span>;
</span><span>        </span><span style=color:#b48ead;>while</span><span>(left < right){
</span><span>            </span><span style=color:#b48ead;>while</span><span>(left < right && v[right] > key)
</span><span>                --right;
</span><span>            </span><span style=color:#b48ead;>while</span><span>(left < right && v[left] < key)
</span><span>                ++left;
</span><span>            </span><span style=color:#b48ead;>if</span><span>(left < right){
</span><span>                </span><span style=color:#bf616a;>swap</span><span>(v[left], v[right]);
</span><span>                --right;
</span><span>                ++left;
</span><span>            }
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>if</span><span>(v[temp.</span><span style=color:#bf616a;>first</span><span>] >= v[left])
</span><span>            </span><span style=color:#bf616a;>swap</span><span>(v[temp.</span><span style=color:#bf616a;>first</span><span>], v[left]);
</span><span>        </span><span style=color:#b48ead;>else
</span><span>            --left;
</span><span>        r[p++] = </span><span style=color:#bf616a;>Range</span><span>(temp.</span><span style=color:#bf616a;>first</span><span>, left - </span><span style=color:#d08770;>1</span><span>);
</span><span>        r[p++] = </span><span style=color:#bf616a;>Range</span><span>(left + </span><span style=color:#d08770;>1</span><span>, temp.</span><span style=color:#bf616a;>last</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><h2 id=dui-pai-xu>堆排序</h2><p>最大堆：<ol><li>构建堆 <ol><li>从最后一个父节点开始调整，调整为符合规则的堆<li>从最后一个父节点递减，将所有父节点从后向前进行调整<li>调整到父节点为根节点则调整完毕</ol><li>根据堆的特性：根节点存放最大值或最小值。将根节点与堆最后一个元素交换，并将堆的大小减一进行堆适应，重新调整为一个规则的堆<li>取出的元素按相反的顺序排列，完成排序</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//堆适应，使堆按规则存放
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>AdjustHeap</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>hole</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>len</span><span>){
</span><span>    </span><span style=color:#65737e;>//const int parent = hole;
</span><span>    </span><span style=color:#b48ead;>int</span><span> value = v[hole];
</span><span>    </span><span style=color:#b48ead;>int</span><span> right = </span><span style=color:#d08770;>2 </span><span>* hole + </span><span style=color:#d08770;>2</span><span>;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(right < len){
</span><span>        </span><span style=color:#b48ead;>if</span><span>(v[right] < v[right-</span><span style=color:#d08770;>1</span><span>])
</span><span>            --right;
</span><span>        </span><span style=color:#b48ead;>if</span><span>(v[hole] < v[right]){
</span><span>            </span><span style=color:#bf616a;>swap</span><span>(v[hole], v[right]);
</span><span>            hole = right;
</span><span>            right = </span><span style=color:#d08770;>2 </span><span>* hole + </span><span style=color:#d08770;>2</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else return</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>if</span><span>(right == len){
</span><span>        </span><span style=color:#b48ead;>if</span><span>(v[hole] < v[right - </span><span style=color:#d08770;>1</span><span>]){
</span><span>            </span><span style=color:#bf616a;>swap</span><span>(v[hole], v[right - </span><span style=color:#d08770;>1</span><span>]);
</span><span>            hole = right - </span><span style=color:#d08770;>1</span><span>;
</span><span>            v[hole] = value;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else return</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return</span><span>;
</span><span>}
</span><span style=color:#65737e;>//构建堆
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>MakeHeap</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    cout << len << endl;
</span><span>    </span><span style=color:#b48ead;>if</span><span>(len < </span><span style=color:#d08770;>2</span><span>)</span><span style=color:#b48ead;>return</span><span>;
</span><span>    </span><span style=color:#b48ead;>int</span><span> parent = (len - </span><span style=color:#d08770;>2</span><span>)/</span><span style=color:#d08770;>2</span><span>;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(</span><span style=color:#d08770;>true</span><span>){
</span><span>        </span><span style=color:#bf616a;>AdjustHeap</span><span>(v, parent, len);
</span><span>        </span><span style=color:#b48ead;>if</span><span>(parent == </span><span style=color:#d08770;>0</span><span>)</span><span style=color:#b48ead;>return</span><span>;
</span><span>        parent--;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return</span><span>;
</span><span>}
</span><span style=color:#65737e;>//堆排序，逐个取出根节点
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>HeapSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = len - </span><span style=color:#d08770;>1</span><span>; i > </span><span style=color:#d08770;>0</span><span>; i--){
</span><span>        </span><span style=color:#bf616a;>swap</span><span>(v[</span><span style=color:#d08770;>0</span><span>], v[i]);
</span><span>        </span><span style=color:#bf616a;>AdjustHeap</span><span>(v, </span><span style=color:#d08770;>0</span><span>, i);
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return</span><span>;
</span><span>}
</span></code></pre><h2 id=gui-bing-pai-xu>归并排序</h2><p>递归思路：<ol><li>分解：将n个元素分成2个子序列<li>解决：对两个子序列进行归并排序，回归后得到两个有序的子序列 <ol><li>回归点：begin >= end，即子序列的元素个数为1后，经排序，返回有序的元素个数为2的子序列</ol><li>合并：将两个有序的子序列合并，得到有序序列（<strong>有序子序列才可顺利合并</strong>）</ol><p>迭代思路：<ol><li>通过设置区间，模仿递归到底层再回归的过程，区间大小从小到大，直接合并、回归</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//递归
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>MergeSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>, vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>ans</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>begin</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>end</span><span>){
</span><span>    </span><span style=color:#b48ead;>if</span><span>(begin >= end)
</span><span>        </span><span style=color:#b48ead;>return</span><span>;
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = end - begin;
</span><span>    </span><span style=color:#b48ead;>int</span><span> mid = (len >> </span><span style=color:#d08770;>1</span><span>) + begin;
</span><span>    </span><span style=color:#b48ead;>int</span><span> start1 = begin, start2 = mid;
</span><span>    </span><span style=color:#bf616a;>MergeSort</span><span>(v, ans, start1, mid);
</span><span>    </span><span style=color:#bf616a;>MergeSort</span><span>(v, ans, start2, end);
</span><span>    </span><span style=color:#b48ead;>int</span><span> index = begin;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(start1 < mid && start2 < end)
</span><span>        ans[index++] = v[start1] < v[start2] ? v[start1++] : v[start2++];
</span><span>    </span><span style=color:#b48ead;>while</span><span>(start1 < mid)
</span><span>        ans[index++] = v[start1++];
</span><span>    </span><span style=color:#b48ead;>while</span><span>(start2 < end)
</span><span>        ans[index++] = v[start2++];
</span><span>}
</span><span style=color:#65737e;>//迭代
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>MergeSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>, vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>ans</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>begin</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>end</span><span>){
</span><span>	</span><span style=color:#b48ead;>int</span><span> len = end - begin;
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> range = </span><span style=color:#d08770;>1</span><span>; range < len - </span><span style=color:#d08770;>1</span><span>; range << </span><span style=color:#d08770;>1</span><span>){
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> start = </span><span style=color:#d08770;>0</span><span>; start < len - range; start += (</span><span style=color:#d08770;>2 </span><span>* range)){
</span><span>            </span><span style=color:#b48ead;>int</span><span> mid = start + range, end = start + range + range;
</span><span>            </span><span style=color:#b48ead;>int</span><span> index = start;	</span><span style=color:#65737e;>//使用下标读写ans，必须确保ans初始化大小和v一样
</span><span>            </span><span style=color:#b48ead;>int</span><span> start1 = start, start2 = mid;	</span><span style=color:#65737e;>//[start, end)
</span><span>            </span><span style=color:#b48ead;>while</span><span>(start1 < mid && start2 < end)
</span><span>                ans[index++] = v[start1] < v[start2] ? v[start1++] : v[start2++];
</span><span>            </span><span style=color:#b48ead;>while</span><span>(start1 < mid)
</span><span>                ans[index++] = v[start1++];
</span><span>            </span><span style=color:#b48ead;>while</span><span>(start2 < end)
</span><span>                ans[index++] = v[start2++];
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h2 id=xi-er-pai-xu>希尔排序</h2><p>思路：<ol><li>按一定步长进行插入排序，步长逐渐减小，最终为1<li>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作<li>当步长为1时，算法变为插入排序，这就保证了数据一定会被排序<li>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，交换不相邻的元素以对数组的局部进行排序，最终用插入排序将局部有序的数组排序。</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#65737e;>//wikipedia解法，对其步长计算没理解
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>ShellSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>	</span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>int</span><span> h = </span><span style=color:#d08770;>1</span><span>;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(h < len/</span><span style=color:#d08770;>3</span><span>)
</span><span>        h = </span><span style=color:#d08770;>3 </span><span>* h + </span><span style=color:#d08770;>1</span><span>;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(h >= </span><span style=color:#d08770;>1</span><span>){
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = h; i < length; i++){
</span><span>            </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = i; j >= h && v[j] < v[j - h]; j -= h)
</span><span>                </span><span style=color:#bf616a;>swap</span><span>(v[j], v[j - h]);
</span><span>        }
</span><span>        h = h / </span><span style=color:#d08770;>3</span><span>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#65737e;>//步长为排序个数折半，步长折半减小，最终必须为1
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>ShellSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>	</span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> h = len >> </span><span style=color:#d08770;>1</span><span>; h > </span><span style=color:#d08770;>0</span><span>; h >>=</span><span style=color:#d08770;>1</span><span>){
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = h; i < len; i++){
</span><span>            </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = i; j >= h && v[j] < v[j - h]; j -= h)
</span><span>                </span><span style=color:#bf616a;>swap</span><span>(v[j], v[j - h]);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h2 id=ji-shu-pai-xu>计数排序</h2><p>计数排序：统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。<p>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。 如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。 计数排序不是比较排序，排序的速度快于任何比较排序算法。 时间复杂度为 O（n+k），空间复杂度为 O（n+k）<p>思路：<ol><li>找出无序序列v的最大和最小元素<li>创建次数数组vCount，对无序序列的元素出现的次数进行统计<li>对计数进行累加，从次数数组的头开始，每一项和前一项相加，此时次数数组的值就是该元素在有序数组中的位置<li>反向填充有序数组ans，将每个元素i放在ans的<strong>第vCount[i]项</strong>（从1开始算）</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>CountSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>, vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>ans</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>if</span><span>(!len)</span><span style=color:#b48ead;>return</span><span>;	</span><span style=color:#65737e;>// 确保待排序容器非空
</span><span>    
</span><span>    </span><span style=color:#65737e;>// 使用 v 的最大值 + 1 作为计数容器 vCount 的大小
</span><span>    </span><span style=color:#b48ead;>int</span><span> vCountLength = (*</span><span style=color:#bf616a;>max_element</span><span>(v.</span><span style=color:#bf616a;>begin</span><span>, v.</span><span style=color:#bf616a;>end</span><span>)) + </span><span style=color:#d08770;>1</span><span>;
</span><span>    vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>vCount</span><span>(vCountLength, </span><span style=color:#d08770;>0</span><span>);
</span><span>    
</span><span>    </span><span style=color:#65737e;>// 统计每个键值出现的次数
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < len; i++)
</span><span>        ++vCount[v[i]];
</span><span>    
</span><span>    </span><span style=color:#65737e;>// 后面的键值出现的位置为前面所有键值出现的次数之和
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>1</span><span>; i < vCountLength; i++)
</span><span>        vCount[i] += vCount[i - </span><span style=color:#d08770;>1</span><span>];
</span><span>    
</span><span>    </span><span style=color:#65737e;>// 将键值放到目标位置
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = len - </span><span style=color:#d08770;>1</span><span>; i >= </span><span style=color:#d08770;>0</span><span>; i--)	</span><span style=color:#65737e;>// 此处逆序是为了保持相同键值的稳定性
</span><span>        ans[--vCount[v[i]]] = v[i];
</span><span>}
</span><span>
</span><span style=color:#65737e;>//优化，待排序数组数量不多，但是数值大:对vCount大小进行精确设置，对v[i]稍加处理后才作为vCount下标
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>CountSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>, vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>ans</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>if</span><span>(!len)</span><span style=color:#b48ead;>return</span><span>;	</span><span style=color:#65737e;>// 确保待排序容器非空
</span><span>    
</span><span>    </span><span style=color:#65737e;>// 使用 v 的最大值 + 1 作为计数容器 vCount 的大小
</span><span>    </span><span style=color:#b48ead;>int</span><span> max = *</span><span style=color:#bf616a;>max_element</span><span>(v.</span><span style=color:#bf616a;>begin</span><span>, v.</span><span style=color:#bf616a;>end</span><span>);
</span><span>    </span><span style=color:#b48ead;>int</span><span> min = *</span><span style=color:#bf616a;>min_element</span><span>(v.</span><span style=color:#bf616a;>begin</span><span>, b.</span><span style=color:#bf616a;>end</span><span>);
</span><span>    </span><span style=color:#b48ead;>int</span><span> vCountLength = max - min + </span><span style=color:#d08770;>1</span><span>;
</span><span>    vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>vCount</span><span>(vCountLength, </span><span style=color:#d08770;>0</span><span>);
</span><span>    
</span><span>    </span><span style=color:#65737e;>// 统计每个键值出现的次数
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < len; i++)
</span><span>        ++vCount[v[i]-min];
</span><span>    
</span><span>    </span><span style=color:#65737e;>// 后面的键值出现的位置为前面所有键值出现的次数之和
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>1</span><span>; i < vCountLength; i++)
</span><span>        vCount[i] += vCount[i - </span><span style=color:#d08770;>1</span><span>];
</span><span>    
</span><span>    </span><span style=color:#65737e;>// 将键值放到目标位置
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = len - </span><span style=color:#d08770;>1</span><span>; i >= </span><span style=color:#d08770;>0</span><span>; i--)	</span><span style=color:#65737e;>// 此处逆序是为了保持相同键值的稳定性
</span><span>        ans[--vCount[v[i] - min]] = v[i];
</span><span>}
</span></code></pre><h2 id=tong-pai-xu>桶排序</h2><p>桶排序：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。 思路：<ol><li>设置一个定量的数组当作空桶子<li>寻访序列，把元素放到对应的桶内的同时执行插入排序，保持桶内元素有序<li>对每个桶进行合并，前提是桶内有序<li>将桶内数据倒出来，此时数据已经是排序好的</ol><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>const</span><span> in BUCKET_NUM = </span><span style=color:#d08770;>10</span><span>;	</span><span style=color:#65737e;>//假设数据分布在[0，100)之间
</span><span>
</span><span style=color:#b48ead;>struct </span><span>ListNode{
</span><span>    </span><span style=color:#b48ead;>explicit </span><span style=color:#8fa1b3;>ListNode</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>i </span><span>= </span><span style=color:#d08770;>0</span><span>):</span><span style=color:#bf616a;>data</span><span>(i), </span><span style=color:#bf616a;>next</span><span>(</span><span style=color:#d08770;>nullptr</span><span>){}
</span><span>    ListNode *next;
</span><span>    </span><span style=color:#b48ead;>int</span><span> data;
</span><span>}
</span><span>ListNode* </span><span style=color:#8fa1b3;>InsertBucket</span><span>(ListNode *</span><span style=color:#bf616a;>head</span><span>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>val</span><span>){
</span><span>    ListNode temp, </span><span style=color:#bf616a;>new_node</span><span>(val);
</span><span>    temp.</span><span style=color:#bf616a;>next </span><span>= head;
</span><span>    ListNode *pre = &temp, *cur = head;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(!cur && cur -> </span><span style=color:#bf616a;>data </span><span><= val){
</span><span>        pre = cur;
</span><span>        cur = cur -> </span><span style=color:#bf616a;>next</span><span>;
</span><span>    }
</span><span>    new_node.</span><span style=color:#bf616a;>next </span><span>= cur;
</span><span>    pre -> </span><span style=color:#bf616a;>next </span><span>= &new_node;
</span><span>    </span><span style=color:#b48ead;>return</span><span> temp.</span><span style=color:#bf616a;>next</span><span>;
</span><span>}
</span><span>
</span><span>ListNode* </span><span style=color:#8fa1b3;>MergeBucket</span><span>(ListNode *</span><span style=color:#bf616a;>head1</span><span>, ListNode *</span><span style=color:#bf616a;>head2</span><span>){
</span><span>    ListNode merge;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(!head1 && !head2){
</span><span>        </span><span style=color:#b48ead;>if</span><span>(head1 -> </span><span style=color:#bf616a;>data </span><span><= head2 -> </span><span style=color:#bf616a;>data</span><span>){
</span><span>            merge.</span><span style=color:#bf616a;>next </span><span>= head1;
</span><span>            head1 = head1 -> </span><span style=color:#bf616a;>next</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>else </span><span>{
</span><span>            merge.</span><span style=color:#bf616a;>next </span><span>= head2;
</span><span>            head2 = head2 -> </span><span style=color:#bf616a;>next</span><span>;
</span><span>        }
</span><span>        merge = merge.</span><span style=color:#bf616a;>next</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>if</span><span>(!head1)merge.</span><span style=color:#bf616a;>next </span><span>= head1;
</span><span>    </span><span style=color:#b48ead;>if</span><span>(!head2)merge.</span><span style=color:#bf616a;>next </span><span>= head2;
</span><span>    
</span><span>    </span><span style=color:#b48ead;>return</span><span> merge.</span><span style=color:#bf616a;>next</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>BucketSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>    vector&LTListNode*> </span><span style=color:#bf616a;>buckets</span><span>(BUCKET_NUM, </span><span style=color:#d08770;>0</span><span>);
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>0</span><span>; i < len; ++i){
</span><span>        </span><span style=color:#b48ead;>int</span><span> index = v[i]/BUCKET_NUM;
</span><span>        ListNode *head = buckets[index];
</span><span>        buciets[index] = </span><span style=color:#bf616a;>InsertBucket</span><span>(head, v[i]);
</span><span>    }
</span><span>    ListNode *head = buckets[</span><span style=color:#d08770;>0</span><span>];
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>1</span><span>; i < BUCKET_NUM; ++i)
</span><span>        head = </span><span style=color:#bf616a;>MergeBucket</span><span>(head, buckets[i]);
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>auto</span><span> i : v){
</span><span>        i = head -> </span><span style=color:#bf616a;>data</span><span>;
</span><span>        head = head -> </span><span style=color:#bf616a;>next</span><span>;
</span><span>    }
</span><span>}
</span></code></pre><h2 id=ji-shu-pai-xu-1>基数排序</h2><pre class=language-c++ data-lang=c++ style=background-color:#2b303b;color:#c0c5ce;><code class=language-c++ data-lang=c++><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>MaxBit</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>m</span><span>){	</span><span style=color:#65737e;>//计算最大元素的位数
</span><span>    </span><span style=color:#b48ead;>int</span><span> max_bit = </span><span style=color:#d08770;>1</span><span>;
</span><span>    </span><span style=color:#b48ead;>int</span><span> p  = </span><span style=color:#d08770;>10</span><span>;
</span><span>    </span><span style=color:#b48ead;>while</span><span>(m >= p){
</span><span>        m /= </span><span style=color:#d08770;>10</span><span>;
</span><span>        ++max_bit;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>return</span><span> max_bit;
</span><span>}
</span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>RadixSort</span><span>(vector<</span><span style=color:#b48ead;>int</span><span>> &</span><span style=color:#bf616a;>v</span><span>){
</span><span>    </span><span style=color:#b48ead;>int</span><span> max_bit = </span><span style=color:#bf616a;>MaxBit</span><span>(*</span><span style=color:#bf616a;>max_element</span><span>(v.</span><span style=color:#bf616a;>begin</span><span>(), v.</span><span style=color:#bf616a;>end</span><span>()));
</span><span>    </span><span style=color:#b48ead;>int</span><span> len = v.</span><span style=color:#bf616a;>size</span><span>();
</span><span>    vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>temp</span><span>(len, </span><span style=color:#d08770;>0</span><span>);	</span><span style=color:#65737e;>//存放每次按位排序后的结果
</span><span>    </span><span style=color:#b48ead;>int</span><span> radix = </span><span style=color:#d08770;>1</span><span>;				</span><span style=color:#65737e;>//从右向左数，第1位，按位排序
</span><span>    </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> i = </span><span style=color:#d08770;>1</span><span>; i <= max_bit; ++i){
</span><span>        vector<</span><span style=color:#b48ead;>int</span><span>> </span><span style=color:#bf616a;>count</span><span>(</span><span style=color:#d08770;>10</span><span>, </span><span style=color:#d08770;>0</span><span>);
</span><span>        
</span><span>        </span><span style=color:#65737e;>//类似计数排序，按位进行计数排序
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = </span><span style=color:#d08770;>0</span><span>; j < len; ++j){
</span><span>            ++count[(v[j]/radix) % </span><span style=color:#d08770;>10</span><span>];
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = </span><span style=color:#d08770;>1</span><span>; j < </span><span style=color:#d08770;>10</span><span>; ++j){
</span><span>            count[j] += count[j-</span><span style=color:#d08770;>1</span><span>];
</span><span>        }
</span><span>        </span><span style=color:#b48ead;>for</span><span>(</span><span style=color:#b48ead;>int</span><span> j = n-</span><span style=color:#d08770;>1</span><span>; j>=</span><span style=color:#d08770;>0</span><span>; --j){
</span><span>            temp[--count[(v[j]/radix) % </span><span style=color:#d08770;>10</span><span>]] = v[j];
</span><span>        }
</span><span>        v = tmp;
</span><span>        radix *= </span><span style=color:#d08770;>10</span><span>;	</span><span style=color:#65737e;>//对排序的位数进行更新
</span><span>    }
</span><span>}
</span></code></pre></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>