<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「工作日还有多少天，休息日还剩几小时」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-text">绪论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">树与二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-text">图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		数据结构概念罗列
	</div>
	
	<div class="page-date">
		2020-12-28
	</div>
	
	<div class="category-area">
		
			 
				「
				<div class="category">
					<a href="/categories/Data Structures">Data Structures</a>
				
				</div>
				」
			
		
	</div>
	
	<div class="content">
		<p>数据结构概念罗列</p>
<span id="more"></span>

<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>数据：信息的载体</p>
<p>数据元素：数据的基本单位</p>
<p>数据对象：数据的一个子集</p>
<p>数据类型：一个值的集合和定义在此集合上的一组操作的总称</p>
<ul>
<li>  原子类型：值不可再分</li>
<li>  结构类型：值可再分</li>
<li>  抽象数据类型：抽象数据组织及其相关操作</li>
</ul>
<p>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</p>
<ul>
<li>逻辑结构<ul>
<li>  线性结构</li>
<li>  非线性结构</li>
</ul>
</li>
<li>存储结构<ul>
<li>  顺序存储</li>
<li>  链式存储</li>
<li>  索引存储</li>
<li>  散列存储</li>
</ul>
</li>
<li>  数据的运算</li>
</ul>
<p>算法：对特定问题求解的一种描述</p>
<ul>
<li>  五个特性：有穷性、确定性、可行性、0个或多个输入、1个或多个输出</li>
<li>描述算法效率的度量<ul>
<li>  时间复杂度</li>
<li>空间复杂度<ul>
<li>  算法原地工作是指算法所需的辅助空间为常量，即O(1)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>存储结构：</p>
<ul>
<li>  顺序存储：顺序表</li>
<li>链式存储：<ul>
<li>  单链表</li>
<li>  双链表</li>
<li>  循环链表</li>
<li>  静态链表（数组实现）</li>
</ul>
</li>
</ul>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列：操作受限的线性表</p>
<p>栈：</p>
<ul>
<li>  顺序栈</li>
<li>  链栈</li>
<li>  共享栈</li>
</ul>
<p>队列：</p>
<ul>
<li>  循环队列</li>
<li>  链式队列</li>
<li>  双端队列</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>存储结构：</p>
<ul>
<li>  定长顺序存储（数组）</li>
<li>  堆分配存储（动态数组）</li>
<li>  块链存储</li>
</ul>
<p>模式匹配算法：</p>
<ul>
<li>  暴力匹配法：O(mn)</li>
<li>  KMP算法：通过部分匹配值避免重头匹配</li>
<li>  KMP算法进一步改进：改进next数组，递归创建next数组，避免$p_j = p_{next[j]}$</li>
</ul>
<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p>特点：</p>
<ul>
<li>  树的根结点没有前驱结点，除根节点以为的所有结点有且只有一个直接前驱</li>
<li>  树中所有结点可以有零个或多个后继</li>
</ul>
<p>结点的度：结点的孩子个数</p>
<p>分支结点：度大于0的结点</p>
<p>叶子结点：度为0的结点</p>
<p>结点的层次从根结点开始定义，根节点在第一层</p>
<p>结点的深度：从根结点自顶向下逐层累加</p>
<p>结点的高度：从叶结点开始自底向上累加</p>
<p>有序树：结点子树有次序，不可互换</p>
<p>无序树：结点子树无次序，可呼唤</p>
<p>路径：两个结点之间所经过的结点序列</p>
<p>路径长度：路径上所经过的边的个数</p>
<p>森林：M棵互不相交的树的集合</p>
<p>树最基本的性质：</p>
<ul>
<li>  结点数 = 所有结点的度数+1</li>
<li>  度为m的树中，第i层至多有$m^{i-1}（i\ge1）$个结点</li>
<li>  高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点</li>
<li>  具有n个结点的m叉树的最小高度为$\lceil log_m(n(m-1)+1)\rceil$</li>
</ul>
<p>二叉树：n个结点的有限集合</p>
<ul>
<li>  或者为空二叉树，n=0</li>
<li>  或者为根结点+左右子树（递归二叉树）</li>
</ul>
<p>特殊的二叉树：</p>
<ul>
<li>  满二叉树</li>
<li>  完全二叉树</li>
<li>  二叉排序树：左子树 &lt; 根结点 &lt; 右子树</li>
<li>  平衡二叉树：任一结点的左右子树深度之差不超过1</li>
</ul>
<p>二叉树的性质：</p>
<ul>
<li>  非空二叉树的叶子结点树等于度为2的结点数+1</li>
<li>  非空二叉树第k层至多有$2^{k-1}$个结点</li>
<li>  高度为h的二叉树至多有$2^h-1$个结点</li>
<li>从根结点开始，从1开始编号<ul>
<li>  当i &gt; 1 时，结点 i 的双亲编号为$\lfloor i/2 \rfloor$</li>
<li>  当 2i &lt;= n 时，左孩子存在，编号为 2i</li>
<li>  当 2i + 1 &lt;= n 时，右孩子存在，编号为 2i + 1</li>
</ul>
</li>
<li>  具有 n (n &gt; 0) 个结点的完全二叉树的高度为$\lceil log_2(n+1) \rceil$或$\lfloor log_2n \rfloor + 1$</li>
</ul>
<p>二叉树存储结构：</p>
<ul>
<li>  顺序存储结构</li>
<li>  链式存储结构</li>
</ul>
<p>三种常用的存储结构：</p>
<ul>
<li>  双亲表示法</li>
<li>  孩子表示法</li>
<li>  孩子兄弟表示法</li>
</ul>
<p>二叉树的遍历：根据根节点的访问顺序，递归</p>
<ul>
<li>  先序遍历</li>
<li>  中序遍历</li>
<li>  后序遍历</li>
<li>  层次遍历（借助辅助队列，FIFO）</li>
</ul>
<p>由二叉树的先序序列和中序序列可以唯一确定一棵二叉树</p>
<p>由二叉树的后序序列和中序序列可以唯一确定一棵二叉树</p>
<p>由二叉树的层序序列和中序序列可以唯一确定一棵二叉树</p>
<p>线索二叉树：二叉树的结点排列成一个线性序列</p>
<p>二叉树的线索化是将二叉链表中的空指针指向前驱或后继的线索，前驱和后继只有在遍历时才能得到，所以线索化实质是遍历一次二叉树。</p>
<p>树转换为二叉树规则：左孩子右兄弟</p>
<table>
<thead>
<tr>
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td>先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>后根遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody></table>
<p>二叉树的应用</p>
<ul>
<li>二叉排序树（BST）<ul>
<li>  查找：从根结点开始，二分查找</li>
<li>插入：<ul>
<li>  树空时直接插入</li>
<li>  非空时插入到查找失败时路径上的最后一个结点的左孩子或右孩子</li>
</ul>
</li>
<li>  构造：依次插入</li>
<li>删除：<ul>
<li>  叶子结点直接删除</li>
<li>  若删除的结点只有一个孩子，则直接替代</li>
<li>  有两个孩子，则用直接前驱或直接后继替代</li>
</ul>
</li>
<li>查找效率<ul>
<li>  平衡二叉树：$O(log_2n)$</li>
<li>  退化成链表：O(n)</li>
</ul>
</li>
</ul>
</li>
<li>平衡二叉树：避免树的高度增长过快，降低二叉排序树的性能<ul>
<li>插入：<ul>
<li>  LL平衡旋转（右单旋转）</li>
<li>  RR平衡旋转（左单旋转）</li>
<li>  LR平衡旋转（先左后右双旋转）</li>
<li>  RL平衡旋转（先右后左双旋转）</li>
</ul>
</li>
<li>  查找：$O(log_2n)$</li>
</ul>
</li>
<li>哈夫曼树：带权路径长度（WPL）最小的二叉树，最优二叉树<ul>
<li>构造过程<ul>
<li>  根据给定的 n 个权值，构造具有 n 棵扩充二叉树的森林</li>
<li>  在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值</li>
<li>  从森林中删除这两棵树，同时把新树加入到森林中</li>
<li>  重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树</li>
</ul>
</li>
<li>  哈夫曼编码是一种被广泛应用且非常有效的数据压缩编码</li>
</ul>
</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图G：顶点集V和边集E组成，G=(V, E)，顶点集一定非空</p>
<p>有向图：E是有向边（弧）的有限集合，弧是顶点的有序对，记为&lt;v,w&gt;</p>
<p>无向图：E是无向边（边）的有限集合，边是顶点的无序对，记为(v,w)</p>
<p>简单图：不存在重复边，不存在顶点到自身的边</p>
<p>多重图：两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联</p>
<p>（简单）完全图：任意两个顶点之间都存在边</p>
<ul>
<li>  有向：n(n-1)</li>
<li>  无向：n(n-1)/2</li>
</ul>
<p>子图：<strong>前提是图</strong>，顶点集和边集是子集。顶点集完全一样则为生成子图。</p>
<p>连通：无向图中，顶点v到顶点w有路径存在</p>
<p>连通图：无向图中，任意两个顶点都是连通的</p>
<p>连通分量：无向图中的极大连通子图</p>
<p>强连通：有向图中，从顶点v到w和从w到v之间都有路径</p>
<p>强连通图：有向图中，任意一对顶点都是强连通的</p>
<p>强连通分量：有向图中的极大强连通子图</p>
<p>连通图的生成树：包含图中全部顶点的一个极小连通子图，若顶点数为n，则边数为n-1</p>
<p>非连通图的生成森林：连通分量的生成树</p>
<p>顶点的度：TD(v)</p>
<p>顶点的入度：ID(v)</p>
<p>顶点的出度：OD(v)</p>
<p>TD(v) = ID(v) + OD(v)</p>
<p>带权图（网）：有权值的图</p>
<p>稠密图、稀疏图：|E| &lt; |V| log|V|时，为稀疏图，反之为稠密图</p>
<p>路径长度：路径上边的数目</p>
<p>回路（环）：若一个图有n个顶点，并且有大于 n-1 条边，则此图有环</p>
<p>简单路径：顶点不重复出现</p>
<p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</p>
<p>距离：顶点之间的最短路径的长度，不存在路径距离为无穷</p>
<p>有向树：一个顶点入度为0，其余顶点入度均为1的有向图</p>
<p>图的存储：</p>
<ul>
<li>  邻接矩阵法</li>
<li>  邻接表法</li>
<li>  十字链表法：有向图的一种链式存储结构，易求得入度和出度</li>
<li>  邻接多重表：无向图的一种链式存储结构，易得到顶点和边的各种信息，<strong>且易于判断两点之间是否存在边（邻接表的缺陷）</strong></li>
</ul>
<p>图的遍历：</p>
<ul>
<li>广度优先搜索（BFS），类似二叉树的层序遍历<ul>
<li>广度遍历中，可得到遍历树：广度优先生成树<ul>
<li>  图的邻接矩阵存储表示唯一，故广度优先生成树也唯一</li>
<li>  图的邻接表存储表示不唯一，故广度优先生成树不唯一</li>
</ul>
</li>
</ul>
</li>
<li>深度优先搜索（DFS）<ul>
<li>深度优先搜索<ul>
<li>  对连通图DFS会产生一棵深度优先生成树</li>
<li>  否则产生深度优先生成森林</li>
<li>  基于邻接表存储的深度优先生成树不唯一</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>图的应用：</p>
<ul>
<li><p>最小生成（代价）树</p>
<ul>
<li>性质<ul>
<li>  最小生成树（树形）不唯一</li>
<li>  最小生成树的边的权值总和唯一</li>
<li>  最小生成树的边数为定点数减一</li>
</ul>
</li>
<li>最小生成树算法（贪心策略）<ul>
<li>  Prim算法：$O(|V|^2)$，<strong>适合边稠密的图</strong></li>
<li>  Kruskal算法：$O(|E|log|E|)$，<strong>适合边稀疏而顶点较多的图</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>最短路径</p>
<ul>
<li>  最短路径算法依赖一种性质：两点之间的最短路径也包含了路径上的其他顶点间的最短路径</li>
<li>  Dijkstra（迪杰斯特拉）算法：<strong>单源最短路径</strong>，即求图中某一顶点到其他各顶点的最短路径，不适用于边上带有负权值，$O(|V|^2)$</li>
<li>Floyd（弗洛依德）算法：<strong>求每对顶点之间的最短路径</strong>，$O(|V|^3)$，代码紧凑且不包含复杂数据结构，因此隐含的常数系数很小<ul>
<li>  允许带负权值的边，但不允许有包含带负权值的边组成回路</li>
<li>  适用于带权无向图，可视为权值相同往返二重边的有向图</li>
<li>  每个顶点轮流运行一次Dijkstra算法，时间复杂度为$O(|V|^2)·|V|=O(|V|^3)$</li>
</ul>
</li>
</ul>
</li>
<li><p>  有向无环图：DAG图，描述含有公共子式的表达式的有效工具，代替二叉树可节省存储空间</p>
</li>
<li><p>拓扑排序：由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p>
<ol>
<li><p> 每个顶点出现且只出现一次</p>
</li>
<li><p> 若顶点A在序列中排在B的前面，则不存在从B到A的路径</p>
</li>
</ol>
</li>
<li><p>关键路径：AOE网中，从源点到汇点的所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，把<strong>关键路径</strong>上面的活动称为<strong>关键活动</strong>。</p>
<ul>
<li>  事件vk最早发生时间ve(k)</li>
<li>  事件vk最迟发生时间vl(k)</li>
<li>  活动ai最早开始时间e(i)</li>
<li>  活动ai最迟开始时间l(i)</li>
<li>  差额d(i) = l(i) - e(i)，差额为0的活动ai是关键活动</li>
<li>  <strong>选择题根据ve的计算过程即可知道关键路径</strong></li>
</ul>
</li>
</ul>
<p>AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边&lt;Vi, Vj&gt;表示活动Vi必须先于活动Vj进行的这样一种关系，则将这种有向图称为用顶点表示活动的网络，记为AOV网。每个AOV网都有一个或多个拓扑排序序列</p>
<p>AOE网：在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为用边表示活动的网络，简称AOE网。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>顺序查找：</p>
<ul>
<li>  $ASL_{成功} = \sum_{i=1}^nP_i(n-i+1)=\frac {n+1} 2$</li>
<li>  $ASL_{不成功} = n +1$</li>
<li>  有序顺序表查找判定树：$ASL_{不成功} = \frac{n}{2} + \frac{n+1}{n}$</li>
</ul>
<p>折半查找/二分查找：</p>
<ul>
<li>  $ASL = log_2(n+1)-1$</li>
<li>  $O(log_2n)$</li>
</ul>
<p>分块查找</p>
<ul>
<li>  块内和索引表均顺序查找：$ASL=L_i+L_S$</li>
<li>  索引表折半查找，块内顺序查找：$ASL=\lceil log_2(b+1)+\frac{s+1}{2}\rceil$</li>
</ul>
<p>B树（多路平衡查找树）：</p>
<ul>
<li>  插入：插入叶节点，溢出则分裂上移</li>
<li>删除：<ul>
<li>  非终端结点，使用前驱或后继替代</li>
<li>终端结点：<ul>
<li>  直接删除</li>
<li>  兄弟够借，父节点关键字取代删除结点，兄弟关键字结点上移</li>
<li>  兄弟不够借，父节点关键字和兄弟结点合并</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>B+树：操作与B树类似，但叶子结点包含信息，非叶结点仅起索引作用</p>
<p>散列表：建立了关键字和存储地址之间的一种之间映射关系，O(1)</p>
<ul>
<li>散列构造：<ul>
<li>  直接定址法</li>
<li>  除留余数法</li>
<li>  数字分析法</li>
<li>  平方取中法</li>
</ul>
</li>
<li>处理冲突的方法<ul>
<li>开放定址法<ul>
<li>  线性探测法</li>
<li>  平方探测法（二次探测法）</li>
<li>  再散列法</li>
</ul>
</li>
<li>  拉链法：同义词存储在线性链表</li>
</ul>
</li>
<li>查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子<ul>
<li>  装填因子，定义为一个表的装满程度，$\alpha=\frac{表中记录数n}{散列表长度m}$</li>
<li>  散列表的平均查找长度不直接依赖于n或m，装得越满，发生冲突的可能越大</li>
</ul>
</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>直接插入排序：</p>
<ul>
<li>  空间复杂度$O(1)$</li>
<li>  时间复杂度$O(n^2)$</li>
</ul>
<p>折半插入排序：折半查找插入位置，统一移动元素</p>
<p>希尔排序：</p>
<ul>
<li>  空间复杂度$O(1)$</li>
<li>  时间复杂度$O(n^2)$</li>
</ul>
<p>冒泡排序：</p>
<ul>
<li>  空间复杂度$O(1)$</li>
<li>  时间复杂度$O(n^2)$</li>
</ul>
<p>快速排序：</p>
<ul>
<li>  空间复杂度$O(log_2n)$</li>
<li>  时间复杂度$O(nlog_2n)$</li>
<li>  所有内部排序中平均性能最优的排序算法</li>
<li>  每趟排序后会将枢轴（基准）元素放到最终位置上</li>
</ul>
<p>简单选择排序：</p>
<ul>
<li>  空间复杂度$O(1)$</li>
<li>  时间复杂度$O(n^2)$</li>
</ul>
<p>堆排序：</p>
<ul>
<li>  空间复杂度$O(1)$</li>
<li>  时间复杂度$O(nlog_2n)$</li>
</ul>
<p>归并排序：</p>
<ul>
<li>  空间复杂度$O(n)$</li>
<li>  时间复杂度$O(nlog_2n)$</li>
</ul>
<p>基数排序</p>
<p>外部排序：</p>
<ul>
<li>  多路平衡归并和败者树</li>
<li>  置换-选择排序（生成初始归并段）</li>
<li>  最佳归并树</li>
</ul>

	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>