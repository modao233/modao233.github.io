<!DOCTYPE html>
<html>
<!-- html页面布局的head -->

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<title>
		modao
	</title>

	<!-- 百度统计代码 -->
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?902dc461fe0d25f09e74e0d04677b6d8";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'G-N2WTGJE0M5');
	</script>
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <!-- 文章详情页模板 -->

<!-- 主页标题栏 -->

<link rel="stylesheet" href="/css/navigatebar.css">


<header class="header">
	<div class="topbar">
		<div class="topbar-button topbar-mine">
			<a href="/">
				modao
			</a>
		</div>
		
			<div class="topbar-button">
				<a href="/">
					Home
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/categories">
					Categories
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/links">
					Friends
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/sites">
					Sites
				</a>
			</div>
		
			<div class="topbar-button">
				<a href="/stars">
					Stars
				</a>
			</div>
		

	</div>
	<div class="slogan">
		「生活可以更简单, 欢迎来到我的开源世界」
	</div>
</header>


<link rel="stylesheet" href="/css/font.css">


<link rel="stylesheet" href="/css/post.css" media="screen and (min-width: 600px)">


<link rel="stylesheet" href="/css/post_mobile.css" media="screen and (max-width: 600px)">


<link rel="stylesheet" href="/css/highlight.css">




<div class="toc">
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%92%8C%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">存储和检索数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%A6%82%E5%86%B5"><span class="toc-text">项目概况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reading-a-TOML-file"><span class="toc-text">Reading a TOML file</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Using-toml-dynamic"><span class="toc-text">Using toml_dynamic</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Using-toml-static"><span class="toc-text">Using toml_static</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reading-and-writing-a-JSON-file"><span class="toc-text">Reading and writing a JSON file</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-json-dynamic-project"><span class="toc-text">The json_dynamic project</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-json-static-project"><span class="toc-text">The json_static project</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reading-an-XML-file"><span class="toc-text">Reading an XML file</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">访问数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQLite%E5%88%B0%E6%AD%A4%E4%B8%80%E6%B8%B8"><span class="toc-text">SQLite到此一游</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PostgreSQL"><span class="toc-text">PostgreSQL</span></a></li></ol>
</div>

<div class="content-area">
	<div class="title">
		
	</div>
	
	<div class="page-date">
		2021-11-07
	</div>
	
	<div class="category-area">
		
			
		
	</div>
	
	<div class="content">
		<h1 id="存储和检索数据"><a href="#存储和检索数据" class="headerlink" title="存储和检索数据"></a>存储和检索数据</h1><p>任何软件应用程序的典型需求是通过读取/写入数据文件或数据流或通过查询/操作数据库来输入/输出数据。关于文件和流，非结构化数据甚至二进制数据很难操作，因此不建议使用。</p>
<p>另外，由于沟通过于繁琐，因此不建议使用专有数据格式，因此，仅应使用标准数据格式。幸运的是，在这些情况下可以免费使用Rust库。有Rust crate可用于处理一些最流行的文件格式，例如TOML，JSON和XML。</p>
<p>在数据库方面，Rust crate使用一些最受欢迎的数据库（例如SQLite，PostgreSQL和Redis）来操纵数据。(mysql太渣…)</p>
<h1 id="项目概况"><a href="#项目概况" class="headerlink" title="项目概况"></a>项目概况</h1><blockquote>
<p>我们将研究如何构建将JSON文件和XML文件加载到三个数据库的程序：SQLite数据库，PostgreSQL数据库和Redis键值存储。为了避免将文件的名称和位置以及数据库用户名密码硬连接到程序中，我们将从TOML配置文件中加载它们。</p>
</blockquote>
<p>最终的项目称为transformer</p>
<ul>
<li>toml_dynamic和toml_static：它们以两种不同的方式读取TOML文件。</li>
<li>json_dynamic和json_static：它们以两种不同的方式读取JSON文件。</li>
<li>xml_example：读取XML文件。</li>
<li>sqlite_example：这将在SQLite数据库中创建两个表，将记录插入其中，并对其进行查询。</li>
<li>postgresql_example：这将在PostgreSQL数据库中创建两个表，将记录插入其中，并对其进行查询。</li>
<li>redis_example：这会将一些数据添加到键值存储中并对其进行查询。</li>
</ul>
<h1 id="Reading-a-TOML-file"><a href="#Reading-a-TOML-file" class="headerlink" title="Reading a TOML file"></a>Reading a TOML file</h1><p>在文件系统中存储信息的一种简单且可维护的方法是使用文本文件。对于不超过100 KB的数据，这也非常有效。<br>存在几种标准，用于在文本文件中存储信息，例如INI，CSV，JSON，XML，YAML等。</p>
<p>cargo使用的是TOML。这是一种非常强大的格式，许多Rust开发人员都使用它来存储其应用程序的配置数据。它被设计为使用文本编辑器手动编写，但是也可以很容易地由工具编写。</p>
<p>toml_dynamic和toml_static项目（使用toml板条箱）从TOML文件加载数据。在配置软件应用程序时，读取TOML文件非常有用，这就是我们要做的。我们将使用data / config.toml文件，该文件包含本项目的所有参数。</p>
<p>你也可以使用代码创建或修改TOML文件，但是我们不会这样做。在某些情况下，例如保存用户首选项，能够修改TOML文件可能很有用。<br>重要的是要考虑到，当TOML文件被程序更改时，它会重组，这样会导致以下问题：</p>
<ul>
<li>解释成你可能不喜欢的特定格式</li>
<li>丢失内容</li>
<li>它的内容按字母顺序排序。</li>
</ul>
<p>因此，如果要同时将TOML格式用于手动编辑的参数和程序保存的数据，最好使用两个不同的文件：</p>
<ul>
<li>一种仅由人编辑</li>
<li>一种主要由软件编辑，但有时也由人编辑</li>
</ul>
<p>使用不同的技术读取TOML文件。这些技术将在两种不同情况下使用：</p>
<ul>
<li>在不确定文件中包含哪些字段的情况下，我们希望进行探索。在这种情况下，我们使用toml_dynamic程序。</li>
<li>在另一种情况下，在我们的程序中，我们准确描述了文件中应包含哪些字段，而我们不接受其他格式。在这种情况下，我们使用toml_static程序</li>
</ul>
<h1 id="Using-toml-dynamic"><a href="#Using-toml-dynamic" class="headerlink" title="Using toml_dynamic"></a>Using toml_dynamic</h1><p>本节的目的是在我们要探究该文件的内容时，读取位于数据文件夹中的config.toml文件。该文件的前三行如下：</p>
<p>   [input]<br>   xml_file = “../data/sales.xml”<br>   json_file = “../data/sales.json”</p>
<p>在这些行之后，文件包含其他部分。其中是[postgresql]部分，其中包含以下行：</p>
<p>   database = “Rust2018”</p>
<p>cargo run</p>
<p>   Original: Table(<br>       {<br>           “input”: Table(<br>               {<br>                   “json_file”: String(<br>                       “../data/sales.json”,<br>                   ),<br>                   “xml_file”: String(<br>                       “../data/sales.xml”,<br>                   ),<br>               },<br>           )</p>
<p>请注意，这只是config.toml文件的前三行的详细表示。此输出继续发出文件其余部分的类似表示。在打印了代表所读取文件的整个数据结构之后，将以下行添加到输出中：      </p>
<p>   [Postgresql].Database: Rust2018</p>
<p>这是在读取文件时对加载的数据结构进行特定查询的结果。</p>
<p>让我们看一下toml_dynamic程序的代码：</p>
<ul>
<li>1、声明一个变量，其中将包含整个文件的描述。此变量在接下来的三个语句中初始化：</li>
</ul>
<pre><code>let config_const_values =
</code></pre>
<ul>
<li>2、我们从命令行的第一个参数将文件的路径名添加到config_path中。然后，我们将该文件的内容加载到config_text字符串中，并将此字符串解析为toml::Value结构。这是一种递归结构，因为它可以在其字段之间具有Value属性：</li>
</ul>
<pre><code>&#123;
   let config_path = std::env::args().nth(1).unwrap();
   let config_text = std::fs::read_to_string(&amp;config_path).unwrap();
   config_text.parse::&lt;toml::Value&gt;().unwrap()
&#125;;
</code></pre>
<ul>
<li>3、然后使用调试结构化格式（：＃？）打印此结构，并从中检索一个值：</li>
</ul>
<pre><code>println!(&quot;Original: &#123;:#?&#125;&quot;, config_const_values);
println!(&quot;[Postgresql].Database: &#123;&#125;&quot;,
   config_const_values.get(&quot;postgresql&quot;).unwrap()
    .get(&quot;database&quot;).unwrap()
    .as_str().unwrap());
</code></pre>
<p>请注意，要获取包含“ postgresql”部分的“数据库”项的值，需要大量代码。 get函数需要寻找一个字符串，这可能会失败。那就是不确定性的代价</p>
<h1 id="Using-toml-static"><a href="#Using-toml-static" class="headerlink" title="Using toml_static"></a>Using toml_static</h1><p>另一方面，如果我们非常确定TOML文件的组织方式，则应使用项目中显示的另一种技术toml_static。</p>
<p>要运行它，请打开toml_static文件夹，然后输入cargo run ../data/config.toml。该程序将仅打印以下行：</p>
<p>   [postgresql].database: Rust2018</p>
<p>该项目使用了另外两个crates：</p>
<ul>
<li>serde: 这样就可以使用基本的序列化/反序列化操作。</li>
<li>serde_derive: 这提供了称为自定义源功能的强大附加功能，使你可以使用结构进行序列化/反序列化。</li>
</ul>
<p>serde是标准的序列化/反序列化库。序列化 Serialization 是将程序的数据结构转换为字符串（或流）的过程。反序列化是相反的过程。它是将字符串（或二进制流）转换为程序的某些数据结构的过程。</p>
<p>在代码中，首先，为data / config.toml文件中包含的任何节定义一个结构。该文件包含Input，Redis，Sqlite和Postgresql部分，因此我们声明的Rust结构与我们要读取的文件部分一样多。然后，定义Config结构以代表整个文件，并将这些部分作为成员。</p>
<p>例如，这是“输入”部分的结构：</p>
<p>   #[allow(unused)]<br>   #[derive(Deserialize)]<br>   struct Input {<br>       xml_file: String,<br>       json_file: String,<br>   }<br>请注意，前面的声明前面有两个属性。</p>
<p>allow（unused）属性用于防止编译器向我们警告以下结构中的未使用字段。对于我们来说，避免这些烦人的警告很方便。derive（Deserialize）属性用于为以下结构激活由serde启动的自动反序列化。</p>
<p>这些声明之后，可以编写以下代码行：</p>
<p>   toml::from_str(&amp;config_text).unwrap()<br>这将调用from_str函数，该函数将文件的文本解析为一个结构。该结构的类型未在此表达式中指定，但其值分配给了在主函数第一行中声明的变量：</p>
<p>   let config_const_values: Config =</p>
<p>因此，其类型为Config。<br>文件内容和结构类型之间的任何差异都将被视为此操作中的错误。因此，如果此操作成功，则该结构上的任何其他操作都不会失败。</p>
<p>尽管先前的程序（toml_dynamic）具有一种动态类型，例如Python或JavaScript，但是该程序具有一种静态类型，类似于Rust或C ++。</p>
<p>静态类型化的优点出现在最后一条语句中，通过简单地编写即可获得与上一个项目的长语句相同的行为。</p>
<p>   config_const_values.postgresql.database.</p>
<h1 id="Reading-and-writing-a-JSON-file"><a href="#Reading-and-writing-a-JSON-file" class="headerlink" title="Reading and writing a JSON file"></a>Reading and writing a JSON file</h1><p>对于存储比配置文件中存储的数据更复杂的数据，JSON格式更合适。这种格式非常流行，特别是在使用JavaScript语言的人群中。</p>
<p>我们将读取并解析data/sales.json文件。该文件包含一个匿名对象，该对象包含两个数组  </p>
<ul>
<li>products</li>
<li>sales</li>
</ul>
<p>“products”数组包含两个对象，每个对象都有三个字段：</p>
<p>   “products”: [<br>       {<br>           “id”: 591,<br>           “category”: “fruit”,<br>           “name”: “orange”<br>       },<br>       {<br>           “id”: 190,<br>           “category”: “furniture”,<br>           “name”: “chair”<br>       }<br>   ],</p>
<p>“sales” …    </p>
<p>数组中的信息是有关一些要出售的产品以及与这些产品相关的一些销售交易的信息。请注意，每个销售的第二个字段（”product_id”）是对产品的引用，因此应在创建相应的产品对象后进行处理。</p>
<p>我们将看到一对具有相同行为的程序。他们读取JSON文件，将第二个销售对象的数量增加1.5，然后将整个更新的结构保存到另一个JSON文件中。</p>
<p>与TOML格式的情况类似，对于JSON文件，也可以使用动态解析技术，其中，任何数据字段的存在和类型均由应用程序代码检查；而静态解析技术，则使用反序列化库进行检查。任何字段的存在和类型。</p>
<p>因此，我们有两个项目：json_dynamic和json_static。要运行每个文件夹，请打开其文件夹，然后输入cargo run ../data/sales.json ../data/sales2.json。该程序将不打印任何内容，但会读取命令行中指定的第一个文件并创建指定的第二个文件。</p>
<p>创建的文件与读取的文件类似，但具有以下区别：</p>
<ul>
<li>json_dynamic创建的文件的字段按字母顺序排序，而json_static创建的文件的字段按Rust数据结构中的顺序排序。</li>
<li>第二次销售的数量从2.14增加到3.64。</li>
<li>最后的空行在两个创建的文件中均被删除。</li>
</ul>
<h1 id="The-json-dynamic-project"><a href="#The-json-dynamic-project" class="headerlink" title="The json_dynamic project"></a>The json_dynamic project</h1><ul>
<li>1.该项目从命令行获取两个文件的路径名-修改后保存已加载的结构，以将现有的JSON文件（“input_path”）读入内存结构，并创建一个JSON文件（“ output_path”）以保存存储结构。</li>
<li>2.然后，将输入文件加载到名为sales_and_products_text的字符串中，并使用通用的serde_json::from_str::<Value>函数将字符串解析为表示JSON文件的动态类型的结构。此结构存储在sales_and_products局部变量中。</li>
</ul>
<p>假设我们要更改第二次销售交易的销售数量，将其增加1.5公斤：</p>
<ul>
<li><p>1、首先，我们必须使用以下表达式获得该值：</p>
<p> sales_and_products[“sales”][1][“quantity”]</p>
</li>
<li><p>2、这将检索常规对象的“sales”子对象。它是一个包含三个对象的数组。</p>
</li>
<li><p>3、然后，此表达式获取此数组的第二项（从zero([1])开始。这是代表单个销售交易的对象。</p>
</li>
<li><p>4、此后，它获得销售交易对象的“数量”子对象。</p>
</li>
<li><p>5、我们获得的值具有一个动态类型，我们认为该类型应该为serde_json::Value::Number，因此我们通过指定if let Value::Number(n)子句来与该类型进行模式匹配。</p>
</li>
<li><p>6、如果一切都很好，则匹配成功，并且我们将获得一个名为n的变量-包含数字，或者可以使用as_f64函数将其转换为Rust浮点数。最后，我们可以增加Rust编号，然后使用from_f64函数从中创建一个JSON编号。然后，我们可以使用与获取该对象相同的表达式将该对象分配给JSON结构：</p>
<p> sales_and_products[“sales”][1][“quantity”]</p>
<pre><code> = Value::Number(Number::from_f64(
     n.as_f64().unwrap() + 1.5).unwrap());
</code></pre>
</li>
<li><p>7、该程序的最后一条语句将JSON结构保存到文件中。在这里，使用了serde_json::to_string_pretty函数。顾名思义，此函数添加了格式空格（空白和换行符），以使生成的JSON文件更易于阅读。还有一个serde_json::to_string函数，它创建相同信息的更紧凑版本。人们阅读起来很困难，但是为计算机处理起来却要快一些：</p>
<p> std::fs::write(</p>
<pre><code> output_path,
 serde_json::to_string_pretty(&amp;sales_and_products).unwrap(),
</code></pre>
<p> ).unwrap();</p>
</li>
</ul>
<h1 id="The-json-static-project"><a href="#The-json-static-project" class="headerlink" title="The json_static project"></a>The json_static project</h1><p>如果对于我们的程序，我们确定我们知道JSON文件的结构，则可以并且应该使用静态类型化的技术来代替。它显示在json_static项目中。这里的情况类似于处理TOML文件的项目。</p>
<p>静态版本的源代码首先声明三个结构-对于要处理的JSON文件中包含的每种对象类型，一个结构。每个结构前面都有以下属性：</p>
<pre><code>   #[derive(Deserialize, Serialize, Debug)]
</code></pre>
<p>JSON字符串使用serde_json :: from_str :: <SalesAndProducts>函数进行解析。然后，增加售出橘子数量的代码变得非常简单：</p>
<p>   sales_and_products.sales[1].quantity += 1.5<br>该程序的其余部分保持不变</p>
<h1 id="Reading-an-XML-file"><a href="#Reading-an-XML-file" class="headerlink" title="Reading an XML file"></a>Reading an XML file</h1><p>另一种非常流行的文本格式是XML。不幸的是，没有稳定的序列化/反序列化库来管理XML格式。但是，这不一定是缺点。实际上，XML格式通常用于存储大型数据集。实际上，它是如此之大，以至于在我们开始将数据转换为内部格式之前，全部加载它们效率低下。在这些情况下，只要读取文件或传入流并对其进行处理，可能会更有效率。</p>
<p>xml_example项目是一个相当复杂的程序，它扫描命令行上指定的XML文件，并以程序方式将信息从文件加载到Rust数据结构中。它旨在读取../data/sales.xml文件。该文件的结构与我们在上一节中寻求的JSON文件相对应。以下几行显示了该文件的摘录：</p>
<p>所有XML文件的第一行都有一个标题，然后是一个根元素。在这种情况下，其根元素称为销售和产品。此元素包含两种元素：产品和销售。两种元素都有特定的子元素，它们是相应数据的字段。在此示例中，仅显示id字段。</p>
<p>要运行该项目，请打开其文件夹，然后输入cargo run ../data/sales.xml。一些行将被打印在控制台上。其中的前四个应如下所示：</p>
<p>   Got product.id: 862.<br>   Got product.category: fruit.<br>   Got product.name: cherry.<br>   Exit product: Product { id: 862, category: “fruit”, name: “cherry” }</p>
<p>这些描述了指定XML文件的内容。特别是，程序找到了ID 862的产品，然后检测到它是水果，然后是樱桃，然后在读取整个产品时，将打印代表该产品的整个结构。类似的输出将出现在销售中。</p>
<p>仅使用xml-rs crate执行分析。xml-rs启用了一种解析机制，如以下代码摘录所示：</p>
<p>   let file = std::fs::File::open(pathname).unwrap();<br>   let file = std::io::BufReader::new(file);<br>   let parser = EventReader::new(file);<br>   for event in parser {<br>       match &amp;location_item {<br>           LocationItem::Other =&gt; …<br>           LocationItem::InProduct =&gt; …<br>           LocationItem::InSale =&gt; …<br>       }<br>   }</p>
<p>EventReader类型的对象将扫描缓冲的文件，并在解析中执行任何步骤时都会生成一个事件。应用程序代码根据它们的需要处理这些事件。<br>使用了“事件”一词，但“transition”一词可能是对解析器提取的数据的更好描述。</p>
<p>复杂的语言很难解析，但是对于像我们的数据这样简单的语言，解析过程中的情况可以由状态机建模。为此，在源代码中声明了三个枚举变量：location_item，具有LocationItem类型； location_product，具有LocationProduct类型；和location_sale，以及LocationSale类型。</p>
<p>第一个通常指示解析的当前位置。我们可以在产品内部（InProduct），销售内部（InSale）或二者皆有（其他）。如果我们在产品内部，则LocationProduct枚举指示当前产品内部解析的当前位置。该字段可以在任何允许的字段内，也可以在所有字段之外。类似的状态发生在销售中。</p>
<p>迭代遇到几种事件。主要内容如下：</p>
<ul>
<li>XmlEvent :: StartElement：表示XML元素正在开始。它由开始元素的名称和该元素的可能属性修饰。</li>
<li>XmlEvent :: EndElement：表示XML元素即将结束。它由结尾元素的名称装饰。</li>
<li>XmlEvent :: Characters：表示元素的文本内容可用。它由该可用文本装饰。</li>
</ul>
<p>该程序使用Product类型声明一个可变的产品结构，并使用Sale类型声明一个可变的sale结构。它们使用默认值初始化。只要有一些可用字符，它们就会存储在当前结构的相应字段中。</p>
<p>例如，考虑一种情况，其中location_item的值是LocationItem :: InProduct，而location_product的值是LocationProduct :: InCategory，也就是说，我们属于产品类别。在这种情况下，可以有类别的名称或类别的结尾。为了获得类别的名称，代码包含匹配语句的这种模式：</p>
<pre><code>   Ok(XmlEvent::Characters(characters)) =&gt; &#123;
       product.category = characters.clone();
       println!(&quot;Got product.category: &#123;&#125;.&quot;, characters);
   &#125;
</code></pre>
<p>在此语句中，characters变量获取类别的名称，并将其副本分配给product.category字段。然后，该名称将打印到控制台。</p>
<h1 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h1><p>文本文件较小且不需要经常更改时，它们是很好的选择。实际上，可以更改文本文件的唯一方法是在文本末尾附加内容或完全重写它。如果要快速更改大型数据集中的信息，唯一的方法是使用数据库管理器。在本节中，我们将通过一个简单的示例来学习如何操作SQLite数据库。</p>
<p>但首先，让我们看一下三种流行的，广泛的数据库管理器类别：</p>
<ul>
<li><p>单文件数据库(单用户):</p>
<blockquote>
<p>这些将所有数据库存储在一个文件中，应用程序代码必须可以访问该文件。数据库代码已链接到应用程序（它可以是静态链接库或动态链接库）。一次仅允许一个用户访问它，并且所有用户都具有管理特权。要将数据库移动到任何地方，只需将文件移动。此类别中最受欢迎的选择是SQLite和Microsoft Access。</p>
</blockquote>
</li>
<li><p>DBMS（数据库管理系统）:</p>
<blockquote>
<p>数据库必须作为服务启动。多个客户端可以同时连接到它，并且它们也可以同时应用更改，而不会损坏任何数据。它需要更多的存储空间，更多的内存以及更多的启动时间（对于服务器）。在此类别中，有几种流行的选择，例如Oracle，Microsoft SQL Server，IBM DB2，MySQL和PostgreSQL。</p>
</blockquote>
</li>
<li><p>Key-value 数据库:</p>
</li>
</ul>
<p>这是一个必须作为服务启动的过程。多个客户端可以同时连接到它并同时应用更改。它本质上是一个大内存哈希映射，可以由其他进程查询，并且可以选择将其数据存储在文件中并在重新启动时重新加载。作为高性能网站的后端，它正在逐渐普及。 Redis是最受欢迎的选择之一。</p>
<p>在以下各节中，我们将向您展示如何访问SQLite单用户数据库（在sqlite_example项目中），PostgreSQL DBMSes（在postgreSQL_example项目中）和Redis键值存储（在redis_example项目中）。然后，在transformer项目中，将同时使用所有三种数据库。</p>
<h1 id="SQLite到此一游"><a href="#SQLite到此一游" class="headerlink" title="SQLite到此一游"></a>SQLite到此一游</h1><blockquote>
<p>该部分的源代码可在sqlite_example项目中找到。要运行它，请打开其文件夹，然后输入cargo run。</p>
</blockquote>
<p>任务：</p>
<p>这将在当前文件夹中创建sales.db文件。该文件包含一个SQLite数据库。然后，它将在此数据库中创建“Product”和“Sales”表，将在每个表中插入一行，并对数据库进行查询。该查询要求所有销售，并将每个销售与其关联的产品连接起来。对于每个提取的行，将在控制台上打印一行，显示销售的时间戳记，销售的权重以及关联产品的名称。</p>
<blockquote>
<p>该项目仅使用rusqlite crate: rusqlite =“ 0.23”</p>
</blockquote>
<p>项目：</p>
<p>让我们看看sqlite_example项目的代码如何工作。主要功能非常简单：</p>
<p>   fn main() -&gt; Result&lt;()&gt; {<br>       let conn = create_db()?;<br>       populate_db(&amp;conn)?;<br>       print_db(&amp;conn)?;<br>       Ok(())<br>   }</p>
<p>它调用create_db来打开或创建带有空表的数据库，并打开并返回与此数据库的连接。</p>
<ul>
<li><p>调用populate_db将行插入到该连接引用的数据库表中。</p>
</li>
<li><p>调用print_db在此数据库上执行查询，并打印该查询提取的数据</p>
<p> fn create_db() -&gt; Result<Connection> {</p>
<pre><code> let database_file = &quot;sales.db&quot;;
 let conn = Connection::open(database_file)?;
 let _ = conn.execute(&quot;DROP TABLE Sales&quot;, params![]);
 let _ = conn.execute(&quot;DROP TABLE Products&quot;, params![]);
 conn.execute(
     &quot;CREATE TABLE Products (
         id INTEGER PRIMARY KEY,
         category TEXT NOT NULL,
         name TEXT NOT NULL UNIQUE)&quot;,
     params![],
 )?;
 conn.execute(
     &quot;CREATE TABLE Sales (
         id TEXT PRIMARY KEY,
         product_id INTEGER NOT NULL REFERENCES Products,
         sale_date BIGINT NOT NULL,
         quantity DOUBLE PRECISION NOT NULL,
         unit TEXT NOT NULL)&quot;,
     params![],
 )?;
 Ok(conn)
</code></pre>
<p> }<br>Connection :: open函数仅使用SQLite数据库文件的路径来打开连接。如果此文件不存在，将创建它。如你所见，创建的sales.db文件很小。通常，空的DBMS数据库要大1000倍。</p>
</li>
</ul>
<p>为了执行数据操作命令，将调用连接的execute方法。它的第一个参数是一个SQL语句，可能包含一些参数，指定为$1，$2，$3等。函数的第二个自变量是对用于替换此类参数的值切片的引用。</p>
<p>当然，如果没有参数，则参数值列表必须为空。第一个参数值的索引为0，它将替换$1参数，第二个参数值将替换$2参数，依此类推。</p>
<p>请注意，参数化SQL语句的参数可以具有不同的数据类型（数字，字母数字，BLOB等），但是Rust集合只能包含相同数据类型的对象。因此，参数！宏用于执行一些魔术。 execute方法的第二个参数的数据类型必须是可以迭代的集合的数据类型，并且其项目实现ToSql特性。顾名思义，实现此特征的对象可用作SQL语句的参数。 rusqlite板条箱包含针对许多Rust基本类型（例如数字和字符串）的此特征的实现。</p>
<p>因此，例如，params!(34，”abc”）表达式生成了一个可以迭代的集合。该迭代的第一项可以转换为包含数字34的对象，并且该数字可用于替换数字类型的SQL参数。该迭代的第二项可以转换为包含“abc”字符串的对象，并且该字符串可用于替换字母数字类型的SQL参数。</p>
<p>现在，让我们看一下populate_db函数。它包含用于将行插入数据库的语句。这是其中之一：</p>
<p>   conn.execute(<br>       “INSERT INTO Products (<br>           id, category, name<br>           ) VALUES ($1, $2, $3)”,<br>       params![1, “fruit”, “pears”],<br>   )?;</p>
<p>如前所述，该语句将执行以下SQL语句：</p>
<p>   INSERT INTO Products (<br>       id, category, name<br>       ) VALUES (1, ‘fruit’, ‘pears’)<br>最后，我们看到了整个print_db函数，它比其他函数更复杂:</p>
<p>   fn print_db(conn: &amp;Connection) -&gt; Result&lt;()&gt; {<br>       let mut command = conn.prepare(<br>           “SELECT p.name, s.unit, s.quantity, s.sale_date<br>           FROM Sales s<br>           LEFT JOIN Products p<br>           ON p.id = s.product_id<br>           ORDER BY s.sale_date”,<br>       )?;<br>       for sale_with_product in command.query_map(params![], |row| {<br>           Ok(SaleWithProduct {<br>               category: “”.to_string(),<br>               name: row.get(0)?,<br>               quantity: row.get(2)?,<br>               unit: row.get(1)?,<br>               date: row.get(3)?,<br>           })<br>       })? {<br>           if let Ok(item) = sale_with_product {<br>               println!(<br>                   “At instant {}, {} {} of {} were sold.”,<br>                   item.date, item.quantity, item.unit, item.name<br>               );<br>           }<br>       }<br>       Ok(())<br>   }</p>
<p>要执行SQL查询，首先，必须通过调用连接的prepare方法准备SELECT SQL语句，以将其转换为具有Statement数据类型的有效内部格式。该对象被分配给命令变量。准备好的语句必须是可变的，以允许以下参数的替换。但是，在这种情况下，我们没有任何参数。</p>
<p>一个查询可以生成多行，并且我们希望一次处理一行，因此我们必须根据此命令创建一个迭代器。它是通过调用命令的query_map方法执行的。此方法接收两个参数-参数值的一部分和一个闭包-并返回一个迭代器。 query_map函数执行两项工作-首先，它替换指定的参数，然后使用闭包将提取的每一行映射（或转换）成更方便的结构。但是在本例中，我们没有要替换的参数，因此我们仅使用SaleWithProduct类型创建特定的结构。要从一行中提取字段，请使用get方法。它在SELECT查询中指定的字段上具有从零开始的索引。此结构是迭代器针对查询提取的任何行返回的对象，并将其分配给名为sale_with_product的迭代变量。</p>
<p>现在我们已经学习了如何访问SQLite数据库，让我们检查PostgreSQL数据库管理系统。</p>
<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><p>我们在SQLite数据库中所做的与在PostgreSQL数据库中所做的相似。这是因为它们都基于SQL语言，但是主要是因为SQLite的设计与PostgreSQL类似。将应用程序从PostgreSQL转换为SQLite可能比较困难，因为前者具有许多高级功能，而后者则不可用。</p>
<p>任务</p>
<p>该部分的源代码可以在postgresql_example文件夹中找到。要运行它，请打开其文件夹，然后输入cargo run。这将基本上执行与sqlite_example相同的操作</p>
<p>该项目仅使用名为postgres crate。</p>
<p>   创建数据库的语句<br>   sudo -u postgres psql<br>   ALTER USER postgres WITH PASSWORD ‘postgres’;</p>
<p>   CREATE DATABASE rust2018</p>
<p>创建到PostgreSQL数据库的连接与创建到SQLite数据库的连接非常不同。由于后者只是一个文件，因此您可以使用与打开文件类似的方式进行操作，并且应编写Connection :: open（&lt;db文件的路径名&gt;）。相反，要连接到PostgreSQL数据库，您需要访问运行服务器的计算机，然后访问该服务器正在侦听的TCP端口，然后需要在此服务器上指定您的凭据（您的用户名和密码）。（可选）然后，您可以指定要使用该服务器管理的数据库。</p>
<p>因此，呼叫的一般形式是Connection :: connect（<URL>，<TlsMode>），其中URL可以是例如postgres://postgres：post @ localhost：5432 / rust2018。 URL的一般格式为postgres：// username [：password] @host [：port] [/ database]，其中密码，端口和数据库部分是可选的。 TlsMode参数指定是否必须加密连接。</p>
<p>该端口是可选的，因为默认情况下其值为5432。另一个区别是该crate不使用参数！宏。相反，它允许我们指定对切片的引用。在这种情况下，它是一个空切片（＆[]），因为我们不需要指定参数。</p>
<p>在PostgreSQL中，连接类的查询方法执行参数替换，与执行方法类似，但是不会将行映射到结构。而是返回一个迭代器，该迭代器可立即在for语句中使用。然后，在循环体中，可以使用row变量（如示例中所示）填充结构。</p>
<p>现在我们知道如何访问SQLite和PostgreSQL数据库中的数据，让我们看看如何存储和检索Redis存储中的数据。</p>
<p>Redis 键值</p>
<p>对于某些类型的数据，某些应用程序需要非常快的响应时间。比DBMS提供的速度更快。通常，专用于一个用户的DBMS足够快，但是对于某些应用程序（通常是大型Web应用程序），存在数百个并发查询和许多并发更新。您可以使用许多台计算机，但是它们之间的数据必须保持一致，而保持一致可能会导致性能瓶颈。</p>
<p>解决此问题的方法是使用键值存储，这是一个非常简单的数据库，可以跨网络复制。这样可以将数据保留在内存中以最大化速度，但是它还支持将数据保存在文件中的选项。这样可以避免服务器停止时丢失信息。</p>
<p>键值存储类似于Rust标准库的HashMap集合，但是它由服务器进程管理，该服务器进程可能在另一台计算机上运行。查询是客户端和服务器之间交换的消息。 Redis是最常用的键值存储之一。</p>
<p>该项目的源代码位于redis_example文件夹中。要运行它，请打开文件夹并输入cargo run。</p>
<p>这只是在当前计算机上创建一个数据存储，并在其中存储以下三个键值对：</p>
<ul>
<li>“aKey”, 关联 “a string”</li>
<li>“anotherKey”, 关联 4567</li>
<li>45, 关联 12345</li>
</ul>
<p>然后，它向商店查询以下密钥：<br>   “aKey”, 获得“字符串”值<br>   “anotherKey”, 获得4567的值<br>   45, 获得12345的值<br>   40, error</p>
<p>此项目中仅使用redis crate。该代码非常简短。让我们看看它是如何工作的：</p>
<p>   fn main() -&gt; redis::RedisResult&lt;()&gt; {<br>   let client = redis::Client::open(“redis://localhost/“)?;<br>   let mut conn = client.get_connection()?;<br>首先，必须获得客户。对redis :: Client :: open的调用会收到一个URL，只是检查该URL是否有效。如果URL有效，则返回redis :: Client对象，该对象没有打开的连接。然后，客户端的get_connection方法尝试连接，如果成功，则返回打开的连接。</p>
<p>任何连接本质上都具有三种重要方法：</p>
<ul>
<li>set: 这将尝试存储一个键值对。</li>
<li>get: 这将尝试检索与指定键关联的值。</li>
<li>exists: 这将尝试检测指定的键是否存在于存储中，而不检索其关联值。</li>
</ul>
<p>然后，调用set三次，分别使用不同的键和值类型：</p>
<p>   conn.set(“aKey”, “a string”)?;<br>   conn.set(“anotherKey”, 4567)?;<br>   conn.set(45, 12345)?;</p>
<p>最后，get被调用四次，存在被调用一次。前三个调用获取存储的值。第四个调用指定了一个不存在的值，因此返回一个空值，该空值不能按要求转换为String，因此会产生错误：</p>
<p>   conn.get::&lt;_, String&gt;(“aKey”)?,<br>   conn.get::&lt;_, u64&gt;(“anotherKey”)?,<br>   conn.get::&lt;_, u16&gt;(45)?,<br>   conn.get::&lt;_, String&gt;(40),<br>   conn.exists::&lt;_, bool&gt;(40)?);</p>
<p>您始终可以检查该错误以查明您的密钥是否存在，但是更干净的解决方案是调用exist方法，该方法返回一个布尔值，用于指定密钥是否存在</p>

	</div>
</div>
<!-- 返回顶部模块 -->
<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;font-size:26px;background-color:#8590a6">
	<a title="返回顶部" style="color:#04fa9f"><⇧></a>
</div>
<script src="/js/totop.js"></script>

  </body>

</html>