<!DOCTYPE html>
<html lang="en">

<head>
    <title>Zola Terminimal theme</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://codecraft.top/style.css">
    <link rel="stylesheet" href="https://codecraft.top/color/pink.css">

        <link rel="stylesheet" href="https://codecraft.top/color/background_blue.css">
    
    <link rel="stylesheet" href="https://codecraft.top/font-hack-subset.css">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://codecraft.top" style="text-decoration: none;">
                    <div class="logo">
                            Terminimal theme
                        </div>
                </a>
            </div>
        </div>

        <nav class="menu">
            <ul class="menu__inner">
                
                <li class="active"><a href="https://codecraft.top">blog</a></li>
            
                <li><a href="https://codecraft.top/tags">tags</a></li>
            
                <li><a href="https://codecraft.top/archive">archive</a></li>
            
                <li><a href="https://codecraft.top/about">about me</a></li>
            </ul>
        </nav>
    
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://codecraft.top/网络编程-IO复用/wang-luo-bian-cheng-iofu-yong/">IO复用</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2021-01-26
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://codecraft.top/tags/c/">#C</a></span>
    

        
        <div class="post-content">
            <p>select、poll、epoll</p>
<span id="continue-reading"></span><h2 id="i-omo-xing">I/O模型</h2>
<p>Unix下可用的I/O模型有五种：</p>
<ul>
<li>阻塞式I/O</li>
<li>非阻塞式I/O</li>
<li>I/O复用（select和poll、epoll）</li>
<li>信号驱动式I/O（SIGIO）</li>
<li>异步I/O（POSIX的aio_系列函数）</li>
</ul>
<blockquote>
<p>详见Unix网络编程卷一第六章</p>
</blockquote>
<p>select()和poll()在Unix系统中存在时间长，主要优势在于可移植性，主要缺点在于当同时检查大量的文件描述符时性能拓展性不佳。</p>
<p>epoll API的关键优势在于能让应用高效地检查大量的文件描述符，主要缺点是专属于Linux系统的API。</p>
  <img src="image-20210125175611142.png" class="left" />
<p><img src="https://codecraft.top/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%8D%E7%94%A8/wang-luo-bian-cheng-iofu-yong/image-20210125175611142.png" alt="image-20210125175611142" /></p>
<h2 id="i-ofu-yong-select">I/O复用-select</h2>
<p>select()首次出现在BSD系统的套接字API中。</p>
<p>select()系统调用的用途：在一段指定的时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。</p>
<p>系统调用select()会一直阻塞，直到一个或多个文件描述符集合成为就绪态。</p>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/select.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/time.h</span><span style="color:#556633;">&gt;

</span><span style="color:#888888;">//若有就绪描述符则返回其数目，若超时则返回0，若出错则返回-1
</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">select</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">maxfdp1</span><span style="color:#e8e8d3;">, fd_set *</span><span style="color:#ffb964;">readset</span><span style="color:#e8e8d3;">, fd_set *</span><span style="color:#ffb964;">writeset</span><span style="color:#e8e8d3;">, 
           fd_set *</span><span style="color:#ffb964;">exceptset</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">const struct</span><span style="color:#e8e8d3;"> timeval *</span><span style="color:#ffb964;">timeout</span><span style="color:#e8e8d3;">);
</span></code></pre>
<p><strong>探究下fd_set的结构</strong></p>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#888888;">/*typesizes.h*/
</span><span style="color:#8fbfdc;">#define </span><span style="color:#ffb964;">__FD_SETSIZE		</span><span style="color:#cf6a4c;">1024

</span><span style="color:#888888;">/*select.h*/
</span><span style="color:#8fbfdc;">typedef long int </span><span style="color:#ffb964;">__fd_mask</span><span style="color:#e8e8d3;">;

</span><span style="color:#888888;">//long int类型共有多少bits
</span><span style="color:#8fbfdc;">#define </span><span style="color:#ffb964;">__NFDBITS	</span><span style="color:#e8e8d3;">(</span><span style="color:#cf6a4c;">8 </span><span style="color:#e8e8d3;">* (</span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;">) sizeof (__fd_mask))

typedef </span><span style="color:#8fbfdc;">struct
</span><span style="color:#e8e8d3;">{
    </span><span style="color:#888888;">//long int型数组，数组大小 = 描述符最大数 / long int的位数
    //数组大小为 __FD_SETSIZE bits
</span><span style="color:#e8e8d3;">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
} fd_set;
</span></code></pre>
<p><strong>select()程序示例：</strong></p>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/types.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/socket.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">netinet/in.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">arpa/inet.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">assert.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdio.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">unistd.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">errno.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">string.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">fcntl.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdlib.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdarg.h</span><span style="color:#556633;">&gt;

</span><span style="color:#8fbfdc;">static void </span><span style="color:#fad07a;">usageError</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">const char</span><span style="color:#e8e8d3;">* </span><span style="color:#ffb964;">progName</span><span style="color:#e8e8d3;">){
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Usage: </span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;"> {timeout | -} fd-num[rw]...\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, progName);
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    - means infinite timeout; \n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    r = monitor for read\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    w = monitor for wirite\n\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    e.g.: </span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;"> - 0rw 1w\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, progName);
    exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
}
</span><span style="color:#8fbfdc;">void </span><span style="color:#fad07a;">cmdLineErr</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">const char </span><span style="color:#e8e8d3;">*</span><span style="color:#ffb964;">format</span><span style="color:#e8e8d3;">, ...)
{
    va_list argList;

    fflush(stdout);           </span><span style="color:#888888;">/* Flush any pending stdout */

    </span><span style="color:#e8e8d3;">fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Command-line usage error: </span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
    va_start(argList, format);
    vfprintf(stderr, format, argList);
    va_end(argList);

    fflush(stderr);           </span><span style="color:#888888;">/* In case stderr is not line-buffered */
    </span><span style="color:#e8e8d3;">exit(EXIT_FAILURE);
}

</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">main</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">argc</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">char</span><span style="color:#e8e8d3;">* </span><span style="color:#ffb964;">argv</span><span style="color:#e8e8d3;">[]){
    fd_set readfds, writefds;
    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;"> ready, nfds, fd, numRead, j;
    </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> timeval timeout;
    </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> timeval *pto;
    </span><span style="color:#8fbfdc;">char</span><span style="color:#e8e8d3;"> buf[</span><span style="color:#cf6a4c;">10</span><span style="color:#e8e8d3;">];

    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(argc &lt; </span><span style="color:#cf6a4c;">2 </span><span style="color:#e8e8d3;">|| strcmp(argv[</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">], </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">--help</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">) == </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
        </span><span style="color:#ffb964;">usageError</span><span style="color:#e8e8d3;">(argv[</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">]);
    }

    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(strcmp(argv[</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">], </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">-</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">) == </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
        pto = NULL;
    }
    </span><span style="color:#8fbfdc;">else</span><span style="color:#e8e8d3;">{
        pto = &amp;timeout;
        timeout.</span><span style="color:#ffb964;">tv_sec </span><span style="color:#e8e8d3;">= strtol(argv[</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">], NULL, </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">);
        timeout.</span><span style="color:#ffb964;">tv_usec </span><span style="color:#e8e8d3;">= </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">;
    }

    nfds = </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">;
    </span><span style="color:#ffb964;">FD_ZERO</span><span style="color:#e8e8d3;">(&amp;readfds);
    </span><span style="color:#ffb964;">FD_ZERO</span><span style="color:#e8e8d3;">(&amp;writefds);

    </span><span style="color:#8fbfdc;">for</span><span style="color:#e8e8d3;">(j = </span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">; j &lt; argc; j++){
        numRead = sscanf(argv[j], </span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">%d%2[rw]</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, &amp;fd, buf);
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(numRead != </span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">){
            </span><span style="color:#ffb964;">usageError</span><span style="color:#e8e8d3;">(argv[</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">]);
        }
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(fd &gt;= FD_SETSIZE){
            </span><span style="color:#ffb964;">cmdLineErr</span><span style="color:#e8e8d3;">(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">file descriptor exceeds limit (</span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">)\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, FD_SETSIZE);
        }
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(fd &gt;= nfds){
            nfds = fd + </span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">;
        }
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(strchr(buf, </span><span style="color:#556633;">&#39;</span><span style="color:#99ad6a;">r</span><span style="color:#556633;">&#39;</span><span style="color:#e8e8d3;">) != NULL){
            </span><span style="color:#ffb964;">FD_SET</span><span style="color:#e8e8d3;">(fd, &amp;readfds);
        }
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(strchr(buf, </span><span style="color:#556633;">&#39;</span><span style="color:#99ad6a;">w</span><span style="color:#556633;">&#39;</span><span style="color:#e8e8d3;">) != NULL){
            </span><span style="color:#ffb964;">FD_SET</span><span style="color:#e8e8d3;">(fd, &amp;writefds);
        }
    }
    ready = </span><span style="color:#ffb964;">select</span><span style="color:#e8e8d3;">(nfds, &amp;readfds, &amp;writefds, NULL, pto);
    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(ready == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">errExit(select)</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
        exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    }
    printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">ready = </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, ready);
    </span><span style="color:#8fbfdc;">for</span><span style="color:#e8e8d3;">(fd = </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">; fd &lt; nfds; fd++){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">: </span><span style="color:#7697d6;">%s%s</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">,fd, </span><span style="color:#ffb964;">FD_ISSET</span><span style="color:#e8e8d3;">(fd, &amp;readfds) ? </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">r</span><span style="color:#556633;">&quot; </span><span style="color:#e8e8d3;">: </span><span style="color:#556633;">&quot;&quot;</span><span style="color:#e8e8d3;">, 
        </span><span style="color:#ffb964;">FD_ISSET</span><span style="color:#e8e8d3;">(fd, &amp;writefds) ? </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">w</span><span style="color:#556633;">&quot; </span><span style="color:#e8e8d3;">: </span><span style="color:#556633;">&quot;&quot;</span><span style="color:#e8e8d3;">);
    }
    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(pto != NULL){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">timeout after select(): </span><span style="color:#7697d6;">%ld</span><span style="color:#99ad6a;">.</span><span style="color:#7697d6;">%03ld</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">,
               (</span><span style="color:#8fbfdc;">long</span><span style="color:#e8e8d3;">) timeout.</span><span style="color:#ffb964;">tv_sec</span><span style="color:#e8e8d3;">, (</span><span style="color:#8fbfdc;">long</span><span style="color:#e8e8d3;">) timeout.</span><span style="color:#ffb964;">tv_usec </span><span style="color:#e8e8d3;">/ </span><span style="color:#cf6a4c;">1000</span><span style="color:#e8e8d3;">);
    }
    exit(</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">);
}
</span></code></pre>
<p><strong>select处理正常数据和带外数据：</strong></p>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/types.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/socket.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">netinet/in.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">arpa/inet.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">assert.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdio.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">unistd.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">errno.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">string.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">fcntl.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdlib.h</span><span style="color:#556633;">&gt;

</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">main</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">argc</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">char</span><span style="color:#e8e8d3;">* </span><span style="color:#ffb964;">argv</span><span style="color:#e8e8d3;">[]){
    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(argc &lt;= </span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">usage: </span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;"> ip_adress port_number\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, </span><span style="color:#ffb964;">basename</span><span style="color:#e8e8d3;">(argv[</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">]));
        </span><span style="color:#8fbfdc;">return </span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">;
    }
    </span><span style="color:#8fbfdc;">const char</span><span style="color:#e8e8d3;">* ip = argv[</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">];
    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;"> port = atoi(argv[</span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">]);

    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;"> ret = </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">;
    </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> sockaddr_in address;
    </span><span style="color:#ffb964;">bzero</span><span style="color:#e8e8d3;">(&amp;address, sizeof(address));
    address.</span><span style="color:#ffb964;">sin_family </span><span style="color:#e8e8d3;">= AF_INET;
    </span><span style="color:#ffb964;">inet_pton</span><span style="color:#e8e8d3;">(AF_INET, ip, &amp;address.</span><span style="color:#ffb964;">sin_addr</span><span style="color:#e8e8d3;">);
    address.</span><span style="color:#ffb964;">sin_port </span><span style="color:#e8e8d3;">= </span><span style="color:#ffb964;">htons</span><span style="color:#e8e8d3;">(port);

    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;"> listenfd = </span><span style="color:#ffb964;">socket</span><span style="color:#e8e8d3;">(PF_INET, SOCK_STREAM, </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">);
    assert(listenfd &gt;= </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">);
    ret = </span><span style="color:#ffb964;">bind</span><span style="color:#e8e8d3;">(listenfd, (</span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> sockaddr*)&amp;address, sizeof(address));
    assert(ret != -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    ret = </span><span style="color:#ffb964;">listen</span><span style="color:#e8e8d3;">(listenfd, </span><span style="color:#cf6a4c;">5</span><span style="color:#e8e8d3;">);
    assert(ret != -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);

    </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> sockaddr_in client_address;
    socklen_t client_addrlength = sizeof(client_address);
    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;"> connfd = </span><span style="color:#ffb964;">accept</span><span style="color:#e8e8d3;">(listenfd, (</span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> sockaddr*)&amp;client_address, &amp;client_addrlength);
    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(connfd &lt; </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error is: </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, errno);
        </span><span style="color:#ffb964;">close</span><span style="color:#e8e8d3;">(listenfd);
    }

    </span><span style="color:#8fbfdc;">char</span><span style="color:#e8e8d3;"> buf[</span><span style="color:#cf6a4c;">1024</span><span style="color:#e8e8d3;">];
    fd_set read_fds;
    fd_set exception_fds;
    </span><span style="color:#ffb964;">FD_ZERO</span><span style="color:#e8e8d3;">(&amp;read_fds);
    </span><span style="color:#ffb964;">FD_ZERO</span><span style="color:#e8e8d3;">(&amp;exception_fds);

    </span><span style="color:#8fbfdc;">while</span><span style="color:#e8e8d3;">(true){
        memset(buf, </span><span style="color:#556633;">&#39;</span><span style="color:#99ad6a;">\0</span><span style="color:#556633;">&#39;</span><span style="color:#e8e8d3;">, sizeof(buf));
        </span><span style="color:#ffb964;">FD_SET</span><span style="color:#e8e8d3;">(connfd, &amp;read_fds);
        </span><span style="color:#ffb964;">FD_SET</span><span style="color:#e8e8d3;">(connfd, &amp;exception_fds);
        ret = </span><span style="color:#ffb964;">select</span><span style="color:#e8e8d3;">(connfd + </span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">, &amp;read_fds, NULL, &amp;exception_fds, NULL);
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(ret &lt; </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">selection failure\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
            </span><span style="color:#8fbfdc;">break</span><span style="color:#e8e8d3;">;
        }
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(</span><span style="color:#ffb964;">FD_ISSET</span><span style="color:#e8e8d3;">(connfd, &amp;read_fds)){
            ret = </span><span style="color:#ffb964;">recv</span><span style="color:#e8e8d3;">(connfd, buf, sizeof(buf)-</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">, </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">);
            </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(ret &lt;= </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
                </span><span style="color:#8fbfdc;">break</span><span style="color:#e8e8d3;">;
            }
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">get </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;"> bytes of normal data: </span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, ret, buf);
        }
        </span><span style="color:#8fbfdc;">else if</span><span style="color:#e8e8d3;">(</span><span style="color:#ffb964;">FD_ISSET</span><span style="color:#e8e8d3;">(connfd, &amp;exception_fds)){
            ret = </span><span style="color:#ffb964;">recv</span><span style="color:#e8e8d3;">(connfd, buf, sizeof(buf)-</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">, MSG_OOB);
            </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(ret &lt;= </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
                </span><span style="color:#8fbfdc;">break</span><span style="color:#e8e8d3;">;
            }
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">get </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;"> bytes of oob data: </span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, ret, buf);
        }
    }
    </span><span style="color:#ffb964;">close</span><span style="color:#e8e8d3;">(connfd);
    </span><span style="color:#ffb964;">close</span><span style="color:#e8e8d3;">(listenfd);
    </span><span style="color:#8fbfdc;">return </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">;
}
</span></code></pre><h2 id="i-ofu-yong-poll">I/O复用-poll</h2>
<p>poll函数起源于SVR3，最初局限于流设备，SVR4取消了这种限制，允许poll工作在任何描述符上。</p>
<p>poll提供的功能与select类似，不过在处理流设备时，它能够提供额外的信息。</p>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">poll.h</span><span style="color:#556633;">&gt;

</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">pollfd</span><span style="color:#e8e8d3;">{
    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;">		fd;
    </span><span style="color:#8fbfdc;">short</span><span style="color:#e8e8d3;">	events;	</span><span style="color:#888888;">//指定要测试的条件
    </span><span style="color:#8fbfdc;">short</span><span style="color:#e8e8d3;">	revents;</span><span style="color:#888888;">//返回描述符的状态
</span><span style="color:#e8e8d3;">}
</span><span style="color:#888888;">//若有就绪描述符返回其数目，超时返回0，出错返回-1
</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">poll</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> pollfd *</span><span style="color:#ffb964;">fdarray</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">unsigned long </span><span style="color:#ffb964;">nfds</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">timeout</span><span style="color:#e8e8d3;">);
</span></code></pre>
<blockquote>
<p>select()同poll()返回正整数的区别：如果一个文件描述符在返回的集合中出现了不止一次，系统调用select()会将同一个文件描述符计数多次。而系统调用poll()返回的是就绪态文件描述符个数，且一个文件描述符只会统计一次，就算在相应的revents字段中设定了多个位掩码也是如此。</p>
</blockquote>
<p><strong>poll示例程序：</strong></p>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">time.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">poll.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/types.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/socket.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">netinet/in.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">arpa/inet.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">assert.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdio.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">unistd.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">errno.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">string.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">fcntl.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdlib.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdarg.h</span><span style="color:#556633;">&gt;

</span><span style="color:#8fbfdc;">static void </span><span style="color:#fad07a;">usageError</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">const char</span><span style="color:#e8e8d3;">* </span><span style="color:#ffb964;">progName</span><span style="color:#e8e8d3;">){
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Usage: </span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;"> {timeout | -} fd-num[rw]...\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, progName);
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    - means infinite timeout; \n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    r = monitor for read\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    w = monitor for wirite\n\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
    fprintf(stderr, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    e.g.: </span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;"> - 0rw 1w\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, progName);
    exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
}

</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">main</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">argc</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">char</span><span style="color:#e8e8d3;">* </span><span style="color:#ffb964;">argv</span><span style="color:#e8e8d3;">[]){
    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;"> numPipes, j, ready, randPipe, numWrites;
    </span><span style="color:#8fbfdc;">int </span><span style="color:#e8e8d3;">(*pfds)[</span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">];</span><span style="color:#888888;">//指向数组的指针
    </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> pollfd *pollFd;

    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(argc &lt; </span><span style="color:#cf6a4c;">2 </span><span style="color:#e8e8d3;">|| strcmp(argv[</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">], </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">--help</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">) == </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;"> num-pipes [num-writes]\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, argv[</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">]);
        exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    }

    numPipes = strtol(argv[</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">], NULL, </span><span style="color:#cf6a4c;">10</span><span style="color:#e8e8d3;">);

    pfds = (</span><span style="color:#8fbfdc;">int </span><span style="color:#e8e8d3;">(*)[</span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">])calloc(numPipes, sizeof(</span><span style="color:#8fbfdc;">int </span><span style="color:#e8e8d3;">[</span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">]));
    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(pfds == NULL){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error malloc</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
        exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    }
    pollFd = (pollfd*)calloc(numPipes, sizeof(</span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> pollfd));
    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(pollFd == NULL){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error malloc</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
        exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    }

    </span><span style="color:#8fbfdc;">for</span><span style="color:#e8e8d3;">(j = </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">; j &lt; numPipes; j++){
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(</span><span style="color:#ffb964;">pipe</span><span style="color:#e8e8d3;">(pfds[j]) == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error pipe </span><span style="color:#7697d6;">%d</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, j);
            exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
        }
    }

    numWrites = (argc &gt; </span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">) ? strtol(argv[</span><span style="color:#cf6a4c;">2</span><span style="color:#e8e8d3;">], NULL, </span><span style="color:#cf6a4c;">10</span><span style="color:#e8e8d3;">) : </span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">;
    </span><span style="color:#ffb964;">srandom</span><span style="color:#e8e8d3;">((</span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;">)time(NULL));
    </span><span style="color:#8fbfdc;">for</span><span style="color:#e8e8d3;">(j = </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">; j &lt; numWrites; j++){
        randPipe = </span><span style="color:#ffb964;">random</span><span style="color:#e8e8d3;">() % numPipes;
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Writing to fd: </span><span style="color:#7697d6;">%3d</span><span style="color:#99ad6a;"> (read fd: </span><span style="color:#7697d6;">%3d</span><span style="color:#99ad6a;">)\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">,
                pfds[randPipe][</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">], pfds[randPipe][</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">]);
        </span><span style="color:#8fbfdc;">if </span><span style="color:#e8e8d3;">(</span><span style="color:#ffb964;">write</span><span style="color:#e8e8d3;">(pfds[randPipe][</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">], </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">a</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, </span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">) == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">write </span><span style="color:#7697d6;">%d</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, pfds[randPipe][</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">]);
            exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
        }
    }

    </span><span style="color:#8fbfdc;">for</span><span style="color:#e8e8d3;">(j = </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">; j &lt; numPipes; j++){
        pollFd[j].</span><span style="color:#ffb964;">fd </span><span style="color:#e8e8d3;">= pfds[j][</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">];
        pollFd[j].</span><span style="color:#ffb964;">events </span><span style="color:#e8e8d3;">= POLLIN;
    }

    ready = </span><span style="color:#ffb964;">poll</span><span style="color:#e8e8d3;">(pollFd, numPipes, -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(ready == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">poll error</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
        exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    }

    printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">poll() returned: </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, ready);

    </span><span style="color:#8fbfdc;">for</span><span style="color:#e8e8d3;">(j = </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">; j &lt; numPipes; j++){
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(pollFd[j].</span><span style="color:#ffb964;">revents </span><span style="color:#e8e8d3;">&amp; POLLIN){
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Readable: </span><span style="color:#7697d6;">%d %3d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, j, pollFd[j].</span><span style="color:#ffb964;">fd</span><span style="color:#e8e8d3;">);
        }
    }
    </span><span style="color:#8fbfdc;">return </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">;
}
</span></code></pre><h2 id="i-ofu-yong-epoll">I/O复用-epoll</h2>
<p>epoll API由三组系统调用组成;</p>
<ul>
<li><code>epoll_create()</code>创建一个epoll实例</li>
<li><code>epoll_ctl()</code>操作同epoll实例相关联的兴趣列表</li>
<li><code>epoll_wait()</code>返回与epoll相关联的就绪列表中的成员</li>
</ul>
<p>epoll实例：epoll API的核心数据结构，和一个打开的文件描述符相关联。这个文件描述符不用来做IO操作，相反它是内核数据结构的句柄，这些内核数据结构实现了两个目的：</p>
<ul>
<li>记录兴趣列表</li>
<li>维护就绪列表</li>
</ul>
<h3 id="epoll-create">epoll_create</h3>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/epoll.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">epoll_create</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">size</span><span style="color:#e8e8d3;">);
</span></code></pre>
<p>参数size指定我们想要通过epoll实例来检查的描述符个数，不是上限，只是告知内核应该如何为内部数据结构划分初始大小。</p>
<p>函数返回epoll实例的文件描述符，该文件描述符不需要时需要close()。</p>
<p>当所有与epoll实例相关的文件描述符都被关闭时，实例被销毁，相关资源释放。（多个文件描述符可能引用到相同的epoll实例，这是由于调用了fork()或dup()这样的类似函数所致）。</p>
<blockquote>
<p>linux2.6.8版以来，size参数被忽略不用。</p>
<p>linux2.6.27以来，Linux支持一个新的系统调用epoll_create1()：</p>
<ul>
<li>去掉了无用的参数size</li>
<li>增加了一个可用来修改系统调用行为的flags参数
<ul>
<li>flag目前只支持一个标志：EPOLL_CLOEXEC，使内核在新的文件描述符上启动了执行即关闭（close-on-exec）标志（FD_CLOEXEC)</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="epoll-ctl">epoll_ctl</h3>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/epoll.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">epoll_ctl</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">epfd</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">op</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">fd</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> epoll *</span><span style="color:#ffb964;">ev</span><span style="color:#e8e8d3;">);
</span></code></pre>
<p>成功返回0，失败返回-1并设置errno。</p>
<p>参数fd：指明修改兴趣列表中哪一个文件描述符的设定</p>
<p>参数op：指定需要执行的操作</p>
<ul>
<li>EPOLL_CTL_ADD：添加</li>
<li>EPOLL_CTL_MOD：修改</li>
<li>EPOLL_CTL_DEL：删除</li>
</ul>
<p>参数ev：</p>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">epoll_event</span><span style="color:#e8e8d3;">{
    uint32_t	 events;</span><span style="color:#888888;">//epoll事件，位掩码
</span><span style="color:#e8e8d3;">    epoll_data_t data;	</span><span style="color:#888888;">//用户数据 
</span><span style="color:#e8e8d3;">}
</span></code></pre><pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">typedef union</span><span style="color:#e8e8d3;"> epoll_data{
    </span><span style="color:#8fbfdc;">void		</span><span style="color:#e8e8d3;">*ptr;
    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;">			fd;
    uint32_t	u32;
    uint64_t	u64;
}</span><span style="color:#ffb964;">epoll_data_t</span><span style="color:#e8e8d3;">;
</span></code></pre>
<ul>
<li>结构体epoll_event在的events字段是一个位掩码，指定待检查的描述符fd上感兴趣的事件集合</li>
<li>data字段是一个联合体，当描述符fd成为就绪态时，联合体的成员可用来指定传回给调用进程的信息
<ul>
<li>联合体成员不能一起使用，常用fd</li>
<li>想要将文件描述符和用户数据关联起来，以实现快速的数据访问，只能使用其它手段，比如放弃使用fd，而在ptr指向的用户数据中包含fd</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>max_user_watches上限</strong></p>
<p>每个注册到epoll实例上的文件描述符需要占用一小段不能被交换的内核内存空间，因此内核提供了一个接口用来定义每个用户可以注册到epoll实例上的文件描述符总数。</p>
<p>这个上限值可以通过max_user_watches来查看和修改，max_user_watches是专属于Linux系统的/proc/sys/fd/epoll目录下的一个文件。默认上限值根据可用系统内存计算得出。</p>
</blockquote>
<h3 id="epoll-wait">epoll_wait</h3>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/epoll.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">epoll_wait</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">epfd</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> epoll_event *</span><span style="color:#ffb964;">evlist</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">maxevents</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">timeout</span><span style="color:#e8e8d3;">);
</span></code></pre>
<p>成功返回就绪态的文件描述符的个数，失败返回-1并设置errno</p>
<p>参数evlist指向的结构体数组中返回的是有关就绪态文件描述符的信息。数组evlist的空间由调用者负责申请，所包含的元素个数在参数maxevents中指定。</p>
<p>在数组evlist中每个元素返回的都是单个就绪态文件描述符的信息：</p>
<ul>
<li>events字段返回在该描述符上已经发生的事件掩码</li>
<li>data字段返回的是适用epoll_ctl()注册监听事件时在ev.data中所指定的值。data字段是唯一可获知同这个事件相关的文件描述符号的途径，因此，在调用epoll_ctl()时要么将ev.data.fd设为文件描述符号，要么将ev.data.ptr设为指向包含文件描述符号的结构体</li>
</ul>
<p>参数timeout用来确定epoll_wait()的阻塞行为：</p>
<ul>
<li>timeout为-1，调用将一直阻塞，直到兴趣列表中的文件描述符上有事件发生，或者直到捕获到一个信号为止</li>
<li>timeout为0，执行一次非阻塞式的检查</li>
<li>timeout大于0，调用将阻塞至多timeout毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止</li>
</ul>
<p>在多线程程序中，可以在一个线程中使用epoll_ctl()将文件描述符添加到另一个线程中由epoll_wait()所监视的epoll实例的兴趣列表中去。这些对兴趣列表的修改将立刻得到处理，而epoll_wait()调用将返回有关新添加的文件描述符的就绪信息。</p>
<p>epoll事件：除了有一个额外的前缀E外，大多数位掩码的名称同poll中对应的事件掩码名称相同。例外情况：</p>
<ul>
<li>EPOLLET：epoll支持边缘触发</li>
<li>EPOLLONESHOT：只触发一次，触发完标记为非激活状态，需要使用EPOLL_CTL_MOD操作重新激活对这个文件描述符的检查</li>
</ul>
<p><img src="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%8D%E7%94%A8/image-20210126233317669.png" alt="image-20210126233317669" /></p>
<p><strong>epoll程序示例：</strong></p>
<pre style="background-color:#151515;">
<code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">sys/epoll.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">fcntl.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">string.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdio.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdlib.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">unistd.h</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">errno.h</span><span style="color:#556633;">&gt;


</span><span style="color:#8fbfdc;">#define </span><span style="color:#ffb964;">MAX_BUF     </span><span style="color:#cf6a4c;">1000
</span><span style="color:#8fbfdc;">#define </span><span style="color:#ffb964;">MAX_EVENTS  </span><span style="color:#cf6a4c;">5

</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">main</span><span style="color:#e8e8d3;">(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">argc</span><span style="color:#e8e8d3;">, </span><span style="color:#8fbfdc;">char</span><span style="color:#e8e8d3;">* </span><span style="color:#ffb964;">argv</span><span style="color:#e8e8d3;">[]){
    </span><span style="color:#8fbfdc;">int</span><span style="color:#e8e8d3;"> epfd, ready, fd, s, j, numOpenFds;
    </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> epoll_event ev;
    </span><span style="color:#8fbfdc;">struct</span><span style="color:#e8e8d3;"> epoll_event evlist[MAX_EVENTS];
    </span><span style="color:#8fbfdc;">char</span><span style="color:#e8e8d3;"> buf[MAX_BUF];

    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(argc &lt; </span><span style="color:#cf6a4c;">2 </span><span style="color:#e8e8d3;">|| strcmp(argv[</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">], </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">--help</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">)==</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">usage: </span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;"> file...\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, argv[</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">]);
        exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    }

    epfd = </span><span style="color:#ffb964;">epoll_create</span><span style="color:#e8e8d3;">(argc - </span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(epfd == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error epoll_create</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
        exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
    }

    </span><span style="color:#8fbfdc;">for</span><span style="color:#e8e8d3;">(j = </span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">; j &lt; argc; j++){
        fd = </span><span style="color:#ffb964;">open</span><span style="color:#e8e8d3;">(argv[j], O_RDONLY);
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(fd == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error open</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
            exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
        }
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Opened \&quot;</span><span style="color:#7697d6;">%s</span><span style="color:#99ad6a;">\&quot; on fd </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, argv[j], fd);

        ev.</span><span style="color:#ffb964;">events </span><span style="color:#e8e8d3;">= EPOLLIN;
        ev.</span><span style="color:#ffb964;">data</span><span style="color:#e8e8d3;">.</span><span style="color:#ffb964;">fd </span><span style="color:#e8e8d3;">= fd;
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(</span><span style="color:#ffb964;">epoll_ctl</span><span style="color:#e8e8d3;">(epfd, EPOLL_CTL_ADD, fd, &amp;ev) == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error epoll_ctl</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
            exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
        }
    }

    numOpenFds = argc - </span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">;

    </span><span style="color:#8fbfdc;">while</span><span style="color:#e8e8d3;">(numOpenFds &gt; </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">){
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">About to epoll_wait()\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
        ready = </span><span style="color:#ffb964;">epoll_wait</span><span style="color:#e8e8d3;">(epfd, evlist, MAX_EVENTS, -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
        </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(ready == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
            </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(errno == EINTR)</span><span style="color:#8fbfdc;">continue</span><span style="color:#e8e8d3;">;
            </span><span style="color:#8fbfdc;">else</span><span style="color:#e8e8d3;">{
                printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error epoll_wait</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
                exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
            }
        }
        printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Ready: </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, ready);

        </span><span style="color:#8fbfdc;">for</span><span style="color:#e8e8d3;">(j = </span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">; j &lt; ready; j++){
            printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">  fd = </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">; events: </span><span style="color:#7697d6;">%s%s%s</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, evlist[j].</span><span style="color:#ffb964;">data</span><span style="color:#e8e8d3;">.</span><span style="color:#ffb964;">fd</span><span style="color:#e8e8d3;">,
                (evlist[j].</span><span style="color:#ffb964;">events </span><span style="color:#e8e8d3;">&amp; EPOLLIN)  ? </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">EPOLLIN </span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">:</span><span style="color:#556633;">&quot;&quot;</span><span style="color:#e8e8d3;">,
                (evlist[j].</span><span style="color:#ffb964;">events </span><span style="color:#e8e8d3;">&amp; EPOLLHUP) ? </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">EPOLLHUP</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">:</span><span style="color:#556633;">&quot;&quot;</span><span style="color:#e8e8d3;">,
                (evlist[j].</span><span style="color:#ffb964;">events </span><span style="color:#e8e8d3;">&amp; EPOLLERR) ? </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">EPOLLERR</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">:</span><span style="color:#556633;">&quot;&quot;</span><span style="color:#e8e8d3;">);
            </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(evlist[j].</span><span style="color:#ffb964;">events </span><span style="color:#e8e8d3;">&amp; EPOLLIN){
                s = </span><span style="color:#ffb964;">read</span><span style="color:#e8e8d3;">(evlist[j].</span><span style="color:#ffb964;">data</span><span style="color:#e8e8d3;">.</span><span style="color:#ffb964;">fd</span><span style="color:#e8e8d3;">, buf, MAX_BUF);
                </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(s == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
                    printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error read</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
                }
                printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    read </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;"> bytes : </span><span style="color:#7697d6;">%.*s</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">,s,s,buf);
            }
            </span><span style="color:#8fbfdc;">else if</span><span style="color:#e8e8d3;">(evlist[j].</span><span style="color:#ffb964;">events </span><span style="color:#e8e8d3;">&amp; (EPOLLHUP | EPOLLERR)){
                printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">    closing fd </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">, evlist[j].</span><span style="color:#ffb964;">data</span><span style="color:#e8e8d3;">.</span><span style="color:#ffb964;">fd</span><span style="color:#e8e8d3;">);
                </span><span style="color:#8fbfdc;">if</span><span style="color:#e8e8d3;">(</span><span style="color:#ffb964;">close</span><span style="color:#e8e8d3;">(evlist[j].</span><span style="color:#ffb964;">data</span><span style="color:#e8e8d3;">.</span><span style="color:#ffb964;">fd</span><span style="color:#e8e8d3;">) == -</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">){
                    printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">error close</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
                    exit(</span><span style="color:#cf6a4c;">1</span><span style="color:#e8e8d3;">);
                }
                numOpenFds--;
            }
        }
    }
    printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">All file descriptors closed; bye\n</span><span style="color:#556633;">&quot;</span><span style="color:#e8e8d3;">);
    exit(</span><span style="color:#cf6a4c;">0</span><span style="color:#e8e8d3;">);
}
</span></code></pre>
        </div>

        
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2021
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
