<!doctype html><html lang=zh-Hans-CN><head><title>modao's blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://modao.site/style.css rel=stylesheet><link href=https://modao.site/color/green.css rel=stylesheet><link href=https://modao.site/color/background_dark.css rel=stylesheet><link href=https://modao.site/font-hack.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-N2WTGJE0M5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N2WTGJE0M5');</script><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a style="text-decoration: none;" href=https://modao.site> <div class=logo>MODAO</div> </a></div></div><nav class=menu><ul class=menu__inner><li class=active><a href=https://modao.site>Home</a><li><a href=https://modao.site/tags>Tags</a><li><a href=https://modao.site/language>PL</a><li><a href=https://modao.site/books>Books</a><li><a href=https://modao.site/links>Links</a><li><a href=https://modao.site/friend>Friend</a></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href="https://modao.site/算法与数据结构/Data Structures/shu-ju-jie-gou-gai-nian-luo-lie/">数据结构概念罗列</a></h1><div class=post-meta-inline><span class=post-date> 2020-12-28 </span></div><span class=post-tags-inline> :: tags:  <a class=post-tag href=https://modao.site/tags/algorithm/>#Algorithm</a></span><div class=post-content><p>数据结构概念罗列<h2 id=xu-lun>绪论</h2><p>数据：信息的载体<p>数据元素：数据的基本单位<p>数据对象：数据的一个子集<p>数据类型：一个值的集合和定义在此集合上的一组操作的总称<ul><li>原子类型：值不可再分<li>结构类型：值可再分<li>抽象数据类型：抽象数据组织及其相关操作</ul><p>数据结构：相互之间存在一种或多种特定关系的数据元素的集合<ul><li>逻辑结构 <ul><li>线性结构<li>非线性结构</ul><li>存储结构 <ul><li>顺序存储<li>链式存储<li>索引存储<li>散列存储</ul><li>数据的运算</ul><p>算法：对特定问题求解的一种描述<ul><li>五个特性：有穷性、确定性、可行性、0个或多个输入、1个或多个输出<li>描述算法效率的度量 <ul><li>时间复杂度<li>空间复杂度 <ul><li>算法原地工作是指算法所需的辅助空间为常量，即O(1)</ul></ul></ul><h2 id=xian-xing-biao>线性表</h2><p>存储结构：<ul><li>顺序存储：顺序表<li>链式存储： <ul><li>单链表<li>双链表<li>循环链表<li>静态链表（数组实现）</ul></ul><h2 id=zhan-he-dui-lie>栈和队列</h2><p>栈和队列：操作受限的线性表<p>栈：<ul><li>顺序栈<li>链栈<li>共享栈</ul><p>队列：<ul><li>循环队列<li>链式队列<li>双端队列</ul><h2 id=zi-fu-chuan>字符串</h2><p>存储结构：<ul><li>定长顺序存储（数组）<li>堆分配存储（动态数组）<li>块链存储</ul><p>模式匹配算法：<ul><li>暴力匹配法：O(mn)<li>KMP算法：通过部分匹配值避免重头匹配<li>KMP算法进一步改进：改进next数组，递归创建next数组，避免$p_j = p_{next[j]}$</ul><h2 id=shu-yu-er-cha-shu>树与二叉树</h2><p>特点：<ul><li>树的根结点没有前驱结点，除根节点以为的所有结点有且只有一个直接前驱<li>树中所有结点可以有零个或多个后继</ul><p>结点的度：结点的孩子个数<p>分支结点：度大于0的结点<p>叶子结点：度为0的结点<p>结点的层次从根结点开始定义，根节点在第一层<p>结点的深度：从根结点自顶向下逐层累加<p>结点的高度：从叶结点开始自底向上累加<p>有序树：结点子树有次序，不可互换<p>无序树：结点子树无次序，可呼唤<p>路径：两个结点之间所经过的结点序列<p>路径长度：路径上所经过的边的个数<p>森林：M棵互不相交的树的集合<p>树最基本的性质：<ul><li>结点数 = 所有结点的度数+1<li>度为m的树中，第i层至多有$m^{i-1}（i\ge1）$个结点<li>高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点<li>具有n个结点的m叉树的最小高度为$\lceil log_m(n(m-1)+1)\rceil$</ul><p>二叉树：n个结点的有限集合<ul><li>或者为空二叉树，n=0<li>或者为根结点+左右子树（递归二叉树）</ul><p>特殊的二叉树：<ul><li>满二叉树<li>完全二叉树<li>二叉排序树：左子树 < 根结点 < 右子树<li>平衡二叉树：任一结点的左右子树深度之差不超过1</ul><p>二叉树的性质：<ul><li>非空二叉树的叶子结点树等于度为2的结点数+1<li>非空二叉树第k层至多有$2^{k-1}$个结点<li>高度为h的二叉树至多有$2^h-1$个结点<li>从根结点开始，从1开始编号 <ul><li>当i > 1 时，结点 i 的双亲编号为$\lfloor i/2 \rfloor$<li>当 2i <= n 时，左孩子存在，编号为 2i<li>当 2i + 1 <= n 时，右孩子存在，编号为 2i + 1</ul><li>具有 n (n > 0) 个结点的完全二叉树的高度为$\lceil log_2(n+1) \rceil$或$\lfloor log_2n \rfloor + 1$</ul><p>二叉树存储结构：<ul><li>顺序存储结构<li>链式存储结构</ul><p>三种常用的存储结构：<ul><li>双亲表示法<li>孩子表示法<li>孩子兄弟表示法</ul><p>二叉树的遍历：根据根节点的访问顺序，递归<ul><li>先序遍历<li>中序遍历<li>后序遍历<li>层次遍历（借助辅助队列，FIFO）</ul><p>由二叉树的先序序列和中序序列可以唯一确定一棵二叉树<p>由二叉树的后序序列和中序序列可以唯一确定一棵二叉树<p>由二叉树的层序序列和中序序列可以唯一确定一棵二叉树<p>线索二叉树：二叉树的结点排列成一个线性序列<p>二叉树的线索化是将二叉链表中的空指针指向前驱或后继的线索，前驱和后继只有在遍历时才能得到，所以线索化实质是遍历一次二叉树。<p>树转换为二叉树规则：左孩子右兄弟<table><thead><tr><th>树<th>森林<th>二叉树<tbody><tr><td>先根遍历<td>先序遍历<td>先序遍历<tr><td>后根遍历<td>中序遍历<td>中序遍历</table><p>二叉树的应用<ul><li>二叉排序树（BST） <ul><li>查找：从根结点开始，二分查找<li>插入： <ul><li>树空时直接插入<li>非空时插入到查找失败时路径上的最后一个结点的左孩子或右孩子</ul><li>构造：依次插入<li>删除： <ul><li>叶子结点直接删除<li>若删除的结点只有一个孩子，则直接替代<li>有两个孩子，则用直接前驱或直接后继替代</ul><li>查找效率 <ul><li>平衡二叉树：$O(log_2n)$<li>退化成链表：O(n)</ul></ul><li>平衡二叉树：避免树的高度增长过快，降低二叉排序树的性能 <ul><li>插入： <ul><li>LL平衡旋转（右单旋转）<li>RR平衡旋转（左单旋转）<li>LR平衡旋转（先左后右双旋转）<li>RL平衡旋转（先右后左双旋转）</ul><li>查找：$O(log_2n)$</ul><li>哈夫曼树：带权路径长度（WPL）最小的二叉树，最优二叉树 <ul><li>构造过程 <ul><li>根据给定的 n 个权值，构造具有 n 棵扩充二叉树的森林<li>在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值<li>从森林中删除这两棵树，同时把新树加入到森林中<li>重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树</ul><li>哈夫曼编码是一种被广泛应用且非常有效的数据压缩编码</ul></ul><h2 id=tu>图</h2><p>图G：顶点集V和边集E组成，G=(V, E)，顶点集一定非空<p>有向图：E是有向边（弧）的有限集合，弧是顶点的有序对，记为&LTv,w><p>无向图：E是无向边（边）的有限集合，边是顶点的无序对，记为(v,w)<p>简单图：不存在重复边，不存在顶点到自身的边<p>多重图：两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联<p>（简单）完全图：任意两个顶点之间都存在边<ul><li>有向：n(n-1)<li>无向：n(n-1)/2</ul><p>子图：<strong>前提是图</strong>，顶点集和边集是子集。顶点集完全一样则为生成子图。<p>连通：无向图中，顶点v到顶点w有路径存在<p>连通图：无向图中，任意两个顶点都是连通的<p>连通分量：无向图中的极大连通子图<p>强连通：有向图中，从顶点v到w和从w到v之间都有路径<p>强连通图：有向图中，任意一对顶点都是强连通的<p>强连通分量：有向图中的极大强连通子图<p>连通图的生成树：包含图中全部顶点的一个极小连通子图，若顶点数为n，则边数为n-1<p>非连通图的生成森林：连通分量的生成树<p>顶点的度：TD(v)<p>顶点的入度：ID(v)<p>顶点的出度：OD(v)<p>TD(v) = ID(v) + OD(v)<p>带权图（网）：有权值的图<p>稠密图、稀疏图：|E| < |V| log|V|时，为稀疏图，反之为稠密图<p>路径长度：路径上边的数目<p>回路（环）：若一个图有n个顶点，并且有大于 n-1 条边，则此图有环<p>简单路径：顶点不重复出现<p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路<p>距离：顶点之间的最短路径的长度，不存在路径距离为无穷<p>有向树：一个顶点入度为0，其余顶点入度均为1的有向图<p>图的存储：<ul><li>邻接矩阵法<li>邻接表法<li>十字链表法：有向图的一种链式存储结构，易求得入度和出度<li>邻接多重表：无向图的一种链式存储结构，易得到顶点和边的各种信息，<strong>且易于判断两点之间是否存在边（邻接表的缺陷）</strong></ul><p>图的遍历：<ul><li>广度优先搜索（BFS），类似二叉树的层序遍历 <ul><li>广度遍历中，可得到遍历树：广度优先生成树 <ul><li>图的邻接矩阵存储表示唯一，故广度优先生成树也唯一<li>图的邻接表存储表示不唯一，故广度优先生成树不唯一</ul></ul><li>深度优先搜索（DFS） <ul><li>深度优先搜索 <ul><li>对连通图DFS会产生一棵深度优先生成树<li>否则产生深度优先生成森林<li>基于邻接表存储的深度优先生成树不唯一</ul></ul></ul><p>图的应用：<ul><li><p>最小生成（代价）树</p> <ul><li>性质 <ul><li>最小生成树（树形）不唯一<li>最小生成树的边的权值总和唯一<li>最小生成树的边数为定点数减一</ul><li>最小生成树算法（贪心策略） <ul><li>Prim算法：$O(|V|^2)$，<strong>适合边稠密的图</strong><li>Kruskal算法：$O(|E|log|E|)$，<strong>适合边稀疏而顶点较多的图</strong></ul></ul><li><p>最短路径</p> <ul><li>最短路径算法依赖一种性质：两点之间的最短路径也包含了路径上的其他顶点间的最短路径<li>Dijkstra（迪杰斯特拉）算法：<strong>单源最短路径</strong>，即求图中某一顶点到其他各顶点的最短路径，不适用于边上带有负权值，$O(|V|^2)$<li>Floyd（弗洛依德）算法：<strong>求每对顶点之间的最短路径</strong>，$O(|V|^3)$，代码紧凑且不包含复杂数据结构，因此隐含的常数系数很小 <ul><li>允许带负权值的边，但不允许有包含带负权值的边组成回路<li>适用于带权无向图，可视为权值相同往返二重边的有向图<li>每个顶点轮流运行一次Dijkstra算法，时间复杂度为$O(|V|^2)·|V|=O(|V|^3)$</ul></ul><li><p>有向无环图：DAG图，描述含有公共子式的表达式的有效工具，代替二叉树可节省存储空间</p><li><p>拓扑排序：由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p> <ol><li><p>每个顶点出现且只出现一次</p><li><p>若顶点A在序列中排在B的前面，则不存在从B到A的路径</p></ol><li><p>关键路径：AOE网中，从源点到汇点的所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，把<strong>关键路径</strong>上面的活动称为<strong>关键活动</strong>。</p> <ul><li>事件vk最早发生时间ve(k)<li>事件vk最迟发生时间vl(k)<li>活动ai最早开始时间e(i)<li>活动ai最迟开始时间l(i)<li>差额d(i) = l(i) - e(i)，差额为0的活动ai是关键活动<li><strong>选择题根据ve的计算过程即可知道关键路径</strong></ul></ul><p>AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边&LTVi, Vj>表示活动Vi必须先于活动Vj进行的这样一种关系，则将这种有向图称为用顶点表示活动的网络，记为AOV网。每个AOV网都有一个或多个拓扑排序序列<p>AOE网：在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为用边表示活动的网络，简称AOE网。<h2 id=cha-zhao>查找</h2><p>顺序查找：<ul><li>$ASL_{成功} = \sum_{i=1}^nP_i(n-i+1)=\frac {n+1} 2$<li>$ASL_{不成功} = n +1$<li>有序顺序表查找判定树：$ASL_{不成功} = \frac{n}{2} + \frac{n+1}{n}$</ul><p>折半查找/二分查找：<ul><li>$ASL = log_2(n+1)-1$<li>$O(log_2n)$</ul><p>分块查找<ul><li>块内和索引表均顺序查找：$ASL=L_i+L_S$<li>索引表折半查找，块内顺序查找：$ASL=\lceil log_2(b+1)+\frac{s+1}{2}\rceil$</ul><p>B树（多路平衡查找树）：<ul><li>插入：插入叶节点，溢出则分裂上移<li>删除： <ul><li>非终端结点，使用前驱或后继替代<li>终端结点： <ul><li>直接删除<li>兄弟够借，父节点关键字取代删除结点，兄弟关键字结点上移<li>兄弟不够借，父节点关键字和兄弟结点合并</ul></ul></ul><p>B+树：操作与B树类似，但叶子结点包含信息，非叶结点仅起索引作用<p>散列表：建立了关键字和存储地址之间的一种之间映射关系，O(1)<ul><li>散列构造： <ul><li>直接定址法<li>除留余数法<li>数字分析法<li>平方取中法</ul><li>处理冲突的方法 <ul><li>开放定址法 <ul><li>线性探测法<li>平方探测法（二次探测法）<li>再散列法</ul><li>拉链法：同义词存储在线性链表</ul><li>查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子 <ul><li>装填因子，定义为一个表的装满程度，$\alpha=\frac{表中记录数n}{散列表长度m}$<li>散列表的平均查找长度不直接依赖于n或m，装得越满，发生冲突的可能越大</ul></ul><h2 id=pai-xu>排序</h2><p>直接插入排序：<ul><li>空间复杂度$O(1)$<li>时间复杂度$O(n^2)$</ul><p>折半插入排序：折半查找插入位置，统一移动元素<p>希尔排序：<ul><li>空间复杂度$O(1)$<li>时间复杂度$O(n^2)$</ul><p>冒泡排序：<ul><li>空间复杂度$O(1)$<li>时间复杂度$O(n^2)$</ul><p>快速排序：<ul><li>空间复杂度$O(log_2n)$<li>时间复杂度$O(nlog_2n)$<li>所有内部排序中平均性能最优的排序算法<li>每趟排序后会将枢轴（基准）元素放到最终位置上</ul><p>简单选择排序：<ul><li>空间复杂度$O(1)$<li>时间复杂度$O(n^2)$</ul><p>堆排序：<ul><li>空间复杂度$O(1)$<li>时间复杂度$O(nlog_2n)$</ul><p>归并排序：<ul><li>空间复杂度$O(n)$<li>时间复杂度$O(nlog_2n)$</ul><p>基数排序<p>外部排序：<ul><li>多路平衡归并和败者树<li>置换-选择排序（生成初始归并段）<li>最佳归并树</ul></div></div></div><footer class=footer__poweredby><p class=caption>© 2022 All Rights Reserved modao::rustacean@aliyun.com<p class=caption>© Powered by <a href=https://www.getzola.org/>Zola</a><p class=caption>© Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman<p class=caption><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh rel=license>自由转载-非商用-非衍生-保持署名</a></footer></div>